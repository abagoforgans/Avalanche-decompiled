contract main {




// =====================  Runtime code  =====================


#
#  - sub_35bc07c2(?)
#  - sub_d332c570(?)
#
address owner;
uint256 stor1;
uint8 stor2;
address sub_93066351Address; offset 8
address sub_52b8bedfAddress;
address sub_809deb63Address;
address sub_f9318b45Address;
address sub_c38eb669Address;
address sub_d6e04f10Address;
uint256 sub_041c6ed1;
uint256 sub_01f47d88;
uint8 sub_7f75077a;
uint8 sub_ce9efb02; offset 8
uint256 sub_0e5a7486;
uint256 sub_696d77d3;
uint256 sub_e625866a;
uint256 sub_6508597e;
uint256 sub_c7cd2b04;
uint256 sub_599a3d39;
uint256 sub_a45de402;
uint256 sub_28ad4335;
uint256 sub_582ae153;
uint256 sub_263d0f4e;
uint256 sub_fc7c54de;
uint256 sub_9961d780;
uint256 sub_23422e8d;
uint256 sub_ba986a80;
uint256 sub_2616c3e7;
uint256 sub_3b7f8113;
address WITHDRAW_ADDRESS;
mapping of uint8 stor28;

function sub_01f47d88(?) {
    return sub_01f47d88
}

function sub_041c6ed1(?) {
    return sub_041c6ed1
}

function sub_0e5a7486(?) {
    return sub_0e5a7486
}

function WITHDRAW_ADDRESS() {
    return WITHDRAW_ADDRESS
}

function sub_23422e8d(?) {
    return sub_23422e8d
}

function sub_2616c3e7(?) {
    return sub_2616c3e7
}

function sub_263d0f4e(?) {
    return sub_263d0f4e
}

function sub_28ad4335(?) {
    return sub_28ad4335
}

function sub_3b7f8113(?) {
    return sub_3b7f8113
}

function sub_52b8bedf(?) {
    return sub_52b8bedfAddress
}

function sub_582ae153(?) {
    return sub_582ae153
}

function sub_599a3d39(?) {
    return sub_599a3d39
}

function paused() {
    return bool(stor2)
}

function sub_6508597e(?) {
    return sub_6508597e
}

function sub_696d77d3(?) {
    return sub_696d77d3
}

function sub_7f75077a(?) {
    return sub_7f75077a
}

function sub_809deb63(?) {
    return sub_809deb63Address
}

function owner() {
    return owner
}

function sub_93066351(?) {
    return sub_93066351Address
}

function sub_9961d780(?) {
    return sub_9961d780
}

function sub_a45de402(?) {
    return sub_a45de402
}

function sub_ba986a80(?) {
    return sub_ba986a80
}

function sub_c38eb669(?) {
    return sub_c38eb669Address
}

function sub_c7cd2b04(?) {
    return sub_c7cd2b04
}

function sub_ce9efb02(?) {
    return sub_ce9efb02
}

function sub_d6e04f10(?) {
    return sub_d6e04f10Address
}

function sub_e625866a(?) {
    return sub_e625866a
}

function sub_f9318b45(?) {
    return sub_f9318b45Address
}

function sub_fc7c54de(?) {
    return sub_fc7c54de
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_16301a33(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_23422e8d = arg1
}

function sub_2ad8a20b(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_c7cd2b04 = arg1
}

function sub_549c8ea4(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_fc7c54de = arg1
}

function sub_554052f4(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_696d77d3 = arg1
}

function sub_57eb055e(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_ba986a80 = arg1
}

function sub_89a21120(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_6508597e = arg1
}

function sub_93c2c383(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_01f47d88 = arg1
}

function sub_ac34cb12(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_a45de402 = arg1
}

function sub_aef3df3d(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_28ad4335 = arg1
}

function sub_c026d404(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_582ae153 = arg1
}

function sub_c805973c(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_599a3d39 = arg1
}

function sub_d433233a(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_0e5a7486 = arg1
}

function sub_f3e6d709(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_9961d780 = arg1
}

function sub_fdb18a19(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_041c6ed1 = arg1
}

function addAdmin(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor28[address(arg1)] = 1
}

function sub_5d7da486(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_7f75077a = uint8(arg1)
}

function sub_f2787f86(?) {
    require calldata.size - 4 >= 32
    require arg1 == uint8(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_ce9efb02 = uint8(arg1)
}

function removeAdmin(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor28[address(arg1)] = 0
}

function withdraw() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call WITHDRAW_ADDRESS with:
       value eth.balance(this.address) wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with 0, 'Failed to send funds'
}

function setWithdrawAddress(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if WITHDRAW_ADDRESS:
        revert with 0, 'Wallet already set'
    if not arg1:
        revert with 0, 'Cannot be set to the zero'
    WITHDRAW_ADDRESS = arg1
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function setContracts(address arg1, address arg2, address arg3, address arg4, address arg5, address arg6) {
    require calldata.size - 4 >= 192
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    require arg6 == arg6
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_52b8bedfAddress = arg1
    sub_809deb63Address = arg2
    sub_93066351Address = arg3
    sub_f9318b45Address = arg4
    sub_c38eb669Address = arg5
    sub_d6e04f10Address = arg6
}

function sub_0f508b9b(?) {
    if block.timestamp < sub_263d0f4e:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_28ad4335 and sub_7f75077a > -1 / sub_28ad4335:
        revert with 0, 17
    if sub_28ad4335 * sub_7f75077a / 100 and block.timestamp - sub_263d0f4e / sub_01f47d88 > -1 / sub_28ad4335 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_28ad4335 <= sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
        if 0 >= sub_582ae153:
            return 0
    else:
        if sub_28ad4335 < sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
            revert with 0, 17
        if sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) >= sub_582ae153:
            return (sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88))
    return sub_582ae153
}

function sub_4bbc0659(?) {
    if block.timestamp < sub_e625866a:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
        revert with 0, 17
    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
        if 0 >= sub_696d77d3:
            return 0
    else:
        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
            revert with 0, 17
        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
            return (sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88))
    return sub_696d77d3
}

function sub_5018eef2(?) {
    if block.timestamp < sub_2616c3e7:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_9961d780 and sub_7f75077a > -1 / sub_9961d780:
        revert with 0, 17
    if sub_9961d780 * sub_7f75077a / 100 and block.timestamp - sub_2616c3e7 / sub_01f47d88 > -1 / sub_9961d780 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_9961d780 <= sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
        if 0 >= sub_ba986a80:
            return 0
    else:
        if sub_9961d780 < sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
            revert with 0, 17
        if sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) >= sub_ba986a80:
            return (sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88))
    return sub_ba986a80
}

function sub_434ebc6a(?) {
    require calldata.size - 4 >= 32
    if stor2:
        revert with 0, 'Pausable: paused'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    staticcall sub_52b8bedfAddress.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < sub_3b7f8113:
        revert with 0, 'Not enough $worlds'
    if sub_3b7f8113 and arg1 > -1 / sub_3b7f8113:
        revert with 0, 17
    require ext_code.size(sub_52b8bedfAddress)
    call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args msg.sender, sub_3b7f8113 * arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(sub_d6e04f10Address)
    call sub_d6e04f10Address.mint(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit 0xe6e1b161: msg.sender, arg1
    stor1 = 1
}

function sub_f4630da7(?) {
    require calldata.size - 4 >= 32
    staticcall sub_93066351Address.isStaked(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        staticcall sub_809deb63Address.0x6352211e with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        return ext_call.return_data[12 len 20]
    staticcall sub_93066351Address.getStake(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 128
    if not bool((2 * ceil32(return_data.size)) + 224 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
    require ext_call.return_data[96] == ext_call.return_data[108 len 20]
    if not ext_call.return_data[108 len 20]:
        revert with 0, 'The owner cannot be address(0)'
    return ext_call.return_data[108 len 20]
}

function sub_32bef484(?) payable {
    require calldata.size - 4 >= 32
    call sub_809deb63Address.tokensMinted() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
    call sub_809deb63Address.0xad789acb with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if uint16(ext_call.return_data[0]) > !arg1:
        revert with 0, 17
    if uint16(ext_call.return_data[0]) + arg1 > ext_call.return_data[0]:
        revert with 0, 'All gen0 tokens minted'
    if arg1 <= 0:
        revert with 0, 'Invalid mint amount (max 10)'
    if arg1 > 10:
        revert with 0, 'Invalid mint amount (max 10)'
    if arg1 and sub_041c6ed1 > -1 / arg1:
        revert with 0, 17
    if arg1 * sub_041c6ed1 != msg.value:
        revert with 0, 'Unsufficient amount'
    idx = 0
    while idx < arg1:
        mem[(2 * ceil32(return_data.size)) + 96] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(2 * ceil32(return_data.size)) + 132] = 1
        require ext_code.size(sub_809deb63Address)
        call sub_809deb63Address.mint(address arg1, bool arg2) with:
             gas gas_remaining wei
            args msg.sender, 1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_158bbbb8(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[100] = address(arg1)
    staticcall sub_f9318b45Address.0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = 0
    while idx < ext_call.return_data[0]:
        mem[mem[64] + 4] = address(arg1)
        mem[mem[64] + 36] = idx
        staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                gas gas_remaining wei
               args address(arg1), idx
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                gas gas_remaining wei
               args mem[_23]
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _27 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _28 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 96
        mem[_28] = mem[_27]
        mem[_28 + 32] = mem[_27 + 32]
        mem[_28 + 64] = mem[_27 + 64]
        if 24 * 3600 > !mem[_28 + 64]:
            revert with 0, 17
        if block.timestamp < mem[_28 + 64] + (24 * 3600):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    return s
}

function sub_9fd1a781(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[100] = address(arg1)
    staticcall sub_c38eb669Address.0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = 0
    while idx < ext_call.return_data[0]:
        mem[mem[64] + 4] = address(arg1)
        mem[mem[64] + 36] = idx
        staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                gas gas_remaining wei
               args address(arg1), idx
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                gas gas_remaining wei
               args mem[_23]
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _27 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _28 = mem[64]
        if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 96
        mem[_28] = mem[_27]
        mem[_28 + 32] = mem[_27 + 32]
        mem[_28 + 64] = mem[_27 + 64]
        if 24 * 3600 > !mem[_28 + 64]:
            revert with 0, 17
        if block.timestamp < mem[_28 + 64] + (24 * 3600):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    return s
}

function sub_a6d365b7(?) {
    require calldata.size - 4 >= 64
    require arg1 == uint16(arg1)
    require arg2 == uint16(arg2)
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    if uint16(arg2) < 1:
        revert with 0, 'Invalid levelsToUpgrade.'
    idx = 1
    while uint16(idx) <= uint16(arg2):
        if uint16(arg1) > -uint16(idx) + 65535:
            revert with 0, 17
        if uint16(uint16(idx) + uint16(arg1)):
            if uint16(uint16(idx) + uint16(arg1)) != 1:
                if uint16(uint16(idx) + uint16(arg1)) != 2:
                    if uint16(uint16(idx) + uint16(arg1)) != 3:
                        if uint16(uint16(idx) + uint16(arg1)) != 4:
                            if uint16(uint16(idx) + uint16(arg1)) != 5:
                                if uint16(uint16(idx) + uint16(arg1)) != 6:
                                    if uint16(uint16(idx) + uint16(arg1)) != 7:
                                        if uint16(uint16(idx) + uint16(arg1)) != 8:
                                            if uint16(uint16(idx) + uint16(arg1)) != 9:
                                                if uint16(uint16(idx) + uint16(arg1)) != 10:
                                                    if uint16(uint16(idx) + uint16(arg1)) != 11:
                                                        if uint16(uint16(idx) + uint16(arg1)) != 12:
                                                            if uint16(uint16(idx) + uint16(arg1)) != 13:
                                                                if uint16(uint16(idx) + uint16(arg1)) != 14:
                                                                    if uint16(uint16(idx) + uint16(arg1)) != 15:
                                                                        if uint16(uint16(idx) + uint16(arg1)) != 16:
                                                                            if uint16(uint16(idx) + uint16(arg1)) != 17:
                                                                                if uint16(uint16(idx) + uint16(arg1)) != 18:
                                                                                    if uint16(uint16(idx) + uint16(arg1)) != 19:
                                                                                        if uint16(uint16(idx) + uint16(arg1)) != 20:
                                                                                            if uint16(uint16(idx) + uint16(arg1)) != 21:
                                                                                                if uint16(uint16(idx) + uint16(arg1)) != 22:
                                                                                                    if uint16(uint16(idx) + uint16(arg1)) != 23:
                                                                                                        if uint16(uint16(idx) + uint16(arg1)) != 24:
                                                                                                            if uint16(uint16(idx) + uint16(arg1)) != 25:
                                                                                                                if uint16(uint16(idx) + uint16(arg1)) <= 25:
                                                                                                                    revert with 0, 'This level is not supported yet'
        if uint16(idx) == 65535:
            revert with 0, 17
        idx = uint16(idx) + 1
        continue 
    revert with 0, 'Error calculating cost.'
}

function sub_63f3bbf1(?) {
    require calldata.size - 4 >= 32
    if stor2:
        revert with 0, 'Pausable: paused'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    if block.timestamp < sub_263d0f4e:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_28ad4335 and sub_7f75077a > -1 / sub_28ad4335:
        revert with 0, 17
    if sub_28ad4335 * sub_7f75077a / 100 and block.timestamp - sub_263d0f4e / sub_01f47d88 > -1 / sub_28ad4335 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_28ad4335 <= sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
        if 0 >= sub_582ae153:
            if arg1 and 0 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, 0
        else:
            if arg1 and sub_582ae153 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, arg1 * sub_582ae153
    else:
        if sub_28ad4335 < sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
            revert with 0, 17
        if sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) >= sub_582ae153:
            if arg1 and sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, (sub_28ad4335 * arg1) - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88 * arg1)
        else:
            if arg1 and sub_582ae153 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, arg1 * sub_582ae153
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(sub_c38eb669Address)
    call sub_c38eb669Address.mint(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if sub_28ad4335 and sub_ce9efb02 > -1 / sub_28ad4335:
        revert with 0, 17
    if block.timestamp < sub_263d0f4e:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_28ad4335 and sub_7f75077a > -1 / sub_28ad4335:
        revert with 0, 17
    if sub_28ad4335 * sub_7f75077a / 100 and block.timestamp - sub_263d0f4e / sub_01f47d88 > -1 / sub_28ad4335 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_28ad4335 <= sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
        if 0 >= sub_582ae153:
            if 0 > !(sub_28ad4335 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_28ad4335 = sub_28ad4335 * sub_ce9efb02 / 100
        else:
            if sub_582ae153 > !(sub_28ad4335 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_28ad4335 = sub_582ae153 + (sub_28ad4335 * sub_ce9efb02 / 100)
    else:
        if sub_28ad4335 < sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88:
            revert with 0, 17
        if sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) >= sub_582ae153:
            if sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) > !(sub_28ad4335 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_28ad4335 = sub_28ad4335 - (sub_28ad4335 * sub_7f75077a / 100 * block.timestamp - sub_263d0f4e / sub_01f47d88) + (sub_28ad4335 * sub_ce9efb02 / 100)
        else:
            if sub_582ae153 > !(sub_28ad4335 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_28ad4335 = sub_582ae153 + (sub_28ad4335 * sub_ce9efb02 / 100)
    sub_263d0f4e = block.timestamp
    emit 0x834bd4dc: msg.sender, arg1
    stor1 = 1
}

function sub_b089981b(?) {
    require calldata.size - 4 >= 32
    if stor2:
        revert with 0, 'Pausable: paused'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    if block.timestamp < sub_2616c3e7:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_9961d780 and sub_7f75077a > -1 / sub_9961d780:
        revert with 0, 17
    if sub_9961d780 * sub_7f75077a / 100 and block.timestamp - sub_2616c3e7 / sub_01f47d88 > -1 / sub_9961d780 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_9961d780 <= sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
        if 0 >= sub_ba986a80:
            if arg1 and 0 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, 0
        else:
            if arg1 and sub_ba986a80 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, arg1 * sub_ba986a80
    else:
        if sub_9961d780 < sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
            revert with 0, 17
        if sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) >= sub_ba986a80:
            if arg1 and sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, (sub_9961d780 * arg1) - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88 * arg1)
        else:
            if arg1 and sub_ba986a80 > -1 / arg1:
                revert with 0, 17
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, arg1 * sub_ba986a80
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(sub_f9318b45Address)
    call sub_f9318b45Address.mint(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if sub_9961d780 and sub_ce9efb02 > -1 / sub_9961d780:
        revert with 0, 17
    if block.timestamp < sub_2616c3e7:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_9961d780 and sub_7f75077a > -1 / sub_9961d780:
        revert with 0, 17
    if sub_9961d780 * sub_7f75077a / 100 and block.timestamp - sub_2616c3e7 / sub_01f47d88 > -1 / sub_9961d780 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_9961d780 <= sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
        if 0 >= sub_ba986a80:
            if 0 > !(sub_9961d780 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_9961d780 = sub_9961d780 * sub_ce9efb02 / 100
        else:
            if sub_ba986a80 > !(sub_9961d780 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_9961d780 = sub_ba986a80 + (sub_9961d780 * sub_ce9efb02 / 100)
    else:
        if sub_9961d780 < sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88:
            revert with 0, 17
        if sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) >= sub_ba986a80:
            if sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) > !(sub_9961d780 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_9961d780 = sub_9961d780 - (sub_9961d780 * sub_7f75077a / 100 * block.timestamp - sub_2616c3e7 / sub_01f47d88) + (sub_9961d780 * sub_ce9efb02 / 100)
        else:
            if sub_ba986a80 > !(sub_9961d780 * sub_ce9efb02 / 100):
                revert with 0, 17
            sub_9961d780 = sub_ba986a80 + (sub_9961d780 * sub_ce9efb02 / 100)
    sub_2616c3e7 = block.timestamp
    emit 0xcc18bdee: msg.sender, arg1
    stor1 = 1
}

function sub_a41a7458(?) {
    require calldata.size - 4 >= 32
    mem[96] = 0
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[384] = 0
    mem[416] = 0
    mem[448] = 0
    mem[480] = 0
    mem[512] = 0
    mem[544] = 0
    mem[576] = 0
    staticcall sub_809deb63Address.getTokenTraits(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[608 len 256] = ext_call.return_data[0 len 256]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 256
    if not bool(ceil32(return_data.size) + 864 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[ceil32(return_data.size) + 608] = ext_call.return_data[0]
    require ext_call.return_data[32] == bool(ext_call.return_data[32])
    mem[ceil32(return_data.size) + 640] = ext_call.return_data[32]
    require ext_call.return_data[64] == bool(ext_call.return_data[64])
    mem[ceil32(return_data.size) + 672] = ext_call.return_data[64]
    require ext_call.return_data[96] == ext_call.return_data[126 len 2]
    mem[ceil32(return_data.size) + 704] = ext_call.return_data[96]
    mem[ceil32(return_data.size) + 736] = ext_call.return_data[128]
    require ext_call.return_data[160] == ext_call.return_data[191 len 1]
    mem[ceil32(return_data.size) + 768] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 800] = ext_call.return_data[192]
    require ext_call.return_data[224] == ext_call.return_data[248 len 8]
    mem[ceil32(return_data.size) + 832] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 868] = arg1
    staticcall sub_93066351Address.isStaked(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(return_data.size) + 864] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        mem[(2 * ceil32(return_data.size)) + 868] = arg1
        staticcall sub_809deb63Address.0x6352211e with:
                gas gas_remaining wei
               args arg1
        mem[(2 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if 0 == ext_call.return_data[126 len 2]:
            return bool(ext_call.return_data[0]), 
                   bool(ext_call.return_data[32]),
                   bool(ext_call.return_data[64]),
                   ext_call.return_data[126 len 2],
                   ext_call.return_data[128],
                   ext_call.return_data[191 len 1],
                   ext_call.return_data[192],
                   ext_call.return_data[248 len 8]
        mem[(4 * ceil32(return_data.size)) + 868] = address(ext_call.return_data[0])
        staticcall sub_c38eb669Address.0x70a08231 with:
                gas gas_remaining wei
               args address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (6 * ceil32(return_data.size)) + 864
        require return_data.size >= 32
        idx = 0
        s = 0
        while idx < ext_call.return_data[0]:
            mem[mem[64] + 4] = address(ext_call.return_data[0])
            mem[mem[64] + 36] = idx
            staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0]), idx
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _140 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                    gas gas_remaining wei
                   args mem[_140]
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _149 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _152 = mem[64]
            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 96
            mem[_152] = mem[_149]
            mem[_152 + 32] = mem[_149 + 32]
            mem[_152 + 64] = mem[_149 + 64]
            if 24 * 3600 > !mem[_152 + 64]:
                revert with 0, 17
            if block.timestamp < mem[_152 + 64] + (24 * 3600):
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
    else:
        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                gas gas_remaining wei
               args arg1
        mem[(2 * ceil32(return_data.size)) + 864 len 128] = ext_call.return_data[0 len 128]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 128
        if not bool((4 * ceil32(return_data.size)) + 992 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == ext_call.return_data[30 len 2]
        mem[(4 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
        mem[(4 * ceil32(return_data.size)) + 896] = ext_call.return_data[32]
        mem[(4 * ceil32(return_data.size)) + 928] = ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[108 len 20]
        mem[(4 * ceil32(return_data.size)) + 960] = ext_call.return_data[96]
        if not ext_call.return_data[108 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if 0 == ext_call.return_data[126 len 2]:
            return bool(ext_call.return_data[0]), 
                   bool(ext_call.return_data[32]),
                   bool(ext_call.return_data[64]),
                   ext_call.return_data[126 len 2],
                   ext_call.return_data[128],
                   ext_call.return_data[191 len 1],
                   ext_call.return_data[192],
                   ext_call.return_data[248 len 8]
        mem[(4 * ceil32(return_data.size)) + 996] = ext_call.return_data[108 len 20]
        staticcall sub_c38eb669Address.0x70a08231 with:
                gas gas_remaining wei
               args ext_call.return_data[108 len 20]
        mem[(4 * ceil32(return_data.size)) + 992] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (6 * ceil32(return_data.size)) + 992
        require return_data.size >= 32
        idx = 0
        s = 0
        while idx < ext_call.return_data[0]:
            mem[mem[64] + 4] = address(ext_call.return_data[96])
            mem[mem[64] + 36] = idx
            staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[96]), idx
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _141 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                    gas gas_remaining wei
                   args mem[_141]
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _151 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _153 = mem[64]
            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 96
            mem[_153] = mem[_151]
            mem[_153 + 32] = mem[_151 + 32]
            mem[_153 + 64] = mem[_151 + 64]
            if 24 * 3600 > !mem[_153 + 64]:
                revert with 0, 17
            if block.timestamp < mem[_153 + 64] + (24 * 3600):
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
    if s and sub_23422e8d > -1 / s:
        revert with 0, 17
    if s * sub_23422e8d > !sub_fc7c54de:
        revert with 0, 17
    if block.timestamp < mem[ceil32(return_data.size) + 736]:
        revert with 0, 17
    if not (s * sub_23422e8d) + sub_fc7c54de:
        revert with 0, 18
    if uint16(block.timestamp - mem[ceil32(return_data.size) + 736] / (s * sub_23422e8d) + sub_fc7c54de) > mem[ceil32(return_data.size) + 734 len 2]:
        mem[ceil32(return_data.size) + 704] = 0
        mem[mem[64]] = bool(mem[ceil32(return_data.size) + 608])
        mem[mem[64] + 32] = bool(mem[ceil32(return_data.size) + 640])
        mem[mem[64] + 64] = bool(mem[ceil32(return_data.size) + 672])
        mem[mem[64] + 96] = 0
        mem[mem[64] + 128] = mem[ceil32(return_data.size) + 736]
        mem[mem[64] + 160] = mem[ceil32(return_data.size) + 799 len 1]
        mem[mem[64] + 192] = mem[ceil32(return_data.size) + 800]
        mem[mem[64] + 224] = mem[ceil32(return_data.size) + 856 len 8]
        return mem[mem[64] len 96], 0, mem[mem[64] + 128 len 128]
    if mem[ceil32(return_data.size) + 734 len 2] < uint16(block.timestamp - mem[ceil32(return_data.size) + 736] / (s * sub_23422e8d) + sub_fc7c54de):
        revert with 0, 17
    mem[ceil32(return_data.size) + 704] = uint16(mem[ceil32(return_data.size) + 734 len 2] - uint16(block.timestamp - mem[ceil32(return_data.size) + 736] / (s * sub_23422e8d) + sub_fc7c54de))
    mem[mem[64]] = bool(mem[ceil32(return_data.size) + 608])
    mem[mem[64] + 32] = bool(mem[ceil32(return_data.size) + 640])
    mem[mem[64] + 64] = bool(mem[ceil32(return_data.size) + 672])
    mem[mem[64] + 96] = mem[ceil32(return_data.size) + 734 len 2]
    mem[mem[64] + 128] = mem[ceil32(return_data.size) + 736]
    mem[mem[64] + 160] = mem[ceil32(return_data.size) + 799 len 1]
    mem[mem[64] + 192] = mem[ceil32(return_data.size) + 800]
    mem[mem[64] + 224] = mem[ceil32(return_data.size) + 856 len 8]
    return memory
      from mem[64]
       len 256
}

function sub_23c67f42(?) {
    require calldata.size - 4 >= 32
    if stor2:
        revert with 0, 'Pausable: paused'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    call sub_809deb63Address.0xad789acb with:
         gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    call sub_809deb63Address.tokensMinted() with:
         gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
    if ext_call.return_data[30 len 2] < ext_call.return_data[0]:
        revert with 0, 'GEN1 sale has not started yet'
    call sub_809deb63Address.tokensMinted() with:
         gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
    call sub_809deb63Address.MAX_TOKENS() with:
         gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if uint16(ext_call.return_data[0]) > !arg1:
        revert with 0, 17
    if uint16(ext_call.return_data[0]) + arg1 > ext_call.return_data[0]:
        revert with 0, 'All tokens minted'
    if arg1 <= 0:
        revert with 0, 'Invalid mint amount (max 10)'
    if arg1 > 10:
        revert with 0, 'Invalid mint amount (max 10)'
    if block.timestamp < sub_e625866a:
        revert with 0, 17
    if not sub_01f47d88:
        revert with 0, 18
    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
        revert with 0, 17
    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
        revert with 0, 17
    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
        if 0 >= sub_696d77d3:
            if False and arg1 > 0:
                revert with 0, 17
            revert with 0, 'GEN1 mint cost cannot be 0'
        if sub_696d77d3 and arg1 > -1 / sub_696d77d3:
            revert with 0, 17
        if sub_696d77d3 * arg1 <= 0:
            revert with 0, 'GEN1 mint cost cannot be 0'
        mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(6 * ceil32(return_data.size)) + 132] = sub_696d77d3 * arg1
        require ext_code.size(sub_52b8bedfAddress)
        call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args msg.sender, sub_696d77d3 * arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if arg1 > test266151307():
            revert with 0, 65
        mem[(6 * ceil32(return_data.size)) + 96] = arg1
        mem[64] = (6 * ceil32(return_data.size)) + (32 * arg1) + 128
        if not arg1:
            idx = 0
            s = 0
            s = 0
            s = ext_call.return_data[0]
            while idx < arg1:
                if uint16(s) == 65535:
                    revert with 0, 17
                _258 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = uint16(s) + 1 << 240
                _259 = mem[64]
                mem[mem[64]] = 54
                mem[64] = mem[64] + 86
                _261 = sha3(mem[_259 + 32 len mem[_259]])
                if sha3(mem[_259 + 32 len mem[_259]]) % 20:
                    if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                        revert with 0, 50
                    mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                    mem[_258 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                    mem[_258 + 90] = msg.sender
                    mem[_258 + 122] = 0
                    require ext_code.size(sub_809deb63Address)
                    call sub_809deb63Address.mint(address arg1, bool arg2) with:
                         gas gas_remaining wei
                        args msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if msg.sender == msg.sender:
                    else:
                        emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                else:
                    mem[_258 + 90] = sha3(mem[_259 + 32 len mem[_259]])
                    staticcall sub_93066351Address.0x9e496641 with:
                            gas gas_remaining wei
                           args _261
                    mem[_258 + 86] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _258 + ceil32(return_data.size) + 86
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                        revert with 0, 50
                    mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                    mem[_258 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                    if ext_call.return_data[12 len 20]:
                        mem[_258 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                        mem[_258 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args address(ext_call.return_data[0]), 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == address(ext_call.return_data[0]):
                        else:
                            emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                        if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                            revert with 0, 17
                        if block.timestamp < sub_e625866a:
                            revert with 0, 17
                        if not sub_01f47d88:
                            revert with 0, 18
                        if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                            revert with 0, 17
                        if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                            revert with 0, 17
                        if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            if 0 >= sub_696d77d3:
                                if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                            else:
                                if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                revert with 0, 17
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _261
                        s = ext_call.return_data[0]
                        s = uint16(s) + 1
                        continue 
                    mem[_258 + ceil32(return_data.size) + 90] = msg.sender
                    mem[_258 + ceil32(return_data.size) + 122] = 0
                    require ext_code.size(sub_809deb63Address)
                    call sub_809deb63Address.mint(address arg1, bool arg2) with:
                         gas gas_remaining wei
                        args msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if msg.sender == msg.sender:
                    else:
                        emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                    revert with 0, 17
                if block.timestamp < sub_e625866a:
                    revert with 0, 17
                if not sub_01f47d88:
                    revert with 0, 18
                if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                    revert with 0, 17
                if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                    revert with 0, 17
                if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                    if 0 >= sub_696d77d3:
                        if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                    else:
                        if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                else:
                    if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        revert with 0, 17
                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _261
                s = msg.sender
                s = uint16(s) + 1
                continue 
            sub_e625866a = block.timestamp
            _246 = mem[64]
            mem[mem[64]] = 32
            _252 = mem[(6 * ceil32(return_data.size)) + 96]
            mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
            idx = 0
            s = (6 * ceil32(return_data.size)) + 128
            t = mem[64] + 64
            while idx < _252:
                mem[t] = mem[s + 30 len 2]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xe70455f3: mem[mem[64] len _246 + (32 * _252) + -mem[64] + 64], msg.sender
        else:
            mem[(6 * ceil32(return_data.size)) + 128 len 32 * arg1] = call.data[calldata.size len 32 * arg1]
            idx = 0
            s = 0
            s = 0
            s = ext_call.return_data[0]
            while idx < arg1:
                if uint16(s) == 65535:
                    revert with 0, 17
                _262 = mem[64]
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = address(msg.sender)
                mem[mem[64] + 84] = uint16(s) + 1 << 240
                _263 = mem[64]
                mem[mem[64]] = 54
                mem[64] = mem[64] + 86
                _265 = sha3(mem[_263 + 32 len mem[_263]])
                if sha3(mem[_263 + 32 len mem[_263]]) % 20:
                    if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                        revert with 0, 50
                    mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                    mem[_262 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                    mem[_262 + 90] = msg.sender
                    mem[_262 + 122] = 0
                    require ext_code.size(sub_809deb63Address)
                    call sub_809deb63Address.mint(address arg1, bool arg2) with:
                         gas gas_remaining wei
                        args msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if msg.sender == msg.sender:
                    else:
                        emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                else:
                    mem[_262 + 90] = sha3(mem[_263 + 32 len mem[_263]])
                    staticcall sub_93066351Address.0x9e496641 with:
                            gas gas_remaining wei
                           args _265
                    mem[_262 + 86] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _262 + ceil32(return_data.size) + 86
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                        revert with 0, 50
                    mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                    mem[_262 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                    if ext_call.return_data[12 len 20]:
                        mem[_262 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                        mem[_262 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args address(ext_call.return_data[0]), 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == address(ext_call.return_data[0]):
                        else:
                            emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                        if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                            revert with 0, 17
                        if block.timestamp < sub_e625866a:
                            revert with 0, 17
                        if not sub_01f47d88:
                            revert with 0, 18
                        if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                            revert with 0, 17
                        if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                            revert with 0, 17
                        if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            if 0 >= sub_696d77d3:
                                if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                            else:
                                if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                revert with 0, 17
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                    revert with 0, 17
                                sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _265
                        s = ext_call.return_data[0]
                        s = uint16(s) + 1
                        continue 
                    mem[_262 + ceil32(return_data.size) + 90] = msg.sender
                    mem[_262 + ceil32(return_data.size) + 122] = 0
                    require ext_code.size(sub_809deb63Address)
                    call sub_809deb63Address.mint(address arg1, bool arg2) with:
                         gas gas_remaining wei
                        args msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if msg.sender == msg.sender:
                    else:
                        emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                    revert with 0, 17
                if block.timestamp < sub_e625866a:
                    revert with 0, 17
                if not sub_01f47d88:
                    revert with 0, 18
                if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                    revert with 0, 17
                if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                    revert with 0, 17
                if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                    if 0 >= sub_696d77d3:
                        if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                    else:
                        if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                else:
                    if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        revert with 0, 17
                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                            revert with 0, 17
                        sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _265
                s = msg.sender
                s = uint16(s) + 1
                continue 
            sub_e625866a = block.timestamp
            _247 = mem[64]
            mem[mem[64]] = 32
            _253 = mem[(6 * ceil32(return_data.size)) + 96]
            mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
            idx = 0
            s = (6 * ceil32(return_data.size)) + 128
            t = mem[64] + 64
            while idx < _253:
                mem[t] = mem[s + 30 len 2]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            emit 0xe70455f3: mem[mem[64] len _247 + (32 * _253) + -mem[64] + 64], msg.sender
    else:
        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
            revert with 0, 17
        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) and arg1 > -1 / sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88):
                revert with 0, 17
            if (sub_0e5a7486 * arg1) - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88 * arg1) <= 0:
                revert with 0, 'GEN1 mint cost cannot be 0'
            mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(6 * ceil32(return_data.size)) + 132] = (sub_0e5a7486 * arg1) - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88 * arg1)
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, (sub_0e5a7486 * arg1) - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88 * arg1)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if arg1 > test266151307():
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 96] = arg1
            mem[64] = (6 * ceil32(return_data.size)) + (32 * arg1) + 128
            if not arg1:
                idx = 0
                s = 0
                s = 0
                s = ext_call.return_data[0]
                while idx < arg1:
                    if uint16(s) == 65535:
                        revert with 0, 17
                    _266 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = uint16(s) + 1 << 240
                    _267 = mem[64]
                    mem[mem[64]] = 54
                    mem[64] = mem[64] + 86
                    _269 = sha3(mem[_267 + 32 len mem[_267]])
                    if sha3(mem[_267 + 32 len mem[_267]]) % 20:
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_266 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        mem[_266 + 90] = msg.sender
                        mem[_266 + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    else:
                        mem[_266 + 90] = sha3(mem[_267 + 32 len mem[_267]])
                        staticcall sub_93066351Address.0x9e496641 with:
                                gas gas_remaining wei
                               args _269
                        mem[_266 + 86] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _266 + ceil32(return_data.size) + 86
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_266 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        if ext_call.return_data[12 len 20]:
                            mem[_266 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                            mem[_266 + ceil32(return_data.size) + 122] = 0
                            require ext_code.size(sub_809deb63Address)
                            call sub_809deb63Address.mint(address arg1, bool arg2) with:
                                 gas gas_remaining wei
                                args address(ext_call.return_data[0]), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.sender == address(ext_call.return_data[0]):
                            else:
                                emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                            if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if block.timestamp < sub_e625866a:
                                revert with 0, 17
                            if not sub_01f47d88:
                                revert with 0, 18
                            if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                                revert with 0, 17
                            if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                if 0 >= sub_696d77d3:
                                    if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                    revert with 0, 17
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _269
                            s = ext_call.return_data[0]
                            s = uint16(s) + 1
                            continue 
                        mem[_266 + ceil32(return_data.size) + 90] = msg.sender
                        mem[_266 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if block.timestamp < sub_e625866a:
                        revert with 0, 17
                    if not sub_01f47d88:
                        revert with 0, 18
                    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                        revert with 0, 17
                    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        if 0 >= sub_696d77d3:
                            if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            revert with 0, 17
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _269
                    s = msg.sender
                    s = uint16(s) + 1
                    continue 
                sub_e625866a = block.timestamp
                _248 = mem[64]
                mem[mem[64]] = 32
                _254 = mem[(6 * ceil32(return_data.size)) + 96]
                mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
                idx = 0
                s = (6 * ceil32(return_data.size)) + 128
                t = mem[64] + 64
                while idx < _254:
                    mem[t] = mem[s + 30 len 2]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xe70455f3: mem[mem[64] len _248 + (32 * _254) + -mem[64] + 64], msg.sender
            else:
                mem[(6 * ceil32(return_data.size)) + 128 len 32 * arg1] = call.data[calldata.size len 32 * arg1]
                idx = 0
                s = 0
                s = 0
                s = ext_call.return_data[0]
                while idx < arg1:
                    if uint16(s) == 65535:
                        revert with 0, 17
                    _270 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = uint16(s) + 1 << 240
                    _271 = mem[64]
                    mem[mem[64]] = 54
                    mem[64] = mem[64] + 86
                    _273 = sha3(mem[_271 + 32 len mem[_271]])
                    if sha3(mem[_271 + 32 len mem[_271]]) % 20:
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_270 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        mem[_270 + 90] = msg.sender
                        mem[_270 + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    else:
                        mem[_270 + 90] = sha3(mem[_271 + 32 len mem[_271]])
                        staticcall sub_93066351Address.0x9e496641 with:
                                gas gas_remaining wei
                               args _273
                        mem[_270 + 86] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _270 + ceil32(return_data.size) + 86
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_270 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        if ext_call.return_data[12 len 20]:
                            mem[_270 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                            mem[_270 + ceil32(return_data.size) + 122] = 0
                            require ext_code.size(sub_809deb63Address)
                            call sub_809deb63Address.mint(address arg1, bool arg2) with:
                                 gas gas_remaining wei
                                args address(ext_call.return_data[0]), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.sender == address(ext_call.return_data[0]):
                            else:
                                emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                            if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if block.timestamp < sub_e625866a:
                                revert with 0, 17
                            if not sub_01f47d88:
                                revert with 0, 18
                            if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                                revert with 0, 17
                            if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                if 0 >= sub_696d77d3:
                                    if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                    revert with 0, 17
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _273
                            s = ext_call.return_data[0]
                            s = uint16(s) + 1
                            continue 
                        mem[_270 + ceil32(return_data.size) + 90] = msg.sender
                        mem[_270 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if block.timestamp < sub_e625866a:
                        revert with 0, 17
                    if not sub_01f47d88:
                        revert with 0, 18
                    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                        revert with 0, 17
                    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        if 0 >= sub_696d77d3:
                            if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            revert with 0, 17
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _273
                    s = msg.sender
                    s = uint16(s) + 1
                    continue 
                sub_e625866a = block.timestamp
                _249 = mem[64]
                mem[mem[64]] = 32
                _255 = mem[(6 * ceil32(return_data.size)) + 96]
                mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
                idx = 0
                s = (6 * ceil32(return_data.size)) + 128
                t = mem[64] + 64
                while idx < _255:
                    mem[t] = mem[s + 30 len 2]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xe70455f3: mem[mem[64] len _249 + (32 * _255) + -mem[64] + 64], msg.sender
        else:
            if sub_696d77d3 and arg1 > -1 / sub_696d77d3:
                revert with 0, 17
            if sub_696d77d3 * arg1 <= 0:
                revert with 0, 'GEN1 mint cost cannot be 0'
            mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(6 * ceil32(return_data.size)) + 132] = sub_696d77d3 * arg1
            require ext_code.size(sub_52b8bedfAddress)
            call sub_52b8bedfAddress.burn(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, sub_696d77d3 * arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if arg1 > test266151307():
                revert with 0, 65
            mem[(6 * ceil32(return_data.size)) + 96] = arg1
            mem[64] = (6 * ceil32(return_data.size)) + (32 * arg1) + 128
            if not arg1:
                idx = 0
                s = 0
                s = 0
                s = ext_call.return_data[0]
                while idx < arg1:
                    if uint16(s) == 65535:
                        revert with 0, 17
                    _274 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = uint16(s) + 1 << 240
                    _275 = mem[64]
                    mem[mem[64]] = 54
                    mem[64] = mem[64] + 86
                    _277 = sha3(mem[_275 + 32 len mem[_275]])
                    if sha3(mem[_275 + 32 len mem[_275]]) % 20:
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_274 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        mem[_274 + 90] = msg.sender
                        mem[_274 + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    else:
                        mem[_274 + 90] = sha3(mem[_275 + 32 len mem[_275]])
                        staticcall sub_93066351Address.0x9e496641 with:
                                gas gas_remaining wei
                               args _277
                        mem[_274 + 86] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _274 + ceil32(return_data.size) + 86
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_274 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        if ext_call.return_data[12 len 20]:
                            mem[_274 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                            mem[_274 + ceil32(return_data.size) + 122] = 0
                            require ext_code.size(sub_809deb63Address)
                            call sub_809deb63Address.mint(address arg1, bool arg2) with:
                                 gas gas_remaining wei
                                args address(ext_call.return_data[0]), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.sender == address(ext_call.return_data[0]):
                            else:
                                emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                            if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if block.timestamp < sub_e625866a:
                                revert with 0, 17
                            if not sub_01f47d88:
                                revert with 0, 18
                            if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                                revert with 0, 17
                            if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                if 0 >= sub_696d77d3:
                                    if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                    revert with 0, 17
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _277
                            s = ext_call.return_data[0]
                            s = uint16(s) + 1
                            continue 
                        mem[_274 + ceil32(return_data.size) + 90] = msg.sender
                        mem[_274 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if block.timestamp < sub_e625866a:
                        revert with 0, 17
                    if not sub_01f47d88:
                        revert with 0, 18
                    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                        revert with 0, 17
                    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        if 0 >= sub_696d77d3:
                            if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            revert with 0, 17
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _277
                    s = msg.sender
                    s = uint16(s) + 1
                    continue 
                sub_e625866a = block.timestamp
                _250 = mem[64]
                mem[mem[64]] = 32
                _256 = mem[(6 * ceil32(return_data.size)) + 96]
                mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
                idx = 0
                s = (6 * ceil32(return_data.size)) + 128
                t = mem[64] + 64
                while idx < _256:
                    mem[t] = mem[s + 30 len 2]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xe70455f3: mem[mem[64] len _250 + (32 * _256) + -mem[64] + 64], msg.sender
            else:
                mem[(6 * ceil32(return_data.size)) + 128 len 32 * arg1] = call.data[calldata.size len 32 * arg1]
                idx = 0
                s = 0
                s = 0
                s = ext_call.return_data[0]
                while idx < arg1:
                    if uint16(s) == 65535:
                        revert with 0, 17
                    _278 = mem[64]
                    mem[mem[64] + 32] = block.timestamp
                    mem[mem[64] + 64] = address(msg.sender)
                    mem[mem[64] + 84] = uint16(s) + 1 << 240
                    _279 = mem[64]
                    mem[mem[64]] = 54
                    mem[64] = mem[64] + 86
                    _281 = sha3(mem[_279 + 32 len mem[_279]])
                    if sha3(mem[_279 + 32 len mem[_279]]) % 20:
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_278 + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        mem[_278 + 90] = msg.sender
                        mem[_278 + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    else:
                        mem[_278 + 90] = sha3(mem[_279 + 32 len mem[_279]])
                        staticcall sub_93066351Address.0x9e496641 with:
                                gas gas_remaining wei
                               args _281
                        mem[_278 + 86] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _278 + ceil32(return_data.size) + 86
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if idx >= mem[(6 * ceil32(return_data.size)) + 96]:
                            revert with 0, 50
                        mem[(32 * idx) + (6 * ceil32(return_data.size)) + 128] = uint16(uint16(s) + 1)
                        mem[_278 + ceil32(return_data.size) + 86] = 0x2097d3fb00000000000000000000000000000000000000000000000000000000
                        if ext_call.return_data[12 len 20]:
                            mem[_278 + ceil32(return_data.size) + 90] = address(ext_call.return_data[0])
                            mem[_278 + ceil32(return_data.size) + 122] = 0
                            require ext_code.size(sub_809deb63Address)
                            call sub_809deb63Address.mint(address arg1, bool arg2) with:
                                 gas gas_remaining wei
                                args address(ext_call.return_data[0]), 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.sender == address(ext_call.return_data[0]):
                            else:
                                emit 0x9655a7b5: msg.sender, address(ext_call.return_data[0]), uint16(uint16(s) + 1)
                            if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if block.timestamp < sub_e625866a:
                                revert with 0, 17
                            if not sub_01f47d88:
                                revert with 0, 18
                            if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                                revert with 0, 17
                            if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                                revert with 0, 17
                            if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                if 0 >= sub_696d77d3:
                                    if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            else:
                                if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                                    revert with 0, 17
                                if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                                    if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                                else:
                                    if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                        revert with 0, 17
                                    sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _281
                            s = ext_call.return_data[0]
                            s = uint16(s) + 1
                            continue 
                        mem[_278 + ceil32(return_data.size) + 90] = msg.sender
                        mem[_278 + ceil32(return_data.size) + 122] = 0
                        require ext_code.size(sub_809deb63Address)
                        call sub_809deb63Address.mint(address arg1, bool arg2) with:
                             gas gas_remaining wei
                            args msg.sender, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.sender == msg.sender:
                        else:
                            emit 0x9655a7b5: msg.sender, msg.sender, uint16(uint16(s) + 1)
                    if sub_0e5a7486 and sub_ce9efb02 > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if block.timestamp < sub_e625866a:
                        revert with 0, 17
                    if not sub_01f47d88:
                        revert with 0, 18
                    if sub_0e5a7486 and sub_7f75077a > -1 / sub_0e5a7486:
                        revert with 0, 17
                    if sub_0e5a7486 * sub_7f75077a / 100 and block.timestamp - sub_e625866a / sub_01f47d88 > -1 / sub_0e5a7486 * sub_7f75077a / 100:
                        revert with 0, 17
                    if sub_0e5a7486 <= sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                        if 0 >= sub_696d77d3:
                            if 0 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 * sub_ce9efb02 / 100
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    else:
                        if sub_0e5a7486 < sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88:
                            revert with 0, 17
                        if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) >= sub_696d77d3:
                            if sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_0e5a7486 - (sub_0e5a7486 * sub_7f75077a / 100 * block.timestamp - sub_e625866a / sub_01f47d88) + (sub_0e5a7486 * sub_ce9efb02 / 100)
                        else:
                            if sub_696d77d3 > !(sub_0e5a7486 * sub_ce9efb02 / 100):
                                revert with 0, 17
                            sub_0e5a7486 = sub_696d77d3 + (sub_0e5a7486 * sub_ce9efb02 / 100)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _281
                    s = msg.sender
                    s = uint16(s) + 1
                    continue 
                sub_e625866a = block.timestamp
                _251 = mem[64]
                mem[mem[64]] = 32
                _257 = mem[(6 * ceil32(return_data.size)) + 96]
                mem[mem[64] + 32] = mem[(6 * ceil32(return_data.size)) + 96]
                idx = 0
                s = (6 * ceil32(return_data.size)) + 128
                t = mem[64] + 64
                while idx < _257:
                    mem[t] = mem[s + 30 len 2]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                emit 0xe70455f3: mem[mem[64] len _251 + (32 * _257) + -mem[64] + 64], msg.sender
    stor1 = 1
}

function sub_4a41eb4f(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 128
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] == uint16(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require cd[36] == uint16(cd[36])
    if stor2:
        revert with 0, 'Pausable: paused'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if tx.origin != msg.sender:
        revert with 0, 'Only EOA'
    if 0 >= ('cd', 4).length:
        mem[ceil32(32 * ('cd', 4).length) + 97] = 0x35ca838b00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + 101] = 32
        mem[ceil32(32 * ('cd', 4).length) + 133] = ('cd', 4).length
        idx = 0
        s = 128
        t = ceil32(32 * ('cd', 4).length) + 165
        while idx < ('cd', 4).length:
            mem[t] = mem[s + 30 len 2]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(sub_809deb63Address)
        call sub_809deb63Address.updateOriginAccess(uint16[] arg1) with:
             gas gas_remaining wei
            args Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + 165 len 32 * ('cd', 4).length])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + 97] = 32
        mem[ceil32(32 * ('cd', 4).length) + 129] = ('cd', 4).length
        idx = 0
        s = 128
        t = mem[64] + 64
        while idx < ('cd', 4).length:
            mem[t] = mem[s + 30 len 2]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        emit 0xe532f731: mem[mem[64] len ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + -mem[64] + 161], msg.sender
        stor1 = 1
    if 0 >= ('cd', 4).length:
        revert with 0, 50
    _315 = mem[128]
    mem[ceil32(32 * ('cd', 4).length) + 101] = mem[158 len 2]
    staticcall sub_809deb63Address.0x36a54b90 with:
            gas gas_remaining wei
           args uint16(_315)
    mem[ceil32(32 * ('cd', 4).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'Only Heros can be leveled up'
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 101] = uint16(_315)
    staticcall sub_93066351Address.isStaked(uint256 arg1) with:
            gas gas_remaining wei
           args uint16(_315)
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 101] = uint16(_315)
        staticcall sub_809deb63Address.0x6352211e with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, 'You don't own this token'
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 97] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 129] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 161] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 193] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 289] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 321] = 0
        staticcall sub_809deb63Address.getTokenTraits(uint256 arg1) with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 353 len 256] = ext_call.return_data[0 len 256]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 256
        if not bool(ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
        require ext_call.return_data[32] == bool(ext_call.return_data[32])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 385] = ext_call.return_data[32]
        require ext_call.return_data[64] == bool(ext_call.return_data[64])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 417] = ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[126 len 2]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 449] = ext_call.return_data[96]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] = ext_call.return_data[128]
        require ext_call.return_data[160] == ext_call.return_data[191 len 1]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 513] = ext_call.return_data[160]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 545] = ext_call.return_data[192]
        require ext_call.return_data[224] == ext_call.return_data[248 len 8]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 577] = ext_call.return_data[224]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 613] = uint16(_315)
        staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 613] = uint16(_315)
            staticcall sub_809deb63Address.0x6352211e with:
                    gas gas_remaining wei
                   args uint16(_315)
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 609] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'The owner cannot be address(0)'
            if 0 == ext_call.return_data[126 len 2]:
                if tx.origin != msg.sender:
                    revert with 0, 'Only EOA'
                if uint16(cd[36]) < 1:
                    revert with 0, 'Invalid levelsToUpgrade.'
                idx = 1
                while uint16(idx) <= uint16(cd[36]):
                    if ext_call.return_data[126 len 2] > -uint16(idx) + 65535:
                        revert with 0, 17
                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]):
                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 1:
                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 2:
                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 3:
                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 4:
                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 5:
                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 6:
                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 7:
                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 8:
                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 9:
                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 10:
                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 11:
                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 12:
                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 13:
                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 14:
                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 15:
                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 16:
                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 17:
                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 18:
                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 19:
                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 20:
                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 21:
                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 22:
                                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 23:
                                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 24:
                                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 25:
                                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) <= 25:
                                                                                                                                revert with 0, 'This level is not supported yet'
                    if uint16(idx) == 65535:
                        revert with 0, 17
                    idx = uint16(idx) + 1
                    continue 
            else:
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 613] = ext_call.return_data[12 len 20]
                staticcall sub_c38eb669Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 609] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (10 * ceil32(return_data.size)) + 609
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[0])
                    mem[mem[64] + 36] = idx
                    staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[0]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _628 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_628]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _647 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _656 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_656] = mem[_647]
                    mem[_656 + 32] = mem[_647 + 32]
                    mem[_656 + 64] = mem[_647 + 64]
                    if 24 * 3600 > !mem[_656 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_656 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s and sub_23422e8d > -1 / s:
                    revert with 0, 17
                if s * sub_23422e8d > !sub_fc7c54de:
                    revert with 0, 17
                if block.timestamp < mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481]:
                    revert with 0, 17
                if not (s * sub_23422e8d) + sub_fc7c54de:
                    revert with 0, 18
                if uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de) > mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]:
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if 0 > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(idx):
                            if uint16(idx) != 1:
                                if uint16(idx) != 2:
                                    if uint16(idx) != 3:
                                        if uint16(idx) != 4:
                                            if uint16(idx) != 5:
                                                if uint16(idx) != 6:
                                                    if uint16(idx) != 7:
                                                        if uint16(idx) != 8:
                                                            if uint16(idx) != 9:
                                                                if uint16(idx) != 10:
                                                                    if uint16(idx) != 11:
                                                                        if uint16(idx) != 12:
                                                                            if uint16(idx) != 13:
                                                                                if uint16(idx) != 14:
                                                                                    if uint16(idx) != 15:
                                                                                        if uint16(idx) != 16:
                                                                                            if uint16(idx) != 17:
                                                                                                if uint16(idx) != 18:
                                                                                                    if uint16(idx) != 19:
                                                                                                        if uint16(idx) != 20:
                                                                                                            if uint16(idx) != 21:
                                                                                                                if uint16(idx) != 22:
                                                                                                                    if uint16(idx) != 23:
                                                                                                                        if uint16(idx) != 24:
                                                                                                                            if uint16(idx) != 25:
                                                                                                                                if uint16(idx) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
                else:
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] < uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de):
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 449] = uint16(mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] - uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de))
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]):
                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 1:
                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 2:
                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 3:
                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 4:
                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 5:
                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 6:
                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 7:
                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 8:
                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 9:
                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 10:
                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 11:
                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 12:
                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 13:
                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 14:
                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 15:
                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 16:
                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 17:
                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 18:
                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 19:
                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 20:
                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 21:
                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 22:
                                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 23:
                                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 24:
                                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 25:
                                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
        else:
            staticcall sub_93066351Address.getStake(uint256 arg1) with:
                    gas gas_remaining wei
                   args uint16(_315)
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 609 len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 128
            if not bool(ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 737 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == ext_call.return_data[30 len 2]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 609] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 641] = ext_call.return_data[32]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 673] = ext_call.return_data[64]
            require ext_call.return_data[96] == ext_call.return_data[108 len 20]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 705] = ext_call.return_data[96]
            if not ext_call.return_data[108 len 20]:
                revert with 0, 'The owner cannot be address(0)'
            if 0 == ext_call.return_data[126 len 2]:
                if tx.origin != msg.sender:
                    revert with 0, 'Only EOA'
                if uint16(cd[36]) < 1:
                    revert with 0, 'Invalid levelsToUpgrade.'
                idx = 1
                while uint16(idx) <= uint16(cd[36]):
                    if ext_call.return_data[126 len 2] > -uint16(idx) + 65535:
                        revert with 0, 17
                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]):
                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 1:
                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 2:
                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 3:
                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 4:
                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 5:
                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 6:
                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 7:
                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 8:
                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 9:
                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 10:
                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 11:
                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 12:
                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 13:
                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 14:
                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 15:
                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 16:
                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 17:
                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 18:
                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 19:
                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 20:
                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 21:
                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 22:
                                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 23:
                                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 24:
                                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 25:
                                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) <= 25:
                                                                                                                                revert with 0, 'This level is not supported yet'
                    if uint16(idx) == 65535:
                        revert with 0, 17
                    idx = uint16(idx) + 1
                    continue 
            else:
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 741] = ext_call.return_data[108 len 20]
                staticcall sub_c38eb669Address.0x70a08231 with:
                        gas gas_remaining wei
                       args ext_call.return_data[108 len 20]
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 737] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (10 * ceil32(return_data.size)) + 737
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[96])
                    mem[mem[64] + 36] = idx
                    staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[96]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _629 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_629]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _649 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _657 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_657] = mem[_649]
                    mem[_657 + 32] = mem[_649 + 32]
                    mem[_657 + 64] = mem[_649 + 64]
                    if 24 * 3600 > !mem[_657 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_657 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s and sub_23422e8d > -1 / s:
                    revert with 0, 17
                if s * sub_23422e8d > !sub_fc7c54de:
                    revert with 0, 17
                if block.timestamp < mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481]:
                    revert with 0, 17
                if not (s * sub_23422e8d) + sub_fc7c54de:
                    revert with 0, 18
                if uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de) > mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]:
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if 0 > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(idx):
                            if uint16(idx) != 1:
                                if uint16(idx) != 2:
                                    if uint16(idx) != 3:
                                        if uint16(idx) != 4:
                                            if uint16(idx) != 5:
                                                if uint16(idx) != 6:
                                                    if uint16(idx) != 7:
                                                        if uint16(idx) != 8:
                                                            if uint16(idx) != 9:
                                                                if uint16(idx) != 10:
                                                                    if uint16(idx) != 11:
                                                                        if uint16(idx) != 12:
                                                                            if uint16(idx) != 13:
                                                                                if uint16(idx) != 14:
                                                                                    if uint16(idx) != 15:
                                                                                        if uint16(idx) != 16:
                                                                                            if uint16(idx) != 17:
                                                                                                if uint16(idx) != 18:
                                                                                                    if uint16(idx) != 19:
                                                                                                        if uint16(idx) != 20:
                                                                                                            if uint16(idx) != 21:
                                                                                                                if uint16(idx) != 22:
                                                                                                                    if uint16(idx) != 23:
                                                                                                                        if uint16(idx) != 24:
                                                                                                                            if uint16(idx) != 25:
                                                                                                                                if uint16(idx) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
                else:
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] < uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de):
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 449] = uint16(mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] - uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] / (s * sub_23422e8d) + sub_fc7c54de))
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2] > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]):
                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 1:
                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 2:
                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 3:
                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 4:
                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 5:
                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 6:
                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 7:
                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 8:
                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 9:
                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 10:
                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 11:
                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 12:
                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 13:
                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 14:
                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 15:
                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 16:
                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 17:
                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 18:
                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 19:
                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 20:
                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 21:
                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 22:
                                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 23:
                                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 24:
                                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) != 25:
                                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 479 len 2]) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
    else:
        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 97 len 128] = ext_call.return_data[0 len 128]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 128
        if not bool(ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == ext_call.return_data[30 len 2]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 97] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 129] = ext_call.return_data[32]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 161] = ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[108 len 20]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 193] = ext_call.return_data[96]
        if not ext_call.return_data[108 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if ext_call.return_data[108 len 20] != msg.sender:
            revert with 0, 'You don't own this token'
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 289] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 321] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 353] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 385] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 417] = 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 449] = 0
        staticcall sub_809deb63Address.getTokenTraits(uint256 arg1) with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 481 len 256] = ext_call.return_data[0 len 256]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 256
        if not bool(ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 737 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 481] = ext_call.return_data[0]
        require ext_call.return_data[32] == bool(ext_call.return_data[32])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 513] = ext_call.return_data[32]
        require ext_call.return_data[64] == bool(ext_call.return_data[64])
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 545] = ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[126 len 2]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 577] = ext_call.return_data[96]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] = ext_call.return_data[128]
        require ext_call.return_data[160] == ext_call.return_data[191 len 1]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 641] = ext_call.return_data[160]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 673] = ext_call.return_data[192]
        require ext_call.return_data[224] == ext_call.return_data[248 len 8]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 705] = ext_call.return_data[224]
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 741] = uint16(_315)
        staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                gas gas_remaining wei
               args uint16(_315)
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 737] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 741] = uint16(_315)
            staticcall sub_809deb63Address.0x6352211e with:
                    gas gas_remaining wei
                   args uint16(_315)
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 737] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if not ext_call.return_data[12 len 20]:
                revert with 0, 'The owner cannot be address(0)'
            if 0 == ext_call.return_data[126 len 2]:
                if tx.origin != msg.sender:
                    revert with 0, 'Only EOA'
                if uint16(cd[36]) < 1:
                    revert with 0, 'Invalid levelsToUpgrade.'
                idx = 1
                while uint16(idx) <= uint16(cd[36]):
                    if ext_call.return_data[126 len 2] > -uint16(idx) + 65535:
                        revert with 0, 17
                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]):
                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 1:
                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 2:
                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 3:
                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 4:
                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 5:
                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 6:
                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 7:
                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 8:
                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 9:
                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 10:
                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 11:
                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 12:
                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 13:
                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 14:
                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 15:
                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 16:
                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 17:
                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 18:
                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 19:
                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 20:
                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 21:
                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 22:
                                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 23:
                                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 24:
                                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 25:
                                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) <= 25:
                                                                                                                                revert with 0, 'This level is not supported yet'
                    if uint16(idx) == 65535:
                        revert with 0, 17
                    idx = uint16(idx) + 1
                    continue 
            else:
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 741] = ext_call.return_data[12 len 20]
                staticcall sub_c38eb669Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[0])
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 737] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (10 * ceil32(return_data.size)) + 737
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[0])
                    mem[mem[64] + 36] = idx
                    staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[0]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _630 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_630]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _651 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _658 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_658] = mem[_651]
                    mem[_658 + 32] = mem[_651 + 32]
                    mem[_658 + 64] = mem[_651 + 64]
                    if 24 * 3600 > !mem[_658 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_658 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s and sub_23422e8d > -1 / s:
                    revert with 0, 17
                if s * sub_23422e8d > !sub_fc7c54de:
                    revert with 0, 17
                if block.timestamp < mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609]:
                    revert with 0, 17
                if not (s * sub_23422e8d) + sub_fc7c54de:
                    revert with 0, 18
                if uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de) > mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]:
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if 0 > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(idx):
                            if uint16(idx) != 1:
                                if uint16(idx) != 2:
                                    if uint16(idx) != 3:
                                        if uint16(idx) != 4:
                                            if uint16(idx) != 5:
                                                if uint16(idx) != 6:
                                                    if uint16(idx) != 7:
                                                        if uint16(idx) != 8:
                                                            if uint16(idx) != 9:
                                                                if uint16(idx) != 10:
                                                                    if uint16(idx) != 11:
                                                                        if uint16(idx) != 12:
                                                                            if uint16(idx) != 13:
                                                                                if uint16(idx) != 14:
                                                                                    if uint16(idx) != 15:
                                                                                        if uint16(idx) != 16:
                                                                                            if uint16(idx) != 17:
                                                                                                if uint16(idx) != 18:
                                                                                                    if uint16(idx) != 19:
                                                                                                        if uint16(idx) != 20:
                                                                                                            if uint16(idx) != 21:
                                                                                                                if uint16(idx) != 22:
                                                                                                                    if uint16(idx) != 23:
                                                                                                                        if uint16(idx) != 24:
                                                                                                                            if uint16(idx) != 25:
                                                                                                                                if uint16(idx) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
                else:
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] < uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de):
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 577] = uint16(mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] - uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de))
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]):
                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 1:
                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 2:
                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 3:
                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 4:
                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 5:
                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 6:
                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 7:
                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 8:
                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 9:
                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 10:
                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 11:
                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 12:
                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 13:
                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 14:
                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 15:
                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 16:
                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 17:
                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 18:
                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 19:
                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 20:
                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 21:
                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 22:
                                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 23:
                                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 24:
                                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 25:
                                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
        else:
            staticcall sub_93066351Address.getStake(uint256 arg1) with:
                    gas gas_remaining wei
                   args uint16(_315)
            mem[ceil32(32 * ('cd', 4).length) + (7 * ceil32(return_data.size)) + 737 len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 128
            if not bool(ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 865 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == ext_call.return_data[30 len 2]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 737] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 769] = ext_call.return_data[32]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 801] = ext_call.return_data[64]
            require ext_call.return_data[96] == ext_call.return_data[108 len 20]
            mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 833] = ext_call.return_data[96]
            if not ext_call.return_data[108 len 20]:
                revert with 0, 'The owner cannot be address(0)'
            if 0 == ext_call.return_data[126 len 2]:
                if tx.origin != msg.sender:
                    revert with 0, 'Only EOA'
                if uint16(cd[36]) < 1:
                    revert with 0, 'Invalid levelsToUpgrade.'
                idx = 1
                while uint16(idx) <= uint16(cd[36]):
                    if ext_call.return_data[126 len 2] > -uint16(idx) + 65535:
                        revert with 0, 17
                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]):
                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 1:
                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 2:
                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 3:
                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 4:
                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 5:
                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 6:
                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 7:
                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 8:
                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 9:
                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 10:
                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 11:
                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 12:
                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 13:
                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 14:
                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 15:
                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 16:
                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 17:
                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 18:
                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 19:
                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 20:
                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 21:
                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 22:
                                                                                                                if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 23:
                                                                                                                    if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 24:
                                                                                                                        if uint16(uint16(idx) + ext_call.return_data[126 len 2]) != 25:
                                                                                                                            if uint16(uint16(idx) + ext_call.return_data[126 len 2]) <= 25:
                                                                                                                                revert with 0, 'This level is not supported yet'
                    if uint16(idx) == 65535:
                        revert with 0, 17
                    idx = uint16(idx) + 1
                    continue 
            else:
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 869] = ext_call.return_data[108 len 20]
                staticcall sub_c38eb669Address.0x70a08231 with:
                        gas gas_remaining wei
                       args ext_call.return_data[108 len 20]
                mem[ceil32(32 * ('cd', 4).length) + (8 * ceil32(return_data.size)) + 865] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (10 * ceil32(return_data.size)) + 865
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[96])
                    mem[mem[64] + 36] = idx
                    staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[96]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _631 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_631]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _653 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _659 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_659] = mem[_653]
                    mem[_659 + 32] = mem[_653 + 32]
                    mem[_659 + 64] = mem[_653 + 64]
                    if 24 * 3600 > !mem[_659 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_659 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s and sub_23422e8d > -1 / s:
                    revert with 0, 17
                if s * sub_23422e8d > !sub_fc7c54de:
                    revert with 0, 17
                if block.timestamp < mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609]:
                    revert with 0, 17
                if not (s * sub_23422e8d) + sub_fc7c54de:
                    revert with 0, 18
                if uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de) > mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]:
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if 0 > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(idx):
                            if uint16(idx) != 1:
                                if uint16(idx) != 2:
                                    if uint16(idx) != 3:
                                        if uint16(idx) != 4:
                                            if uint16(idx) != 5:
                                                if uint16(idx) != 6:
                                                    if uint16(idx) != 7:
                                                        if uint16(idx) != 8:
                                                            if uint16(idx) != 9:
                                                                if uint16(idx) != 10:
                                                                    if uint16(idx) != 11:
                                                                        if uint16(idx) != 12:
                                                                            if uint16(idx) != 13:
                                                                                if uint16(idx) != 14:
                                                                                    if uint16(idx) != 15:
                                                                                        if uint16(idx) != 16:
                                                                                            if uint16(idx) != 17:
                                                                                                if uint16(idx) != 18:
                                                                                                    if uint16(idx) != 19:
                                                                                                        if uint16(idx) != 20:
                                                                                                            if uint16(idx) != 21:
                                                                                                                if uint16(idx) != 22:
                                                                                                                    if uint16(idx) != 23:
                                                                                                                        if uint16(idx) != 24:
                                                                                                                            if uint16(idx) != 25:
                                                                                                                                if uint16(idx) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
                else:
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] < uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de):
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 577] = uint16(mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] - uint16(block.timestamp - mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 609] / (s * sub_23422e8d) + sub_fc7c54de))
                    if tx.origin != msg.sender:
                        revert with 0, 'Only EOA'
                    if uint16(cd[36]) < 1:
                        revert with 0, 'Invalid levelsToUpgrade.'
                    idx = 1
                    while uint16(idx) <= uint16(cd[36]):
                        if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2] > -uint16(idx) + 65535:
                            revert with 0, 17
                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]):
                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 1:
                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 2:
                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 3:
                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 4:
                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 5:
                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 6:
                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 7:
                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 8:
                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 9:
                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 10:
                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 11:
                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 12:
                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 13:
                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 14:
                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 15:
                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 16:
                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 17:
                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 18:
                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 19:
                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 20:
                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 21:
                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 22:
                                                                                                                    if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 23:
                                                                                                                        if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 24:
                                                                                                                            if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) != 25:
                                                                                                                                if uint16(uint16(idx) + mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 607 len 2]) <= 25:
                                                                                                                                    revert with 0, 'This level is not supported yet'
                        if uint16(idx) == 65535:
                            revert with 0, 17
                        idx = uint16(idx) + 1
                        continue 
    revert with 0, 'Error calculating cost.'
}

function sub_0ee2bb31(?) {
    require calldata.size - 4 >= 32
    mem[100] = arg1
    staticcall sub_809deb63Address.getTokenWriteBlock(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[24 len 8]
    if ext_call.return_data[24 len 8] >= block.number:
        revert with 0, 'Nope!'
    mem[ceil32(return_data.size) + 100] = arg1
    staticcall sub_809deb63Address.0x32385e25 with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[24 len 8]
    if ext_call.return_data[24 len 8] >= block.number:
        revert with 0, 'Nope!'
    mem[(2 * ceil32(return_data.size)) + 100] = arg1
    staticcall sub_93066351Address.isStaked(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'Token is not staked'
    mem[(4 * ceil32(return_data.size)) + 96] = 0
    mem[(4 * ceil32(return_data.size)) + 128] = 0
    mem[(4 * ceil32(return_data.size)) + 160] = 0
    mem[(4 * ceil32(return_data.size)) + 192] = 0
    mem[(4 * ceil32(return_data.size)) + 224] = 0
    mem[(4 * ceil32(return_data.size)) + 256] = 0
    mem[(4 * ceil32(return_data.size)) + 288] = 0
    mem[(4 * ceil32(return_data.size)) + 320] = 0
    mem[(4 * ceil32(return_data.size)) + 352] = 0
    mem[(4 * ceil32(return_data.size)) + 384] = 0
    mem[(4 * ceil32(return_data.size)) + 416] = 0
    mem[(4 * ceil32(return_data.size)) + 448] = 0
    staticcall sub_809deb63Address.getTokenTraits(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[(4 * ceil32(return_data.size)) + 480 len 256] = ext_call.return_data[0 len 256]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 256
    if not bool((6 * ceil32(return_data.size)) + 736 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(6 * ceil32(return_data.size)) + 480] = ext_call.return_data[0]
    require ext_call.return_data[32] == bool(ext_call.return_data[32])
    mem[(6 * ceil32(return_data.size)) + 512] = ext_call.return_data[32]
    require ext_call.return_data[64] == bool(ext_call.return_data[64])
    mem[(6 * ceil32(return_data.size)) + 544] = ext_call.return_data[64]
    require ext_call.return_data[96] == ext_call.return_data[126 len 2]
    mem[(6 * ceil32(return_data.size)) + 576] = ext_call.return_data[96]
    mem[(6 * ceil32(return_data.size)) + 608] = ext_call.return_data[128]
    require ext_call.return_data[160] == ext_call.return_data[191 len 1]
    mem[(6 * ceil32(return_data.size)) + 640] = ext_call.return_data[160]
    mem[(6 * ceil32(return_data.size)) + 672] = ext_call.return_data[192]
    require ext_call.return_data[224] == ext_call.return_data[248 len 8]
    mem[(6 * ceil32(return_data.size)) + 704] = ext_call.return_data[224]
    mem[(6 * ceil32(return_data.size)) + 740] = arg1
    staticcall sub_93066351Address.isStaked(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    mem[(6 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        mem[(7 * ceil32(return_data.size)) + 740] = arg1
        staticcall sub_809deb63Address.0x6352211e with:
                gas gas_remaining wei
               args arg1
        mem[(7 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if not ext_call.return_data[12 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if 0 == ext_call.return_data[126 len 2]:
            mem[(8 * ceil32(return_data.size)) + 740] = arg1
            staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                    gas gas_remaining wei
                   args arg1
            mem[(8 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                mem[(10 * ceil32(return_data.size)) + 740] = arg1
                staticcall sub_809deb63Address.0x6352211e with:
                        gas gas_remaining wei
                       args arg1
                mem[(10 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if not ext_call.return_data[12 len 20]:
                    revert with 0, 'The owner cannot be address(0)'
                if not ext_call.return_data[32]:
                    staticcall sub_93066351Address.0x219bec0b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    if not bool((13 * ceil32(return_data.size)) + 864 <= test266151307()):
                        revert with 0, 65
                    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                    require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                    if ext_call.return_data[0] < ext_call.return_data[32]:
                        revert with 0, 17
                    if uint8(ext_call.return_data[160]) and ext_call.return_data[0] - ext_call.return_data[32] > -1 / uint8(ext_call.return_data[160]):
                        revert with 0, 17
                    return ((ext_call.return_data[0] * uint8(ext_call.return_data[160])) - (ext_call.return_data[32] * uint8(ext_call.return_data[160])))
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(11 * ceil32(return_data.size)) + 736 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((12 * ceil32(return_data.size)) + 864 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(12 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                mem[(12 * ceil32(return_data.size)) + 768] = ext_call.return_data[32]
                mem[(12 * ceil32(return_data.size)) + 800] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(12 * ceil32(return_data.size)) + 832] = ext_call.return_data[96]
                if block.timestamp < ext_call.return_data[64]:
                    revert with 0, 17
                if block.timestamp - ext_call.return_data[64] and sub_6508597e > -1 / block.timestamp - ext_call.return_data[64]:
                    revert with 0, 17
                if 0 > !((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600):
                    revert with 0, 17
                if ext_call.return_data[126 len 2] and sub_c7cd2b04 > -1 / ext_call.return_data[126 len 2]:
                    revert with 0, 17
                mem[(12 * ceil32(return_data.size)) + 868] = address(ext_call.return_data[0])
                staticcall sub_f9318b45Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (13 * ceil32(return_data.size)) + 864
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[0])
                    mem[mem[64] + 36] = idx
                    staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[0]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _847 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_847]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _876 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _883 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_883] = mem[_876]
                    mem[_883 + 32] = mem[_876 + 32]
                    mem[_883 + 64] = mem[_876 + 64]
                    if 24 * 3600 > !mem[_883 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_883 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s < sub_599a3d39:
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                        revert with 0, 17
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 800]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 800] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 800]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 800]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 800]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 800]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 800]) / 24 * 3600)
                else:
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                        revert with 0, 17
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if s < sub_599a3d39 - 1:
                        revert with 0, 17
                    t = 1
                    u = sub_a45de402
                    v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                    while t <= s + -sub_599a3d39 + 1:
                        if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                            revert with 0, 17
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                            revert with 0, 17
                        if t == -1:
                            revert with 0, 17
                        t = t + 1
                        u = 95 * u / 100
                        v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                        continue 
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !v:
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 800]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 800] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 800]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 800]) - (v * mem[(12 * ceil32(return_data.size)) + 800]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 800]) - (v * mem[(12 * ceil32(return_data.size)) + 800]) / 24 * 3600)
            else:
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(10 * ceil32(return_data.size)) + 736 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((11 * ceil32(return_data.size)) + 864 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(11 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                mem[(11 * ceil32(return_data.size)) + 768] = ext_call.return_data[32]
                mem[(11 * ceil32(return_data.size)) + 800] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(11 * ceil32(return_data.size)) + 832] = ext_call.return_data[96]
                if not ext_call.return_data[108 len 20]:
                    revert with 0, 'The owner cannot be address(0)'
                if not ext_call.return_data[32]:
                    staticcall sub_93066351Address.0x219bec0b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    if not bool((13 * ceil32(return_data.size)) + 992 <= test266151307()):
                        revert with 0, 65
                    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                    require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                    if ext_call.return_data[0] < ext_call.return_data[32]:
                        revert with 0, 17
                    if uint8(ext_call.return_data[160]) and ext_call.return_data[0] - ext_call.return_data[32] > -1 / uint8(ext_call.return_data[160]):
                        revert with 0, 17
                    return ((ext_call.return_data[0] * uint8(ext_call.return_data[160])) - (ext_call.return_data[32] * uint8(ext_call.return_data[160])))
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(11 * ceil32(return_data.size)) + 864 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((12 * ceil32(return_data.size)) + 992 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(12 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
                mem[(12 * ceil32(return_data.size)) + 896] = ext_call.return_data[32]
                mem[(12 * ceil32(return_data.size)) + 928] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(12 * ceil32(return_data.size)) + 960] = ext_call.return_data[96]
                if block.timestamp < ext_call.return_data[64]:
                    revert with 0, 17
                if block.timestamp - ext_call.return_data[64] and sub_6508597e > -1 / block.timestamp - ext_call.return_data[64]:
                    revert with 0, 17
                if 0 > !((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600):
                    revert with 0, 17
                if ext_call.return_data[126 len 2] and sub_c7cd2b04 > -1 / ext_call.return_data[126 len 2]:
                    revert with 0, 17
                mem[(12 * ceil32(return_data.size)) + 996] = address(ext_call.return_data[96])
                staticcall sub_f9318b45Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[96])
                mem[(12 * ceil32(return_data.size)) + 992] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (13 * ceil32(return_data.size)) + 992
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[96])
                    mem[mem[64] + 36] = idx
                    staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[96]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _848 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_848]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _877 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _884 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_884] = mem[_877]
                    mem[_884 + 32] = mem[_877 + 32]
                    mem[_884 + 64] = mem[_877 + 64]
                    if 24 * 3600 > !mem[_884 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_884 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s < sub_599a3d39:
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                        revert with 0, 17
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 928] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600)
                else:
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                        revert with 0, 17
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if s < sub_599a3d39 - 1:
                        revert with 0, 17
                    t = 1
                    u = sub_a45de402
                    v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                    while t <= s + -sub_599a3d39 + 1:
                        if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                            revert with 0, 17
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                            revert with 0, 17
                        if t == -1:
                            revert with 0, 17
                        t = t + 1
                        u = 95 * u / 100
                        v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                        continue 
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !v:
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 928] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (v * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (v * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600)
        else:
            mem[(8 * ceil32(return_data.size)) + 740] = address(ext_call.return_data[0])
            staticcall sub_c38eb669Address.0x70a08231 with:
                    gas gas_remaining wei
                   args address(ext_call.return_data[0])
            mem[(8 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (10 * ceil32(return_data.size)) + 736
            require return_data.size >= 32
            idx = 0
            s = 0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = address(ext_call.return_data[0])
                mem[mem[64] + 36] = idx
                staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[0]), idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _846 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                        gas gas_remaining wei
                       args mem[_846]
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _875 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _882 = mem[64]
                if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 96
                mem[_882] = mem[_875]
                mem[_882 + 32] = mem[_875 + 32]
                mem[_882 + 64] = mem[_875 + 64]
                if 24 * 3600 > !mem[_882 + 64]:
                    revert with 0, 17
                if block.timestamp < mem[_882 + 64] + (24 * 3600):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            if s and sub_23422e8d > -1 / s:
                revert with 0, 17
            if s * sub_23422e8d > !sub_fc7c54de:
                revert with 0, 17
            if block.timestamp < mem[(6 * ceil32(return_data.size)) + 608]:
                revert with 0, 17
            if not (s * sub_23422e8d) + sub_fc7c54de:
                revert with 0, 18
            if uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de) > mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                mem[(6 * ceil32(return_data.size)) + 576] = 0
                mem[mem[64] + 4] = arg1
                staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _924 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_924] == bool(mem[_924])
                if not mem[_924]:
                    mem[mem[64] + 4] = arg1
                    staticcall sub_809deb63Address.0x6352211e with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _964 = mem[_948]
                    require mem[_948] == mem[_948 + 12 len 20]
                    if not mem[_948 + 12 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1006 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1019 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1036 = mem[_1019]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1079 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1102 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1079] == mem[_1079 + 30 len 2]
                        mem[_1102] = mem[_1079]
                        mem[_1102 + 32] = mem[_1079 + 32]
                        mem[_1102 + 64] = mem[_1079 + 64]
                        require mem[_1079 + 96] == mem[_1079 + 108 len 20]
                        mem[_1102 + 96] = mem[_1079 + 96]
                        if _1036 < mem[_1102 + 32]:
                            revert with 0, 17
                        if uint8(_1006) and _1036 - mem[_1102 + 32] > -1 / uint8(_1006):
                            revert with 0, 17
                        mem[mem[64]] = (_1036 * uint8(_1006)) - (mem[_1102 + 32] * uint8(_1006))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1020 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1037 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1020] == mem[_1020 + 30 len 2]
                        mem[_1037] = mem[_1020]
                        mem[_1037 + 32] = mem[_1020 + 32]
                        mem[_1037 + 64] = mem[_1020 + 64]
                        require mem[_1020 + 96] == mem[_1020 + 108 len 20]
                        mem[_1037 + 96] = mem[_1020 + 96]
                        _1157 = mem[_1037 + 64]
                        if block.timestamp < mem[_1037 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1037 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1037 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1037 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        if 0 and sub_c7cd2b04 > -1 / 0:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_964)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_964)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1244 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1254 = mem[_1244]
                        idx = 0
                        s = 0
                        while idx < _1254:
                            mem[mem[64] + 4] = address(_964)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_964), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1470 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1470]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1518 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1526 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1526] = mem[_1518]
                            mem[_1526 + 32] = mem[_1518 + 32]
                            mem[_1526 + 64] = mem[_1518 + 64]
                            if 24 * 3600 > !mem[_1526 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1526 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if 0 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1037 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1037 + 64] and mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 > -1 / block.timestamp - mem[_1037 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1157 * sub_6508597e) / 24 * 3600 > !((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1037 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1157 * sub_6508597e) / 24 * 3600) + ((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1037 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if 0 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1037 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1037 + 64] and v > -1 / block.timestamp - mem[_1037 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1157 * sub_6508597e) / 24 * 3600 > !((v * block.timestamp) - (v * mem[_1037 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1157 * sub_6508597e) / 24 * 3600) + ((v * block.timestamp) - (v * mem[_1037 + 64]) / 24 * 3600)
                else:
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _965 = mem[64]
                    if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 128
                    require mem[_949] == mem[_949 + 30 len 2]
                    mem[_965] = mem[_949]
                    mem[_965 + 32] = mem[_949 + 32]
                    mem[_965 + 64] = mem[_949 + 64]
                    require mem[_949 + 96] == mem[_949 + 108 len 20]
                    mem[_965 + 96] = mem[_949 + 96]
                    _1011 = mem[_965 + 96]
                    if not mem[_965 + 108 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1059 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1080 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1106 = mem[_1080]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1136 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1158 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1136] == mem[_1136 + 30 len 2]
                        mem[_1158] = mem[_1136]
                        mem[_1158 + 32] = mem[_1136 + 32]
                        mem[_1158 + 64] = mem[_1136 + 64]
                        require mem[_1136 + 96] == mem[_1136 + 108 len 20]
                        mem[_1158 + 96] = mem[_1136 + 96]
                        if _1106 < mem[_1158 + 32]:
                            revert with 0, 17
                        if uint8(_1059) and _1106 - mem[_1158 + 32] > -1 / uint8(_1059):
                            revert with 0, 17
                        mem[mem[64]] = (_1106 * uint8(_1059)) - (mem[_1158 + 32] * uint8(_1059))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1081 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1107 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1081] == mem[_1081 + 30 len 2]
                        mem[_1107] = mem[_1081]
                        mem[_1107 + 32] = mem[_1081 + 32]
                        mem[_1107 + 64] = mem[_1081 + 64]
                        require mem[_1081 + 96] == mem[_1081 + 108 len 20]
                        mem[_1107 + 96] = mem[_1081 + 96]
                        _1199 = mem[_1107 + 64]
                        if block.timestamp < mem[_1107 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1107 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1107 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1107 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        if 0 and sub_c7cd2b04 > -1 / 0:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_1011)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_1011)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1263 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1271 = mem[_1263]
                        idx = 0
                        s = 0
                        while idx < _1271:
                            mem[mem[64] + 4] = address(_1011)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_1011), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1471 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1471]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1519 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1527 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1527] = mem[_1519]
                            mem[_1527 + 32] = mem[_1519 + 32]
                            mem[_1527 + 64] = mem[_1519 + 64]
                            if 24 * 3600 > !mem[_1527 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1527 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if 0 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1107 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1107 + 64] and mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 > -1 / block.timestamp - mem[_1107 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1199 * sub_6508597e) / 24 * 3600 > !((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1107 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1199 * sub_6508597e) / 24 * 3600) + ((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1107 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if 0 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1107 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1107 + 64] and v > -1 / block.timestamp - mem[_1107 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1199 * sub_6508597e) / 24 * 3600 > !((v * block.timestamp) - (v * mem[_1107 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1199 * sub_6508597e) / 24 * 3600) + ((v * block.timestamp) - (v * mem[_1107 + 64]) / 24 * 3600)
            else:
                if mem[(6 * ceil32(return_data.size)) + 606 len 2] < uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de):
                    revert with 0, 17
                mem[(6 * ceil32(return_data.size)) + 576] = uint16(mem[(6 * ceil32(return_data.size)) + 606 len 2] - uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de))
                mem[mem[64] + 4] = arg1
                staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _930 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_930] == bool(mem[_930])
                if not mem[_930]:
                    mem[mem[64] + 4] = arg1
                    staticcall sub_809deb63Address.0x6352211e with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _976 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _982 = mem[_976]
                    require mem[_976] == mem[_976 + 12 len 20]
                    if not mem[_976 + 12 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1030 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1054 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1086 = mem[_1054]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1122 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1138 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1122] == mem[_1122 + 30 len 2]
                        mem[_1138] = mem[_1122]
                        mem[_1138 + 32] = mem[_1122 + 32]
                        mem[_1138 + 64] = mem[_1122 + 64]
                        require mem[_1122 + 96] == mem[_1122 + 108 len 20]
                        mem[_1138 + 96] = mem[_1122 + 96]
                        if _1086 < mem[_1138 + 32]:
                            revert with 0, 17
                        if uint8(_1030) and _1086 - mem[_1138 + 32] > -1 / uint8(_1030):
                            revert with 0, 17
                        mem[mem[64]] = (_1086 * uint8(_1030)) - (mem[_1138 + 32] * uint8(_1030))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1055 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1087 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1055] == mem[_1055 + 30 len 2]
                        mem[_1087] = mem[_1055]
                        mem[_1087 + 32] = mem[_1055 + 32]
                        mem[_1087 + 64] = mem[_1055 + 64]
                        require mem[_1055 + 96] == mem[_1055 + 108 len 20]
                        mem[_1087 + 96] = mem[_1055 + 96]
                        _1181 = mem[_1087 + 64]
                        if block.timestamp < mem[_1087 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1087 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1087 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1087 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        _1226 = mem[(6 * ceil32(return_data.size)) + 576]
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_c7cd2b04 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_982)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_982)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1258 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1266 = mem[_1258]
                        idx = 0
                        s = 0
                        while idx < _1266:
                            mem[mem[64] + 4] = address(_982)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_982), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1468 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1468]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1516 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1524 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1524] = mem[_1516]
                            mem[_1524 + 32] = mem[_1516 + 32]
                            mem[_1524 + 64] = mem[_1516 + 64]
                            if 24 * 3600 > !mem[_1524 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1524 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if uint16(_1226) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1087 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1087 + 64] and (uint16(_1226) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[_1087 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1181 * sub_6508597e) / 24 * 3600 > !((uint16(_1226) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1226) * sub_c7cd2b04 * mem[_1087 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1087 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1181 * sub_6508597e) / 24 * 3600) + ((uint16(_1226) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1226) * sub_c7cd2b04 * mem[_1087 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1087 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if uint16(_1226) * sub_c7cd2b04 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1087 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1087 + 64] and (uint16(_1226) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[_1087 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1181 * sub_6508597e) / 24 * 3600 > !((uint16(_1226) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1226) * sub_c7cd2b04 * mem[_1087 + 64]) - (v * mem[_1087 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1181 * sub_6508597e) / 24 * 3600) + ((uint16(_1226) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1226) * sub_c7cd2b04 * mem[_1087 + 64]) - (v * mem[_1087 + 64]) / 24 * 3600)
                else:
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _977 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _983 = mem[64]
                    if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 128
                    require mem[_977] == mem[_977 + 30 len 2]
                    mem[_983] = mem[_977]
                    mem[_983 + 32] = mem[_977 + 32]
                    mem[_983 + 64] = mem[_977 + 64]
                    require mem[_977 + 96] == mem[_977 + 108 len 20]
                    mem[_983 + 96] = mem[_977 + 96]
                    _1035 = mem[_983 + 96]
                    if not mem[_983 + 108 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1097 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1123 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1142 = mem[_1123]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1174 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1182 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1174] == mem[_1174 + 30 len 2]
                        mem[_1182] = mem[_1174]
                        mem[_1182 + 32] = mem[_1174 + 32]
                        mem[_1182 + 64] = mem[_1174 + 64]
                        require mem[_1174 + 96] == mem[_1174 + 108 len 20]
                        mem[_1182 + 96] = mem[_1174 + 96]
                        if _1142 < mem[_1182 + 32]:
                            revert with 0, 17
                        if uint8(_1097) and _1142 - mem[_1182 + 32] > -1 / uint8(_1097):
                            revert with 0, 17
                        mem[mem[64]] = (_1142 * uint8(_1097)) - (mem[_1182 + 32] * uint8(_1097))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1124 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1143 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1124] == mem[_1124 + 30 len 2]
                        mem[_1143] = mem[_1124]
                        mem[_1143 + 32] = mem[_1124 + 32]
                        mem[_1143 + 64] = mem[_1124 + 64]
                        require mem[_1124 + 96] == mem[_1124 + 108 len 20]
                        mem[_1143 + 96] = mem[_1124 + 96]
                        _1210 = mem[_1143 + 64]
                        if block.timestamp < mem[_1143 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1143 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1143 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1143 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        _1243 = mem[(6 * ceil32(return_data.size)) + 576]
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_c7cd2b04 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_1035)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_1035)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1274 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1284 = mem[_1274]
                        idx = 0
                        s = 0
                        while idx < _1284:
                            mem[mem[64] + 4] = address(_1035)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_1035), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1469 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1469]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1517 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1525 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1525] = mem[_1517]
                            mem[_1525 + 32] = mem[_1517 + 32]
                            mem[_1525 + 64] = mem[_1517 + 64]
                            if 24 * 3600 > !mem[_1525 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1525 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if uint16(_1243) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1143 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1143 + 64] and (uint16(_1243) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[_1143 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1210 * sub_6508597e) / 24 * 3600 > !((uint16(_1243) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1243) * sub_c7cd2b04 * mem[_1143 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1143 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1210 * sub_6508597e) / 24 * 3600) + ((uint16(_1243) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1243) * sub_c7cd2b04 * mem[_1143 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1143 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if uint16(_1243) * sub_c7cd2b04 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1143 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1143 + 64] and (uint16(_1243) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[_1143 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1210 * sub_6508597e) / 24 * 3600 > !((uint16(_1243) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1243) * sub_c7cd2b04 * mem[_1143 + 64]) - (v * mem[_1143 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1210 * sub_6508597e) / 24 * 3600) + ((uint16(_1243) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1243) * sub_c7cd2b04 * mem[_1143 + 64]) - (v * mem[_1143 + 64]) / 24 * 3600)
    else:
        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                gas gas_remaining wei
               args arg1
        mem[(7 * ceil32(return_data.size)) + 736 len 128] = ext_call.return_data[0 len 128]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 128
        if not bool((8 * ceil32(return_data.size)) + 864 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == ext_call.return_data[30 len 2]
        mem[(8 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
        mem[(8 * ceil32(return_data.size)) + 768] = ext_call.return_data[32]
        mem[(8 * ceil32(return_data.size)) + 800] = ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[108 len 20]
        mem[(8 * ceil32(return_data.size)) + 832] = ext_call.return_data[96]
        if not ext_call.return_data[108 len 20]:
            revert with 0, 'The owner cannot be address(0)'
        if 0 == ext_call.return_data[126 len 2]:
            mem[(8 * ceil32(return_data.size)) + 868] = arg1
            staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                    gas gas_remaining wei
                   args arg1
            mem[(8 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                mem[(10 * ceil32(return_data.size)) + 868] = arg1
                staticcall sub_809deb63Address.0x6352211e with:
                        gas gas_remaining wei
                       args arg1
                mem[(10 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if not ext_call.return_data[12 len 20]:
                    revert with 0, 'The owner cannot be address(0)'
                if not ext_call.return_data[32]:
                    staticcall sub_93066351Address.0x219bec0b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    if not bool((13 * ceil32(return_data.size)) + 992 <= test266151307()):
                        revert with 0, 65
                    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                    require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                    if ext_call.return_data[0] < ext_call.return_data[32]:
                        revert with 0, 17
                    if uint8(ext_call.return_data[160]) and ext_call.return_data[0] - ext_call.return_data[32] > -1 / uint8(ext_call.return_data[160]):
                        revert with 0, 17
                    return ((ext_call.return_data[0] * uint8(ext_call.return_data[160])) - (ext_call.return_data[32] * uint8(ext_call.return_data[160])))
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(11 * ceil32(return_data.size)) + 864 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((12 * ceil32(return_data.size)) + 992 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(12 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
                mem[(12 * ceil32(return_data.size)) + 896] = ext_call.return_data[32]
                mem[(12 * ceil32(return_data.size)) + 928] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(12 * ceil32(return_data.size)) + 960] = ext_call.return_data[96]
                if block.timestamp < ext_call.return_data[64]:
                    revert with 0, 17
                if block.timestamp - ext_call.return_data[64] and sub_6508597e > -1 / block.timestamp - ext_call.return_data[64]:
                    revert with 0, 17
                if 0 > !((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600):
                    revert with 0, 17
                if ext_call.return_data[126 len 2] and sub_c7cd2b04 > -1 / ext_call.return_data[126 len 2]:
                    revert with 0, 17
                mem[(12 * ceil32(return_data.size)) + 996] = address(ext_call.return_data[0])
                staticcall sub_f9318b45Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[0])
                mem[(12 * ceil32(return_data.size)) + 992] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (13 * ceil32(return_data.size)) + 992
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[0])
                    mem[mem[64] + 36] = idx
                    staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[0]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _850 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_850]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _880 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _886 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_886] = mem[_880]
                    mem[_886 + 32] = mem[_880 + 32]
                    mem[_886 + 64] = mem[_880 + 64]
                    if 24 * 3600 > !mem[_886 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_886 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s < sub_599a3d39:
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                        revert with 0, 17
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 928] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600)
                else:
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                        revert with 0, 17
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if s < sub_599a3d39 - 1:
                        revert with 0, 17
                    t = 1
                    u = sub_a45de402
                    v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                    while t <= s + -sub_599a3d39 + 1:
                        if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                            revert with 0, 17
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                            revert with 0, 17
                        if t == -1:
                            revert with 0, 17
                        t = t + 1
                        u = 95 * u / 100
                        v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                        continue 
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !v:
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 928] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 928]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (v * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 928]) - (v * mem[(12 * ceil32(return_data.size)) + 928]) / 24 * 3600)
            else:
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(10 * ceil32(return_data.size)) + 864 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((11 * ceil32(return_data.size)) + 992 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(11 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
                mem[(11 * ceil32(return_data.size)) + 896] = ext_call.return_data[32]
                mem[(11 * ceil32(return_data.size)) + 928] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(11 * ceil32(return_data.size)) + 960] = ext_call.return_data[96]
                if not ext_call.return_data[108 len 20]:
                    revert with 0, 'The owner cannot be address(0)'
                if not ext_call.return_data[32]:
                    staticcall sub_93066351Address.0x219bec0b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 128
                    if not bool((13 * ceil32(return_data.size)) + 1120 <= test266151307()):
                        revert with 0, 65
                    require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                    require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                    if ext_call.return_data[0] < ext_call.return_data[32]:
                        revert with 0, 17
                    if uint8(ext_call.return_data[160]) and ext_call.return_data[0] - ext_call.return_data[32] > -1 / uint8(ext_call.return_data[160]):
                        revert with 0, 17
                    return ((ext_call.return_data[0] * uint8(ext_call.return_data[160])) - (ext_call.return_data[32] * uint8(ext_call.return_data[160])))
                staticcall sub_93066351Address.getStake(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[(11 * ceil32(return_data.size)) + 992 len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 128
                if not bool((12 * ceil32(return_data.size)) + 1120 <= test266151307()):
                    revert with 0, 65
                require ext_call.return_data[0] == ext_call.return_data[30 len 2]
                mem[(12 * ceil32(return_data.size)) + 992] = ext_call.return_data[0]
                mem[(12 * ceil32(return_data.size)) + 1024] = ext_call.return_data[32]
                mem[(12 * ceil32(return_data.size)) + 1056] = ext_call.return_data[64]
                require ext_call.return_data[96] == ext_call.return_data[108 len 20]
                mem[(12 * ceil32(return_data.size)) + 1088] = ext_call.return_data[96]
                if block.timestamp < ext_call.return_data[64]:
                    revert with 0, 17
                if block.timestamp - ext_call.return_data[64] and sub_6508597e > -1 / block.timestamp - ext_call.return_data[64]:
                    revert with 0, 17
                if 0 > !((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600):
                    revert with 0, 17
                if ext_call.return_data[126 len 2] and sub_c7cd2b04 > -1 / ext_call.return_data[126 len 2]:
                    revert with 0, 17
                mem[(12 * ceil32(return_data.size)) + 1124] = address(ext_call.return_data[96])
                staticcall sub_f9318b45Address.0x70a08231 with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[96])
                mem[(12 * ceil32(return_data.size)) + 1120] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (13 * ceil32(return_data.size)) + 1120
                require return_data.size >= 32
                idx = 0
                s = 0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = address(ext_call.return_data[96])
                    mem[mem[64] + 36] = idx
                    staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                            gas gas_remaining wei
                           args address(ext_call.return_data[96]), idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _851 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                            gas gas_remaining wei
                           args mem[_851]
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _881 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _887 = mem[64]
                    if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 96
                    mem[_887] = mem[_881]
                    mem[_887 + 32] = mem[_881 + 32]
                    mem[_887 + 64] = mem[_881 + 64]
                    if 24 * 3600 > !mem[_887 + 64]:
                        revert with 0, 17
                    if block.timestamp < mem[_887 + 64] + (24 * 3600):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 1
                    continue 
                if s < sub_599a3d39:
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                        revert with 0, 17
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 1056]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 1056] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 1056]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 1056]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 1056]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 1056]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[(12 * ceil32(return_data.size)) + 1056]) / 24 * 3600)
                else:
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                        revert with 0, 17
                    if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                        revert with 0, 17
                    if sub_599a3d39 < 1:
                        revert with 0, 17
                    if s < sub_599a3d39 - 1:
                        revert with 0, 17
                    t = 1
                    u = sub_a45de402
                    v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                    while t <= s + -sub_599a3d39 + 1:
                        if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                            revert with 0, 17
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                            revert with 0, 17
                        if t == -1:
                            revert with 0, 17
                        t = t + 1
                        u = 95 * u / 100
                        v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                        continue 
                    if uint16(ext_call.return_data[96]) * sub_c7cd2b04 > !v:
                        revert with 0, 17
                    if block.timestamp < mem[(12 * ceil32(return_data.size)) + 1056]:
                        revert with 0, 17
                    if block.timestamp - mem[(12 * ceil32(return_data.size)) + 1056] and (uint16(ext_call.return_data[96]) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[(12 * ceil32(return_data.size)) + 1056]:
                        revert with 0, 17
                    if (block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600 > !((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 1056]) - (v * mem[(12 * ceil32(return_data.size)) + 1056]) / 24 * 3600):
                        revert with 0, 17
                    mem[mem[64]] = ((block.timestamp * sub_6508597e) - (ext_call.return_data[64] * sub_6508597e) / 24 * 3600) + ((uint16(ext_call.return_data[96]) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(ext_call.return_data[96]) * sub_c7cd2b04 * mem[(12 * ceil32(return_data.size)) + 1056]) - (v * mem[(12 * ceil32(return_data.size)) + 1056]) / 24 * 3600)
        else:
            mem[(8 * ceil32(return_data.size)) + 868] = ext_call.return_data[108 len 20]
            staticcall sub_c38eb669Address.0x70a08231 with:
                    gas gas_remaining wei
                   args ext_call.return_data[108 len 20]
            mem[(8 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (10 * ceil32(return_data.size)) + 864
            require return_data.size >= 32
            idx = 0
            s = 0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = address(ext_call.return_data[96])
                mem[mem[64] + 36] = idx
                staticcall sub_c38eb669Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                        gas gas_remaining wei
                       args address(ext_call.return_data[96]), idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _849 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                staticcall sub_c38eb669Address.getTokenTraits(uint256 arg1) with:
                        gas gas_remaining wei
                       args mem[_849]
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _879 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _885 = mem[64]
                if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 96
                mem[_885] = mem[_879]
                mem[_885 + 32] = mem[_879 + 32]
                mem[_885 + 64] = mem[_879 + 64]
                if 24 * 3600 > !mem[_885 + 64]:
                    revert with 0, 17
                if block.timestamp < mem[_885 + 64] + (24 * 3600):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 1
                continue 
            if s and sub_23422e8d > -1 / s:
                revert with 0, 17
            if s * sub_23422e8d > !sub_fc7c54de:
                revert with 0, 17
            if block.timestamp < mem[(6 * ceil32(return_data.size)) + 608]:
                revert with 0, 17
            if not (s * sub_23422e8d) + sub_fc7c54de:
                revert with 0, 18
            if uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de) > mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                mem[(6 * ceil32(return_data.size)) + 576] = 0
                mem[mem[64] + 4] = arg1
                staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _925 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_925] == bool(mem[_925])
                if not mem[_925]:
                    mem[mem[64] + 4] = arg1
                    staticcall sub_809deb63Address.0x6352211e with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _952 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _972 = mem[_952]
                    require mem[_952] == mem[_952 + 12 len 20]
                    if not mem[_952 + 12 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1012 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1022 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1048 = mem[_1022]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1083 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1116 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1083] == mem[_1083 + 30 len 2]
                        mem[_1116] = mem[_1083]
                        mem[_1116 + 32] = mem[_1083 + 32]
                        mem[_1116 + 64] = mem[_1083 + 64]
                        require mem[_1083 + 96] == mem[_1083 + 108 len 20]
                        mem[_1116 + 96] = mem[_1083 + 96]
                        if _1048 < mem[_1116 + 32]:
                            revert with 0, 17
                        if uint8(_1012) and _1048 - mem[_1116 + 32] > -1 / uint8(_1012):
                            revert with 0, 17
                        mem[mem[64]] = (_1048 * uint8(_1012)) - (mem[_1116 + 32] * uint8(_1012))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1023 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1049 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1023] == mem[_1023 + 30 len 2]
                        mem[_1049] = mem[_1023]
                        mem[_1049 + 32] = mem[_1023 + 32]
                        mem[_1049 + 64] = mem[_1023 + 64]
                        require mem[_1023 + 96] == mem[_1023 + 108 len 20]
                        mem[_1049 + 96] = mem[_1023 + 96]
                        _1169 = mem[_1049 + 64]
                        if block.timestamp < mem[_1049 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1049 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1049 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1049 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        if 0 and sub_c7cd2b04 > -1 / 0:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_972)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_972)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1247 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1257 = mem[_1247]
                        idx = 0
                        s = 0
                        while idx < _1257:
                            mem[mem[64] + 4] = address(_972)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_972), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1474 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1474]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1522 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1530 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1530] = mem[_1522]
                            mem[_1530 + 32] = mem[_1522 + 32]
                            mem[_1530 + 64] = mem[_1522 + 64]
                            if 24 * 3600 > !mem[_1530 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1530 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if 0 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1049 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1049 + 64] and mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 > -1 / block.timestamp - mem[_1049 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1169 * sub_6508597e) / 24 * 3600 > !((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1049 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1169 * sub_6508597e) / 24 * 3600) + ((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1049 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if 0 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1049 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1049 + 64] and v > -1 / block.timestamp - mem[_1049 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1169 * sub_6508597e) / 24 * 3600 > !((v * block.timestamp) - (v * mem[_1049 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1169 * sub_6508597e) / 24 * 3600) + ((v * block.timestamp) - (v * mem[_1049 + 64]) / 24 * 3600)
                else:
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _953 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _973 = mem[64]
                    if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 128
                    require mem[_953] == mem[_953 + 30 len 2]
                    mem[_973] = mem[_953]
                    mem[_973 + 32] = mem[_953 + 32]
                    mem[_973 + 64] = mem[_953 + 64]
                    require mem[_953 + 96] == mem[_953 + 108 len 20]
                    mem[_973 + 96] = mem[_953 + 96]
                    _1017 = mem[_973 + 96]
                    if not mem[_973 + 108 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1071 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1084 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1120 = mem[_1084]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1137 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1170 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1137] == mem[_1137 + 30 len 2]
                        mem[_1170] = mem[_1137]
                        mem[_1170 + 32] = mem[_1137 + 32]
                        mem[_1170 + 64] = mem[_1137 + 64]
                        require mem[_1137 + 96] == mem[_1137 + 108 len 20]
                        mem[_1170 + 96] = mem[_1137 + 96]
                        if _1120 < mem[_1170 + 32]:
                            revert with 0, 17
                        if uint8(_1071) and _1120 - mem[_1170 + 32] > -1 / uint8(_1071):
                            revert with 0, 17
                        mem[mem[64]] = (_1120 * uint8(_1071)) - (mem[_1170 + 32] * uint8(_1071))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1085 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1121 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1085] == mem[_1085 + 30 len 2]
                        mem[_1121] = mem[_1085]
                        mem[_1121 + 32] = mem[_1085 + 32]
                        mem[_1121 + 64] = mem[_1085 + 64]
                        require mem[_1085 + 96] == mem[_1085 + 108 len 20]
                        mem[_1121 + 96] = mem[_1085 + 96]
                        _1205 = mem[_1121 + 64]
                        if block.timestamp < mem[_1121 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1121 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1121 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1121 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        if 0 and sub_c7cd2b04 > -1 / 0:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_1017)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_1017)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1265 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1273 = mem[_1265]
                        idx = 0
                        s = 0
                        while idx < _1273:
                            mem[mem[64] + 4] = address(_1017)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_1017), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1475 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1475]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1523 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1531 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1531] = mem[_1523]
                            mem[_1531 + 32] = mem[_1523 + 32]
                            mem[_1531 + 64] = mem[_1523 + 64]
                            if 24 * 3600 > !mem[_1531 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1531 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if 0 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1121 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1121 + 64] and mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 > -1 / block.timestamp - mem[_1121 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1205 * sub_6508597e) / 24 * 3600 > !((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1121 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1205 * sub_6508597e) / 24 * 3600) + ((mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1121 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if 0 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1121 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1121 + 64] and v > -1 / block.timestamp - mem[_1121 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1205 * sub_6508597e) / 24 * 3600 > !((v * block.timestamp) - (v * mem[_1121 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1205 * sub_6508597e) / 24 * 3600) + ((v * block.timestamp) - (v * mem[_1121 + 64]) / 24 * 3600)
            else:
                if mem[(6 * ceil32(return_data.size)) + 606 len 2] < uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de):
                    revert with 0, 17
                mem[(6 * ceil32(return_data.size)) + 576] = uint16(mem[(6 * ceil32(return_data.size)) + 606 len 2] - uint16(block.timestamp - mem[(6 * ceil32(return_data.size)) + 608] / (s * sub_23422e8d) + sub_fc7c54de))
                mem[mem[64] + 4] = arg1
                staticcall sub_93066351Address.isStaked(uint256 arg1) with:
                        gas gas_remaining wei
                       args arg1
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _932 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_932] == bool(mem[_932])
                if not mem[_932]:
                    mem[mem[64] + 4] = arg1
                    staticcall sub_809deb63Address.0x6352211e with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _979 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _984 = mem[_979]
                    require mem[_979] == mem[_979 + 12 len 20]
                    if not mem[_979 + 12 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1042 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1066 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1090 = mem[_1066]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1129 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1144 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1129] == mem[_1129 + 30 len 2]
                        mem[_1144] = mem[_1129]
                        mem[_1144 + 32] = mem[_1129 + 32]
                        mem[_1144 + 64] = mem[_1129 + 64]
                        require mem[_1129 + 96] == mem[_1129 + 108 len 20]
                        mem[_1144 + 96] = mem[_1129 + 96]
                        if _1090 < mem[_1144 + 32]:
                            revert with 0, 17
                        if uint8(_1042) and _1090 - mem[_1144 + 32] > -1 / uint8(_1042):
                            revert with 0, 17
                        mem[mem[64]] = (_1090 * uint8(_1042)) - (mem[_1144 + 32] * uint8(_1042))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1067 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1091 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1067] == mem[_1067 + 30 len 2]
                        mem[_1091] = mem[_1067]
                        mem[_1091 + 32] = mem[_1067 + 32]
                        mem[_1091 + 64] = mem[_1067 + 64]
                        require mem[_1067 + 96] == mem[_1067 + 108 len 20]
                        mem[_1091 + 96] = mem[_1067 + 96]
                        _1189 = mem[_1091 + 64]
                        if block.timestamp < mem[_1091 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1091 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1091 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1091 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        _1227 = mem[(6 * ceil32(return_data.size)) + 576]
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_c7cd2b04 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_984)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_984)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1260 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1268 = mem[_1260]
                        idx = 0
                        s = 0
                        while idx < _1268:
                            mem[mem[64] + 4] = address(_984)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_984), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1472 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1472]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1520 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1528 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1528] = mem[_1520]
                            mem[_1528 + 32] = mem[_1520 + 32]
                            mem[_1528 + 64] = mem[_1520 + 64]
                            if 24 * 3600 > !mem[_1528 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1528 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if uint16(_1227) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1091 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1091 + 64] and (uint16(_1227) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[_1091 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1189 * sub_6508597e) / 24 * 3600 > !((uint16(_1227) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1227) * sub_c7cd2b04 * mem[_1091 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1091 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1189 * sub_6508597e) / 24 * 3600) + ((uint16(_1227) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1227) * sub_c7cd2b04 * mem[_1091 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1091 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if uint16(_1227) * sub_c7cd2b04 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1091 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1091 + 64] and (uint16(_1227) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[_1091 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1189 * sub_6508597e) / 24 * 3600 > !((uint16(_1227) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1227) * sub_c7cd2b04 * mem[_1091 + 64]) - (v * mem[_1091 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1189 * sub_6508597e) / 24 * 3600) + ((uint16(_1227) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1227) * sub_c7cd2b04 * mem[_1091 + 64]) - (v * mem[_1091 + 64]) / 24 * 3600)
                else:
                    staticcall sub_93066351Address.getStake(uint256 arg1) with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _980 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 128
                    _985 = mem[64]
                    if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 128
                    require mem[_980] == mem[_980 + 30 len 2]
                    mem[_985] = mem[_980]
                    mem[_985 + 32] = mem[_980 + 32]
                    mem[_985 + 64] = mem[_980 + 64]
                    require mem[_980 + 96] == mem[_980 + 108 len 20]
                    mem[_985 + 96] = mem[_980 + 96]
                    _1047 = mem[_985 + 96]
                    if not mem[_985 + 108 len 20]:
                        revert with 0, 'The owner cannot be address(0)'
                    if not mem[(6 * ceil32(return_data.size)) + 512]:
                        _1111 = mem[(6 * ceil32(return_data.size)) + 640]
                        staticcall sub_93066351Address.0x219bec0b with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1130 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1148 = mem[_1130]
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1176 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1190 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1176] == mem[_1176 + 30 len 2]
                        mem[_1190] = mem[_1176]
                        mem[_1190 + 32] = mem[_1176 + 32]
                        mem[_1190 + 64] = mem[_1176 + 64]
                        require mem[_1176 + 96] == mem[_1176 + 108 len 20]
                        mem[_1190 + 96] = mem[_1176 + 96]
                        if _1148 < mem[_1190 + 32]:
                            revert with 0, 17
                        if uint8(_1111) and _1148 - mem[_1190 + 32] > -1 / uint8(_1111):
                            revert with 0, 17
                        mem[mem[64]] = (_1148 * uint8(_1111)) - (mem[_1190 + 32] * uint8(_1111))
                    else:
                        staticcall sub_93066351Address.getStake(uint256 arg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 128
                        _1149 = mem[64]
                        if mem[64] + 128 > test266151307() or mem[64] + 128 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 128
                        require mem[_1131] == mem[_1131 + 30 len 2]
                        mem[_1149] = mem[_1131]
                        mem[_1149 + 32] = mem[_1131 + 32]
                        mem[_1149 + 64] = mem[_1131 + 64]
                        require mem[_1131 + 96] == mem[_1131 + 108 len 20]
                        mem[_1149 + 96] = mem[_1131 + 96]
                        _1215 = mem[_1149 + 64]
                        if block.timestamp < mem[_1149 + 64]:
                            revert with 0, 17
                        if block.timestamp - mem[_1149 + 64] and sub_6508597e > -1 / block.timestamp - mem[_1149 + 64]:
                            revert with 0, 17
                        if 0 > !((block.timestamp * sub_6508597e) - (mem[_1149 + 64] * sub_6508597e) / 24 * 3600):
                            revert with 0, 17
                        _1246 = mem[(6 * ceil32(return_data.size)) + 576]
                        if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_c7cd2b04 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(_1047)
                        staticcall sub_f9318b45Address.0x70a08231 with:
                                gas gas_remaining wei
                               args address(_1047)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1277 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1286 = mem[_1277]
                        idx = 0
                        s = 0
                        while idx < _1286:
                            mem[mem[64] + 4] = address(_1047)
                            mem[mem[64] + 36] = idx
                            staticcall sub_f9318b45Address.tokenOfOwnerByIndex(address arg1, uint256 arg2) with:
                                    gas gas_remaining wei
                                   args address(_1047), idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            staticcall sub_f9318b45Address.getTokenTraits(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args mem[_1473]
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1521 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _1529 = mem[64]
                            if mem[64] + 96 > test266151307() or mem[64] + 96 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 96
                            mem[_1529] = mem[_1521]
                            mem[_1529 + 32] = mem[_1521 + 32]
                            mem[_1529 + 64] = mem[_1521 + 64]
                            if 24 * 3600 > !mem[_1529 + 64]:
                                revert with 0, 17
                            if block.timestamp < mem[_1529 + 64] + (24 * 3600):
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s
                                continue 
                            if s == -1:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 1
                            continue 
                        if s < sub_599a3d39:
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and s > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] * s and sub_a45de402 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2] * s:
                                revert with 0, 17
                            if uint16(_1246) * sub_c7cd2b04 > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402):
                                revert with 0, 17
                            if block.timestamp < mem[_1149 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1149 + 64] and (uint16(_1246) * sub_c7cd2b04) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402) > -1 / block.timestamp - mem[_1149 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1215 * sub_6508597e) / 24 * 3600 > !((uint16(_1246) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1246) * sub_c7cd2b04 * mem[_1149 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1149 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1215 * sub_6508597e) / 24 * 3600) + ((uint16(_1246) * sub_c7cd2b04 * block.timestamp) + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * block.timestamp) - (uint16(_1246) * sub_c7cd2b04 * mem[_1149 + 64]) - (mem[(6 * ceil32(return_data.size)) + 606 len 2] * s * sub_a45de402 * mem[_1149 + 64]) / 24 * 3600)
                        else:
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if mem[(6 * ceil32(return_data.size)) + 606 len 2] and sub_599a3d39 - 1 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                revert with 0, 17
                            if -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]) and sub_a45de402 > -1 / -mem[(6 * ceil32(return_data.size)) + 606 len 2] + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2]):
                                revert with 0, 17
                            if sub_599a3d39 < 1:
                                revert with 0, 17
                            if s < sub_599a3d39 - 1:
                                revert with 0, 17
                            t = 1
                            u = sub_a45de402
                            v = (-1 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402) + (sub_599a3d39 * mem[(6 * ceil32(return_data.size)) + 606 len 2] * sub_a45de402)
                            while t <= s + -sub_599a3d39 + 1:
                                if u > 0x2b1da46102b1da46102b1da46102b1da46102b1da46102b1da46102b1da4610:
                                    revert with 0, 17
                                if mem[(6 * ceil32(return_data.size)) + 606 len 2] and 95 * u / 100 > -1 / mem[(6 * ceil32(return_data.size)) + 606 len 2]:
                                    revert with 0, 17
                                if v > !(mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100):
                                    revert with 0, 17
                                if t == -1:
                                    revert with 0, 17
                                t = t + 1
                                u = 95 * u / 100
                                v = v + (mem[(6 * ceil32(return_data.size)) + 606 len 2] * 95 * u / 100)
                                continue 
                            if uint16(_1246) * sub_c7cd2b04 > !v:
                                revert with 0, 17
                            if block.timestamp < mem[_1149 + 64]:
                                revert with 0, 17
                            if block.timestamp - mem[_1149 + 64] and (uint16(_1246) * sub_c7cd2b04) + v > -1 / block.timestamp - mem[_1149 + 64]:
                                revert with 0, 17
                            if (block.timestamp * sub_6508597e) - (_1215 * sub_6508597e) / 24 * 3600 > !((uint16(_1246) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1246) * sub_c7cd2b04 * mem[_1149 + 64]) - (v * mem[_1149 + 64]) / 24 * 3600):
                                revert with 0, 17
                            mem[mem[64]] = ((block.timestamp * sub_6508597e) - (_1215 * sub_6508597e) / 24 * 3600) + ((uint16(_1246) * sub_c7cd2b04 * block.timestamp) + (v * block.timestamp) - (uint16(_1246) * sub_c7cd2b04 * mem[_1149 + 64]) - (v * mem[_1149 + 64]) / 24 * 3600)
    return memory
      from mem[64]
       len 32
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - sub_0081a21f(?)
#  - sub_5cb677ee(?)
#  - claim(uint256[] arg1)
#  - sub_a633b2f2(?)
#  - sub_aff63b7d(?)
#
address owner;
array of uint256 stor1;
array of uint256 stor2;
array of uint256 stor3;
array of uint256 stor4;
array of uint256 stor5;
array of uint256 stor6;
array of struct stor7;
address stor8;
address stor9;
address stor10;
mapping of uint8 stor11;
mapping of uint256 sub_ded2abc3;
mapping of struct stor13;

function sub_222d9d4a(?) payable {
    return stor2.length
}

function WhiteListed(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor11[arg1])
}

function sub_7e953ee7(?) payable {
    return stor5.length
}

function owner() payable {
    return owner
}

function sub_b49bb8f3(?) payable {
    return stor1.length
}

function sub_ded2abc3(?) payable {
    require calldata.size - 4 >= 32
    return sub_ded2abc3[arg1]
}

function sub_f5597032(?) payable {
    return stor4.length
}

function sub_fb0ecf68(?) payable {
    return stor3.length
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_9d041475(?) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor1.length = arg1
    stor2.length = arg2
    stor3.length = arg3
}

function sub_164af651(?) payable {
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    require ext_code.size(stor9)
    staticcall stor9.0x164af651 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_61c873f5(?) payable {
    require calldata.size - 4 >= 64
    require arg1 < 6
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 5:
        revert with 0, 33
    if arg1 == 4:
        stor5.length = arg2
    else:
        if arg1 > 5:
            revert with 0, 33
        if arg1 != 5:
            stor4.length = arg2
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_593860a9(?) payable {
    require calldata.size - 4 >= 32
    if sub_ded2abc3[arg1]:
        return sub_ded2abc3[arg1]
    require ext_code.size(stor8)
    staticcall stor8.0xded2abc3 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function setAddress(address arg1, address arg2, address arg3, address arg4, address arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    address(stor6.length) = arg2
    address(stor7.length) = arg1
    stor8 = arg3
    stor9 = arg4
    stor10 = arg5
}

function setWhitelist(address[] arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 11
        stor11[address(cd[((32 * idx) + arg1 + 36)])] = uint8(arg2)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function sub_e31b17ab(?) payable {
    require calldata.size - 4 >= 96
    require arg2 == address(arg2)
    require arg3 == bool(arg3)
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    sub_ded2abc3[arg1] = 0
    if bool(stor13[arg1].field_0):
        if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        uint256(stor13[arg1].field_0) = 0
        if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
            idx = 0
            while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor13[arg1][idx].field_0) = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
            revert with 0, 34
        uint256(stor13[arg1].field_0) = 0
        if 31 < stor13[arg1].field_1 % 128:
            idx = 0
            while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                uint256(stor13[arg1][idx].field_0) = 0
                idx = idx + 1
                continue 
    uint256(stor13[arg1].field_256) = 0
    uint256(stor13[arg1].field_512) = 0
    uint256(stor13[arg1].field_768) = 0
    uint256(stor13[arg1].field_1024) = 0
    uint256(stor13[arg1].field_1280) = 0
    uint256(stor13[arg1].field_1536) = 0
    uint16(stor13[arg1].field_1792) = 0
    if arg3:
        require ext_code.size(stor8)
        call stor8.0x37c14e70 with:
             gas gas_remaining wei
            args arg1, address(arg2)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function getMeta(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[96] = 96
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if bool(stor13[arg1].field_0):
                if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, uint256(stor13[arg1].field_0)):
                    if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                        mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[704] = uint256(stor13[arg1].field_0)
                        idx = 704
                        s = 0
                        while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            else:
                if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                if stor13[arg1].field_1 % 128:
                    if 31 >= stor13[arg1].field_1 % 128:
                        mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                    else:
                        mem[704] = uint256(stor13[arg1].field_0)
                        idx = 704
                        s = 0
                        while stor13[arg1].field_1 % 128 + 672 > idx:
                            mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                            idx = idx + 32
                            s = s + 1
                            continue 
            if uint8(stor13[arg1].field_1792) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1792) >= 6:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) >= 6:
                revert with 0, 33
            return 32, 288, 
                   uint256(stor13[arg1].field_256),
                   uint256(stor13[arg1].field_512),
                   uint256(stor13[arg1].field_768),
                   uint256(stor13[arg1].field_1024),
                   uint256(stor13[arg1].field_1280),
                   uint256(stor13[arg1].field_1536),
                   uint8(stor13[arg1].field_1792),
                   uint8(stor13[arg1].field_1800),
                   2 * Mask(256, -1, uint256(stor13[arg1].field_0)),
                   mem[704 len ceil32(uint255(uint256(stor13[arg1].field_0)) * 0.5)]
        if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 >= uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                else:
                    mem[704] = uint256(stor13[arg1].field_0)
                    idx = 704
                    s = 0
                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 >= stor13[arg1].field_1 % 128:
                    mem[704] = 256 * Mask(248, 0, stor13[arg1].field_8)
                else:
                    mem[704] = uint256(stor13[arg1].field_0)
                    idx = 704
                    s = 0
                    while stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1792) >= 6:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) >= 6:
            revert with 0, 33
        return 32, 288, 
               uint256(stor13[arg1].field_256),
               uint256(stor13[arg1].field_512),
               uint256(stor13[arg1].field_768),
               uint256(stor13[arg1].field_1024),
               uint256(stor13[arg1].field_1280),
               uint256(stor13[arg1].field_1536),
               uint8(stor13[arg1].field_1792),
               uint8(stor13[arg1].field_1800),
               stor13[arg1].field_0 % 128,
               mem[704 len ceil32(stor13[arg1].field_1 % 128)]
    mem[384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _9 = mem[384 len 4], Mask(224, 32, arg1) >> 32
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool(ceil32(return_data.size) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + 672
    _12 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < return_data.size + 384
    _17 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[ceil32(return_data.size) + 672] = _17
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + _17 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 704 len ceil32(_17)] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + 416 len ceil32(_17)]
    if ceil32(_17) > _17:
        mem[_17 + ceil32(return_data.size) + 704] = 0
    mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
    mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
    mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
    mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
    mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
    mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
    mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
    require mem[_9 + 608] < 6
    mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
    require mem[_9 + 640] < 6
    mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = 288
    mem[mem[64] + 320] = _17
    mem[mem[64] + 352 len ceil32(_17)] = mem[ceil32(return_data.size) + 704 len ceil32(_17)]
    if ceil32(_17) > _17:
        mem[_17 + mem[64] + 352] = 0
    mem[mem[64] + 64] = mem[ceil32(return_data.size) + 416]
    mem[mem[64] + 96] = mem[ceil32(return_data.size) + 448]
    mem[mem[64] + 128] = mem[ceil32(return_data.size) + 480]
    mem[mem[64] + 160] = mem[ceil32(return_data.size) + 512]
    mem[mem[64] + 192] = mem[ceil32(return_data.size) + 544]
    mem[mem[64] + 224] = mem[ceil32(return_data.size) + 576]
    if mem[ceil32(return_data.size) + 608] >= 6:
        revert with 0, 33
    mem[mem[64] + 256] = mem[ceil32(return_data.size) + 608]
    if mem[ceil32(return_data.size) + 640] >= 6:
        revert with 0, 33
    mem[mem[64] + 288] = mem[ceil32(return_data.size) + 640]
    return 32, 288, mem[mem[64] + 64 len 256], _17, mem[mem[64] + 352 len ceil32(_17)]
}

function sub_c4d4c5f0(?) payable {
    require calldata.size - 4 >= 64
    require cd[36] <= test266151307()
    require calldata.size + -cd[36] - 4 >= 288
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    require ('cd', 36).length < calldata.size + -cd[36] - 35
    require cd[(cd[36] + ('cd', 36).length + 4)] <= test266151307()
    require cd[36] + ('cd', 36).length + 36 <= calldata.size - cd[(cd[36] + ('cd', 36).length + 4)]
    if cd[(cd[36] + ('cd', 36).length + 4)] > test266151307():
        revert with 0, 65
    if bool(stor13[cd[4]].field_0):
        if bool(stor13[cd[4]].field_0) == uint255(uint256(stor13[cd[4]].field_0)) * 0.5 < 32:
            revert with 0, 34
        if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 <= 31 and cd[(cd[36] + ('cd', 36).length + 4)] <= 31:
            if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor[s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor[Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
        else:
            if uint255(uint256(stor13[cd[4]].field_0)) * 0.5 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, (uint255(uint256(stor13[cd[4]].field_0)) * 0.5) + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor13[cd[4]][s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]][Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
    else:
        if bool(stor13[cd[4]].field_0) == stor13[cd[4]].field_1 % 128 < 32:
            revert with 0, 34
        if stor13[cd[4]].field_1 % 128 <= 31 and cd[(cd[36] + ('cd', 36).length + 4)] <= 31:
            if stor13[cd[4]].field_1 % 128 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor[idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor[s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor[Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
        else:
            if stor13[cd[4]].field_1 % 128 > 31:
                if cd[(cd[36] + ('cd', 36).length + 4)] >= 32:
                    idx = Mask(251, 0, cd[(cd[36] + ('cd', 36).length + 4)] + 31) * 0.03125
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    idx = 0
                    while idx < Mask(251, 0, stor13[cd[4]].field_1 % 128 + 31) * 0.03125:
                        uint256(stor13[cd[4]][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            if cd[(cd[36] + ('cd', 36).length + 4)] > 31 != 1:
                if not cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]].field_0) = 2 * cd[(cd[36] + ('cd', 36).length + 4)]
                else:
                    uint256(stor13[cd[4]].field_0) = cd[(cd[36] + ('cd', 36).length + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)], -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)]) or 2 * cd[(cd[36] + ('cd', 36).length + 4)]
            else:
                idx = 0
                s = 0
                t = 0
                while idx < floor32(cd[(cd[36] + ('cd', 36).length + 4)]):
                    uint256(stor13[cd[4]][s].field_0) = cd[(t + cd[36] + ('cd', 36).length + 36)]
                    idx = idx + 32
                    s = s + 1
                    t = t + 32
                    continue 
                if floor32(cd[(cd[36] + ('cd', 36).length + 4)]) < cd[(cd[36] + ('cd', 36).length + 4)]:
                    uint256(stor13[cd[4]][Mask(251, 0, floor32(cd[(cd[36] + ('cd', 36).length + 4)]) + 31) >> 5].field_0) = cd[(cd[36] + ('cd', 36).length + ceil32(floor32(cd[(cd[36] + ('cd', 36).length + 4)])) + 36)] and !(Mask(256, -8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32, -1) >> 8 * cd[(cd[36] + ('cd', 36).length + 4)] % 32)
                uint256(stor13[cd[4]].field_0) = (2 * cd[(cd[36] + ('cd', 36).length + 4)]) + 1
    uint256(stor13[cd[4]].field_256) = ('cd', 36)[0]
    uint256(stor13[cd[4]].field_512) = ('cd', 36)[1]
    uint256(stor13[cd[4]].field_768) = ('cd', 36)[2]
    uint256(stor13[cd[4]].field_1024) = ('cd', 36)[3]
    uint256(stor13[cd[4]].field_1280) = ('cd', 36)[4]
    uint256(stor13[cd[4]].field_1536) = ('cd', 36)[5]
    require ('cd', 36)[6] < 6
    uint8(stor13[cd[4]].field_1792) = uint8(('cd', 36)[6])
    require ('cd', 36)[7] < 6
    uint8(stor13[cd[4]].field_1800) = uint8(('cd', 36)[7])
}

function sub_cc72ba0f(?) payable {
    require calldata.size - 4 >= 64
    mem[0] = msg.sender
    mem[32] = 11
    if not stor11[msg.sender]:
        revert with 0, 'Not allowed'
    if arg2 <= arg1:
        mem[96] = 1
        mem[64] = 160
        mem[128] = 96
        mem[160] = 32
        mem[192] = 1
        idx = 0
        s = 128
        t = 224
        u = (32 * mem[96]) + 224
        while idx < 1:
            mem[t] = u - 224
            _63 = mem[s]
            _66 = mem[mem[s]]
            mem[u] = mem[mem[s]]
            v = 0
            while v < _66:
                mem[v + u + 32] = mem[v + _63 + 32]
                v = v + 32
                continue 
            if ceil32(_66) > _66:
                mem[_66 + u + 32] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_66) + u + 32
            continue 
    else:
        if arg2 < arg1:
            revert with 0, 17
        if 1 > !(arg2 - arg1):
            revert with 0, 17
        if arg2 + -arg1 + 1 > test266151307():
            revert with 0, 65
        mem[96] = arg2 + -arg1 + 1
        mem[64] = (32 * arg2 + -arg1 + 1) + 128
        if not arg2 + -arg1 + 1:
            idx = arg1
            while idx <= arg2:
                mem[0] = idx
                mem[32] = 13
                if bool(stor13[idx].field_0):
                    if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _70 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[idx].field_0)) * 0.5) + 32
                    mem[_70] = uint255(uint256(stor13[idx].field_0)) * 0.5
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_70 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_70 + 32] = uint256(stor13[idx].field_0)
                                s = _70 + 32
                                t = sha3(sha3(idx, 13))
                                while _70 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_70 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_70 + 32] = uint256(stor13[idx].field_0)
                                s = _70 + 32
                                t = sha3(sha3(idx, 13))
                                while _70 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _70
                else:
                    if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _75 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[idx].field_1 % 128) + 32
                    mem[_75] = stor13[idx].field_1 % 128
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_75 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_75 + 32] = uint256(stor13[idx].field_0)
                                s = _75 + 32
                                t = sha3(sha3(idx, 13))
                                while _75 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_75 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_75 + 32] = uint256(stor13[idx].field_0)
                                s = _75 + 32
                                t = sha3(sha3(idx, 13))
                                while _75 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _75
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _64 = mem[64]
            mem[mem[64]] = 32
            _67 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 64
            u = mem[64] + (32 * mem[96]) + 64
            while idx < _67:
                mem[t] = u + -_64 - 64
                _116 = mem[s]
                _120 = mem[mem[s]]
                mem[u] = mem[mem[s]]
                v = 0
                while v < _120:
                    mem[v + u + 32] = mem[v + _116 + 32]
                    v = v + 32
                    continue 
                if ceil32(_120) > _120:
                    mem[_120 + u + 32] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_120) + u + 32
                continue 
        else:
            mem[128] = 96
            s = 128
            idx = arg2 + -arg1 + 1
            while idx - 1:
                mem[s + 32] = 96
                s = s + 32
                idx = idx - 1
                continue 
            idx = arg1
            while idx <= arg2:
                mem[0] = idx
                mem[32] = 13
                if bool(stor13[idx].field_0):
                    if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _129 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[idx].field_0)) * 0.5) + 32
                    mem[_129] = uint255(uint256(stor13[idx].field_0)) * 0.5
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_129 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_129 + 32] = uint256(stor13[idx].field_0)
                                s = _129 + 32
                                t = sha3(sha3(idx, 13))
                                while _129 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_129 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_129 + 32] = uint256(stor13[idx].field_0)
                                s = _129 + 32
                                t = sha3(sha3(idx, 13))
                                while _129 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _129
                else:
                    if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _132 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[idx].field_1 % 128) + 32
                    mem[_132] = stor13[idx].field_1 % 128
                    if bool(stor13[idx].field_0):
                        if bool(stor13[idx].field_0) == uint255(uint256(stor13[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[idx].field_0)):
                            if 31 >= uint255(uint256(stor13[idx].field_0)) * 0.5:
                                mem[_132 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_132 + 32] = uint256(stor13[idx].field_0)
                                s = _132 + 32
                                t = sha3(sha3(idx, 13))
                                while _132 + (uint255(uint256(stor13[idx].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[idx].field_0) == stor13[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[idx].field_1 % 128:
                            if 31 >= stor13[idx].field_1 % 128:
                                mem[_132 + 32] = 256 * Mask(248, 0, stor13[idx].field_8)
                            else:
                                mem[0] = sha3(idx, 13)
                                mem[_132 + 32] = uint256(stor13[idx].field_0)
                                s = _132 + 32
                                t = sha3(sha3(idx, 13))
                                while _132 + stor13[idx].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    if idx < arg1:
                        revert with 0, 17
                    if idx - arg1 >= mem[96]:
                        revert with 0, 50
                    mem[(32 * idx - arg1) + 128] = _132
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _121 = mem[64]
            mem[mem[64]] = 32
            _122 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 64
            u = mem[64] + (32 * mem[96]) + 64
            while idx < _122:
                mem[t] = u + -_121 - 64
                _151 = mem[s]
                _153 = mem[mem[s]]
                mem[u] = mem[mem[s]]
                v = 0
                while v < _153:
                    mem[v + u + 32] = mem[v + _151 + 32]
                    v = v + 32
                    continue 
                if ceil32(_153) > _153:
                    mem[_153 + u + 32] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_153) + u + 32
                continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function updateName(uint256 arg1, string arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    mem[ceil32(ceil32(arg2.length)) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(ceil32(arg2.length)) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    mem[ceil32(ceil32(arg2.length)) + ceil32(return_data.size) + 101] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x6352211e with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(ceil32(arg2.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'Not owner'
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 97] = 96
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 129] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 161] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 193] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 225] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 257] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 289] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 321] = 0
    mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 353] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 705
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 673 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 705
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + stor13[arg1].field_1 % 128 + 673 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        uint8(stor13[arg1].field_1792) = uint8(stor13[arg1].field_1792)
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = uint8(stor13[arg1].field_1800)
    else:
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 389] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0x36dac2cc with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
        require return_data.size - mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 >= 288
        if not bool(ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673 <= test266151307()):
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673
        _25 = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] <= test266151307()
        require ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 416 < ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + return_data.size + 385
        _30 = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385]
        if mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 289 < 288 or ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 674 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385])) + 674
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 673] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 385] + 385]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + _25 + _30 + 32 <= return_data.size
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 705 len ceil32(_30)] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + _25 + 417 len ceil32(_30)]
        if ceil32(_30) > _30:
            mem[_30 + ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 705] = 0
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 417]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 449]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 481] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 481]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 513] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 513]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 545] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 545]
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 577] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 577]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 609] < 6
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 609]
        require mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 641] < 6
        mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 641] = mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg2.length)) + (2 * ceil32(return_data.size)) + 385 len 4], Mask(224, 32, arg1) >> 32 + 641]
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if arg2.length:
                uint256(stor13[arg1][].field_0) = Array(len=arg2.length, data=arg2[all])
            else:
                uint256(stor13[arg1].field_0) = 0
                idx = 0
                while stor13[arg1].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor13[arg1][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        uint256(stor13[arg1].field_256) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 417]
        uint256(stor13[arg1].field_512) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 449]
        uint256(stor13[arg1].field_768) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 481]
        uint256(stor13[arg1].field_1024) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 513]
        uint256(stor13[arg1].field_1280) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 545]
        uint256(stor13[arg1].field_1536) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 577]
        if mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609] > 5:
            revert with 0, 33
        uint256(stor13[arg1].field_1792) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 609]
        if mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 641] > 5:
            revert with 0, 33
        Mask(248, 0, stor13[arg1].field_1800) = mem[ceil32(ceil32(arg2.length)) + (4 * ceil32(return_data.size)) + 642 len 31]
}

function getPendingReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[100] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    mem[ceil32(return_data.size) + 96] = 96
    mem[ceil32(return_data.size) + 128] = 0
    mem[ceil32(return_data.size) + 160] = 0
    mem[ceil32(return_data.size) + 192] = 0
    mem[ceil32(return_data.size) + 224] = 0
    mem[ceil32(return_data.size) + 256] = 0
    mem[ceil32(return_data.size) + 288] = 0
    mem[ceil32(return_data.size) + 320] = 0
    mem[ceil32(return_data.size) + 352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = ceil32(return_data.size) + 704
                    s = 0
                    while ceil32(return_data.size) + (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = ceil32(return_data.size) + 704
                    s = 0
                    while ceil32(return_data.size) + stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 4:
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600))
        if uint8(stor13[arg1].field_1800) != 5:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600))
        if sub_ded2abc3[arg1]:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
            if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if block.timestamp < uint256(stor13[arg1].field_768):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) == 5:
            if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                revert with 0, 17
            if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600))
        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
            revert with 0, 17
        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
            revert with 0, 17
        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
        else:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if uint8(stor13[arg1].field_1800) != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint256(stor13[arg1].field_768) > !stor3.length:
            revert with 0, 17
        return (uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600))
    mem[ceil32(return_data.size) + 384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _15 = mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32
    require mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool((2 * ceil32(return_data.size)) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + 672
    _18 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < ceil32(return_data.size) + return_data.size + 384
    _23 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[(2 * ceil32(return_data.size)) + 672] = _23
    require mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + _18 + _23 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 704 len ceil32(_23)] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 384 len 4], Mask(224, 32, arg1) >> 32 + _18 + 416 len ceil32(_23)]
    if ceil32(_23) <= _23:
        mem[(2 * ceil32(return_data.size)) + 384] = (2 * ceil32(return_data.size)) + 672
        mem[(2 * ceil32(return_data.size)) + 416] = mem[ceil32(return_data.size) + _15 + 416]
        mem[(2 * ceil32(return_data.size)) + 448] = mem[ceil32(return_data.size) + _15 + 448]
        mem[(2 * ceil32(return_data.size)) + 480] = mem[ceil32(return_data.size) + _15 + 480]
        mem[(2 * ceil32(return_data.size)) + 512] = mem[ceil32(return_data.size) + _15 + 512]
        mem[(2 * ceil32(return_data.size)) + 544] = mem[ceil32(return_data.size) + _15 + 544]
        mem[(2 * ceil32(return_data.size)) + 576] = mem[ceil32(return_data.size) + _15 + 576]
        require mem[ceil32(return_data.size) + _15 + 608] < 6
        mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + _15 + 608]
        require mem[ceil32(return_data.size) + _15 + 640] < 6
        mem[(2 * ceil32(return_data.size)) + 640] = mem[ceil32(return_data.size) + _15 + 640]
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 4:
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3129 = mem[(2 * ceil32(return_data.size)) + 544]
                _3137 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor5.length:
                    revert with 0, 17
                _3259 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3599 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600) and mem[_3599] > -1 / _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3667 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600) and mem[_3667] > -1 / _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3668 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600) and mem[_3668] > -1 / _3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3259 + ((block.timestamp * _3129 * stor5.length) - (_3137 * _3129 * stor5.length) / 10000 / 24 * 3600))
            _3130 = mem[(2 * ceil32(return_data.size)) + 448]
            _3138 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor5.length:
                revert with 0, 17
            _3260 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3604 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600) and mem[_3604] > -1 / _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3670 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600) and mem[_3670] > -1 / _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3671 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600) and mem[_3671] > -1 / _3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3260 + ((block.timestamp * _3130 * stor5.length) - (_3138 * _3130 * stor5.length) / 10000 / 24 * 3600))
        if mem[(2 * ceil32(return_data.size)) + 640] != 5:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3155 = mem[(2 * ceil32(return_data.size)) + 544]
                _3169 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor4.length:
                    revert with 0, 17
                _3327 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3677 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600) and mem[_3677] > -1 / _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3753 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600) and mem[_3753] > -1 / _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3754 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600) and mem[_3754] > -1 / _3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3327 + ((block.timestamp * _3155 * stor4.length) - (_3169 * _3155 * stor4.length) / 10000 / 24 * 3600))
            _3156 = mem[(2 * ceil32(return_data.size)) + 448]
            _3170 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor4.length:
                revert with 0, 17
            _3328 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3682 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600) and mem[_3682] > -1 / _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3756 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600) and mem[_3756] > -1 / _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3757 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600) and mem[_3757] > -1 / _3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3328 + ((block.timestamp * _3156 * stor4.length) - (_3170 * _3156 * stor4.length) / 10000 / 24 * 3600))
        mem[0] = arg1
        mem[32] = 12
        if sub_ded2abc3[arg1]:
            mem[0] = arg1
            mem[32] = 12
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                _3175 = mem[(2 * ceil32(return_data.size)) + 544]
                _3181 = mem[(2 * ceil32(return_data.size)) + 480]
                if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                    revert with 0, 17
                _3463 = mem[(2 * ceil32(return_data.size)) + 512]
                if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3791 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3791] > -1 / _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3847 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3847] > -1 / _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                            revert with 0, 17
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3848 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3848] > -1 / _3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                            revert with 0, 17
                if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                    revert with 0, 17
                return (_3463 + ((block.timestamp * _3175 * sub_ded2abc3[arg1]) - (_3181 * _3175 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
            _3176 = mem[(2 * ceil32(return_data.size)) + 448]
            _3182 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3464 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3796 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3796] > -1 / _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3850 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3850] > -1 / _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3851 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3851] > -1 / _3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3464 + ((block.timestamp * _3176 * sub_ded2abc3[arg1]) - (_3182 * _3176 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        mem[mem[64] + 4] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3168 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3177 = mem[_3168]
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3211 = mem[(2 * ceil32(return_data.size)) + 544]
            _3231 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and mem[_3168] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]:
                revert with 0, 17
            _3623 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3168]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3975 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600) and mem[_3975] > -1 / _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4029 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600) and mem[_4029] > -1 / _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4030 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600) and mem[_4030] > -1 / _3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3623 + ((block.timestamp * _3211 * _3177) - (_3231 * _3211 * _3177) / 10000 / 24 * 3600))
        _3212 = mem[(2 * ceil32(return_data.size)) + 448]
        _3232 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and mem[_3168] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]:
            revert with 0, 17
        _3624 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3168]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3980 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600) and mem[_3980] > -1 / _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4032 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600) and mem[_4032] > -1 / _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4033 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600) and mem[_4033] > -1 / _3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3624 + ((block.timestamp * _3212 * _3177) - (_3232 * _3212 * _3177) / 10000 / 24 * 3600))
    mem[_23 + (2 * ceil32(return_data.size)) + 704] = 0
    mem[(2 * ceil32(return_data.size)) + 384] = (2 * ceil32(return_data.size)) + 672
    mem[(2 * ceil32(return_data.size)) + 416] = mem[ceil32(return_data.size) + _15 + 416]
    mem[(2 * ceil32(return_data.size)) + 448] = mem[ceil32(return_data.size) + _15 + 448]
    mem[(2 * ceil32(return_data.size)) + 480] = mem[ceil32(return_data.size) + _15 + 480]
    mem[(2 * ceil32(return_data.size)) + 512] = mem[ceil32(return_data.size) + _15 + 512]
    mem[(2 * ceil32(return_data.size)) + 544] = mem[ceil32(return_data.size) + _15 + 544]
    mem[(2 * ceil32(return_data.size)) + 576] = mem[ceil32(return_data.size) + _15 + 576]
    require mem[ceil32(return_data.size) + _15 + 608] < 6
    mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + _15 + 608]
    require mem[ceil32(return_data.size) + _15 + 640] < 6
    mem[(2 * ceil32(return_data.size)) + 640] = mem[ceil32(return_data.size) + _15 + 640]
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 4:
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3133 = mem[(2 * ceil32(return_data.size)) + 544]
            _3142 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor5.length:
                revert with 0, 17
            _3261 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3613 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600) and mem[_3613] > -1 / _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3683 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600) and mem[_3683] > -1 / _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3684 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600) and mem[_3684] > -1 / _3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3261 + ((block.timestamp * _3133 * stor5.length) - (_3142 * _3133 * stor5.length) / 10000 / 24 * 3600))
        _3134 = mem[(2 * ceil32(return_data.size)) + 448]
        _3143 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and stor5.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * stor5.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor5.length:
            revert with 0, 17
        _3262 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3618 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600) and mem[_3618] > -1 / _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3686 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600) and mem[_3686] > -1 / _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3687 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600) and mem[_3687] > -1 / _3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3262 + ((block.timestamp * _3134 * stor5.length) - (_3143 * _3134 * stor5.length) / 10000 / 24 * 3600))
    if mem[(2 * ceil32(return_data.size)) + 640] != 5:
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3157 = mem[(2 * ceil32(return_data.size)) + 544]
            _3173 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * stor4.length:
                revert with 0, 17
            _3329 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3693 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600) and mem[_3693] > -1 / _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3765 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600) and mem[_3765] > -1 / _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3766 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600) and mem[_3766] > -1 / _3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3329 + ((block.timestamp * _3157 * stor4.length) - (_3173 * _3157 * stor4.length) / 10000 / 24 * 3600))
        _3158 = mem[(2 * ceil32(return_data.size)) + 448]
        _3174 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and stor4.length > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * stor4.length and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * stor4.length:
            revert with 0, 17
        _3330 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3698 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600) and mem[_3698] > -1 / _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3768 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600) and mem[_3768] > -1 / _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3769 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600) and mem[_3769] > -1 / _3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3330 + ((block.timestamp * _3158 * stor4.length) - (_3174 * _3158 * stor4.length) / 10000 / 24 * 3600))
    mem[0] = arg1
    mem[32] = 12
    if sub_ded2abc3[arg1]:
        mem[0] = arg1
        mem[32] = 12
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            _3178 = mem[(2 * ceil32(return_data.size)) + 544]
            _3183 = mem[(2 * ceil32(return_data.size)) + 480]
            if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3467 = mem[(2 * ceil32(return_data.size)) + 512]
            if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            if mem[(2 * ceil32(return_data.size)) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3801 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3801] > -1 / _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3853 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3853] > -1 / _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3854 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3854] > -1 / _3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
                revert with 0, 17
            return (_3467 + ((block.timestamp * _3178 * sub_ded2abc3[arg1]) - (_3183 * _3178 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
        _3179 = mem[(2 * ceil32(return_data.size)) + 448]
        _3184 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] and sub_ded2abc3[arg1] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]:
            revert with 0, 17
        _3468 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3806 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3806] > -1 / _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3856 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3856] > -1 / _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3857 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3857] > -1 / _3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3468 + ((block.timestamp * _3179 * sub_ded2abc3[arg1]) - (_3184 * _3179 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600))
    mem[mem[64] + 4] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0xded2abc3 with:
            gas gas_remaining wei
           args arg1
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3172 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3180 = mem[_3172]
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 5:
        _3213 = mem[(2 * ceil32(return_data.size)) + 544]
        _3233 = mem[(2 * ceil32(return_data.size)) + 480]
        if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 544] and mem[_3172] > -1 / mem[(2 * ceil32(return_data.size)) + 544]:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 544] * mem[_3172] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 544] * mem[_3172]:
            revert with 0, 17
        _3625 = mem[(2 * ceil32(return_data.size)) + 512]
        if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3172]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 544] * mem[_3172]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        if mem[(2 * ceil32(return_data.size)) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3985 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600) and mem[_3985] > -1 / _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            if mem[(2 * ceil32(return_data.size)) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[(2 * ceil32(return_data.size)) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4037 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600) and mem[_4037] > -1 / _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600):
                    revert with 0, 17
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4038 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600) and mem[_4038] > -1 / _3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600):
                    revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
            revert with 0, 17
        return (_3625 + ((block.timestamp * _3213 * _3180) - (_3233 * _3213 * _3180) / 10000 / 24 * 3600))
    _3214 = mem[(2 * ceil32(return_data.size)) + 448]
    _3234 = mem[(2 * ceil32(return_data.size)) + 480]
    if block.timestamp < mem[(2 * ceil32(return_data.size)) + 480]:
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 448] and mem[_3172] > -1 / mem[(2 * ceil32(return_data.size)) + 448]:
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 448] * mem[_3172] and block.timestamp - mem[(2 * ceil32(return_data.size)) + 480] > -1 / mem[(2 * ceil32(return_data.size)) + 448] * mem[_3172]:
        revert with 0, 17
    _3626 = mem[(2 * ceil32(return_data.size)) + 512]
    if mem[(2 * ceil32(return_data.size)) + 512] > !((block.timestamp * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3172]) - (mem[(2 * ceil32(return_data.size)) + 480] * mem[(2 * ceil32(return_data.size)) + 448] * mem[_3172]) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 640] > 5:
        revert with 0, 33
    if mem[(2 * ceil32(return_data.size)) + 640] == 5:
        require ext_code.size(stor8)
        staticcall stor8.0xe5d76232 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3990 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600) and mem[_3990] > -1 / _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600):
            revert with 0, 17
    else:
        if mem[(2 * ceil32(return_data.size)) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[(2 * ceil32(return_data.size)) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4040 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600) and mem[_4040] > -1 / _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600):
                revert with 0, 17
        else:
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4041 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600) and mem[_4041] > -1 / _3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600):
                revert with 0, 17
    if mem[(2 * ceil32(return_data.size)) + 480] > !stor3.length:
        revert with 0, 17
    return (_3626 + ((block.timestamp * _3214 * _3180) - (_3234 * _3214 * _3180) / 10000 / 24 * 3600))
}

function sub_d34db045(?) payable {
    require calldata.size - 4 >= 32
    mem[96] = 96
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[0] = arg1
    mem[32] = 13
    if uint256(stor13[arg1].field_512):
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor13[arg1].field_0):
            if bool(stor13[arg1].field_0) == uint255(uint256(stor13[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor13[arg1].field_0)):
                if 31 < uint255(uint256(stor13[arg1].field_0)) * 0.5:
                    idx = 704
                    s = 0
                    while (uint255(uint256(stor13[arg1].field_0)) * 0.5) + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor13[arg1].field_0) == stor13[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor13[arg1].field_1 % 128:
                if 31 < stor13[arg1].field_1 % 128:
                    idx = 704
                    s = 0
                    while stor13[arg1].field_1 % 128 + 672 > idx:
                        mem[idx + 32] = uint256(stor13[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        if uint8(stor13[arg1].field_1792) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 4:
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor5.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor5.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor5.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
            if uint256(stor13[arg1].field_512) and stor5.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor5.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor5.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor5.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor5.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
        if uint8(stor13[arg1].field_1800) != 5:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and stor4.length > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * stor4.length:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * stor4.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
            if uint256(stor13[arg1].field_512) and stor4.length > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * stor4.length and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * stor4.length:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * stor4.length) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * stor4.length) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
        if sub_ded2abc3[arg1]:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if block.timestamp < uint256(stor13[arg1].field_768):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) == 5:
                if uint256(stor13[arg1].field_1280) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_1280):
                    revert with 0, 17
                if uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]:
                    revert with 0, 17
                if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[arg1].field_1800) == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                else:
                    if uint8(stor13[arg1].field_1800) > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if uint8(stor13[arg1].field_1800) != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if uint256(stor13[arg1].field_768) > !stor3.length:
                    revert with 0, 17
                return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                       uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
            if uint256(stor13[arg1].field_512) and sub_ded2abc3[arg1] > -1 / uint256(stor13[arg1].field_512):
                revert with 0, 17
            if uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if block.timestamp < uint256(stor13[arg1].field_768):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) == 5:
            if uint256(stor13[arg1].field_1280) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1280):
                revert with 0, 17
            if uint256(stor13[arg1].field_1280) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_1280) * ext_call.return_data[0]:
                revert with 0, 17
            if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            if uint8(stor13[arg1].field_1800) == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
            else:
                if uint8(stor13[arg1].field_1800) > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if uint8(stor13[arg1].field_1800) != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600):
                revert with 0, 17
            if uint256(stor13[arg1].field_768) > !stor3.length:
                revert with 0, 17
            return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600), 
                   (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_1280) * ext_call.return_data[0]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
                   uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
        if uint256(stor13[arg1].field_512) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_512):
            revert with 0, 17
        if uint256(stor13[arg1].field_512) * ext_call.return_data[0] and block.timestamp - uint256(stor13[arg1].field_768) > -1 / uint256(stor13[arg1].field_512) * ext_call.return_data[0]:
            revert with 0, 17
        if uint256(stor13[arg1].field_1024) > !((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint8(stor13[arg1].field_1800) > 5:
            revert with 0, 33
        if uint8(stor13[arg1].field_1800) == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
        else:
            if uint8(stor13[arg1].field_1800) > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if uint8(stor13[arg1].field_1800) != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
            else:
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600) and ext_call.return_data[0] > -1 / uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600):
            revert with 0, 17
        if uint256(stor13[arg1].field_768) > !stor3.length:
            revert with 0, 17
        return uint256(stor13[arg1].field_1024) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600), 
               (uint256(stor13[arg1].field_1024) * ext_call.return_data[0]) + ((block.timestamp * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) - (uint256(stor13[arg1].field_768) * uint256(stor13[arg1].field_512) * ext_call.return_data[0]) / 10000 / 24 * 3600 * ext_call.return_data[0]) / 10000,
               uint256(stor13[arg1].field_768) + stor3.length <= block.timestamp
    mem[384] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
    mem[388] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0x36dac2cc with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[384 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _9 = mem[384 len 4], Mask(224, 32, arg1) >> 32
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require return_data.size - mem[384 len 4], Mask(224, 32, arg1) >> 32 >= 288
    if not bool(ceil32(return_data.size) + 672 <= test266151307()):
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + 672
    _12 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384]
    require mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] <= test266151307()
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 415 < return_data.size + 384
    _17 = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384]
    if mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 289 < 288 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + 384] + 384])) + 673
    mem[ceil32(return_data.size) + 672] = _17
    require mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + _17 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 704 len ceil32(_17)] = mem[mem[384 len 4], Mask(224, 32, arg1) >> 32 + _12 + 416 len ceil32(_17)]
    if ceil32(_17) <= _17:
        mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
        mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
        mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
        mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
        mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
        mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
        mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
        require mem[_9 + 608] < 6
        mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
        require mem[_9 + 640] < 6
        mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 4:
            if mem[ceil32(return_data.size) + 640] == 5:
                _3123 = mem[ceil32(return_data.size) + 544]
                _3131 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and stor5.length > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor5.length:
                    revert with 0, 17
                _3253 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3593 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600) and mem[_3593] > -1 / _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600), 
                           (_3253 * mem[_3593]) + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600 * mem[_3593]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3661 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600) and mem[_3661] > -1 / _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600), 
                           (_3253 * mem[_3661]) + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600 * mem[_3661]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3662 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600) and mem[_3662] > -1 / _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3253 + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600), 
                       (_3253 * mem[_3662]) + ((block.timestamp * _3123 * stor5.length) - (_3131 * _3123 * stor5.length) / 10000 / 24 * 3600 * mem[_3662]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            _3124 = mem[ceil32(return_data.size) + 448]
            _3132 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and stor5.length > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor5.length:
                revert with 0, 17
            _3254 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3598 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600) and mem[_3598] > -1 / _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600), 
                       (_3254 * mem[_3598]) + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600 * mem[_3598]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3664 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600) and mem[_3664] > -1 / _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600), 
                       (_3254 * mem[_3664]) + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600 * mem[_3664]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3665 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600) and mem[_3665] > -1 / _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3254 + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600), 
                   (_3254 * mem[_3665]) + ((block.timestamp * _3124 * stor5.length) - (_3132 * _3124 * stor5.length) / 10000 / 24 * 3600 * mem[_3665]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] != 5:
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                _3149 = mem[ceil32(return_data.size) + 544]
                _3163 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and stor4.length > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor4.length:
                    revert with 0, 17
                _3321 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3671 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600) and mem[_3671] > -1 / _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600), 
                           (_3321 * mem[_3671]) + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600 * mem[_3671]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3747 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600) and mem[_3747] > -1 / _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600), 
                           (_3321 * mem[_3747]) + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600 * mem[_3747]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3748 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600) and mem[_3748] > -1 / _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3321 + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600), 
                       (_3321 * mem[_3748]) + ((block.timestamp * _3149 * stor4.length) - (_3163 * _3149 * stor4.length) / 10000 / 24 * 3600 * mem[_3748]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            _3150 = mem[ceil32(return_data.size) + 448]
            _3164 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and stor4.length > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor4.length:
                revert with 0, 17
            _3322 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3676 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600) and mem[_3676] > -1 / _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600), 
                       (_3322 * mem[_3676]) + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600 * mem[_3676]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3750 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600) and mem[_3750] > -1 / _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600), 
                       (_3322 * mem[_3750]) + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600 * mem[_3750]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3751 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600) and mem[_3751] > -1 / _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3322 + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600), 
                   (_3322 * mem[_3751]) + ((block.timestamp * _3150 * stor4.length) - (_3164 * _3150 * stor4.length) / 10000 / 24 * 3600 * mem[_3751]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        mem[0] = arg1
        mem[32] = 12
        if sub_ded2abc3[arg1]:
            mem[0] = arg1
            mem[32] = 12
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                _3169 = mem[ceil32(return_data.size) + 544]
                _3175 = mem[ceil32(return_data.size) + 480]
                if block.timestamp < mem[ceil32(return_data.size) + 480]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 544]:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]:
                    revert with 0, 17
                _3457 = mem[ceil32(return_data.size) + 512]
                if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                if mem[ceil32(return_data.size) + 640] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3785] > -1 / _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                           (_3457 * mem[_3785]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3785]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                if mem[ceil32(return_data.size) + 640] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[ceil32(return_data.size) + 640] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3849 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3849] > -1 / _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[ceil32(return_data.size) + 480] > !stor3.length:
                        revert with 0, 17
                    return _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                           (_3457 * mem[_3849]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3849]) / 10000,
                           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3850 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3850] > -1 / _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3457 + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3457 * mem[_3850]) + ((block.timestamp * _3169 * sub_ded2abc3[arg1]) - (_3175 * _3169 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3850]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            _3170 = mem[ceil32(return_data.size) + 448]
            _3176 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 448]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3458 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3790 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3790] > -1 / _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3458 * mem[_3790]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3790]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3852 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3852] > -1 / _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3458 * mem[_3852]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3852]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3853 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3853] > -1 / _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3458 + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3458 * mem[_3853]) + ((block.timestamp * _3170 * sub_ded2abc3[arg1]) - (_3176 * _3170 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3853]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        mem[mem[64] + 4] = arg1
        require ext_code.size(stor8)
        staticcall stor8.0xded2abc3 with:
                gas gas_remaining wei
               args arg1
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3162 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3171 = mem[_3162]
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3205 = mem[ceil32(return_data.size) + 544]
            _3225 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and mem[_3162] > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * mem[_3162] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * mem[_3162]:
                revert with 0, 17
            _3617 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * mem[_3162]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * mem[_3162]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3985 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600) and mem[_3985] > -1 / _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600), 
                       (_3617 * mem[_3985]) + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600 * mem[_3985]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4039 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600) and mem[_4039] > -1 / _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600), 
                       (_3617 * mem[_4039]) + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600 * mem[_4039]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4040 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600) and mem[_4040] > -1 / _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3617 + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600), 
                   (_3617 * mem[_4040]) + ((block.timestamp * _3205 * _3171) - (_3225 * _3205 * _3171) / 10000 / 24 * 3600 * mem[_4040]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        _3206 = mem[ceil32(return_data.size) + 448]
        _3226 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and mem[_3162] > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * mem[_3162] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * mem[_3162]:
            revert with 0, 17
        _3618 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * mem[_3162]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * mem[_3162]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3990 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600) and mem[_3990] > -1 / _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600), 
                   (_3618 * mem[_3990]) + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600 * mem[_3990]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4042 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600) and mem[_4042] > -1 / _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600), 
                   (_3618 * mem[_4042]) + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600 * mem[_4042]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4043 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600) and mem[_4043] > -1 / _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3618 + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600), 
               (_3618 * mem[_4043]) + ((block.timestamp * _3206 * _3171) - (_3226 * _3206 * _3171) / 10000 / 24 * 3600 * mem[_4043]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    mem[_17 + ceil32(return_data.size) + 704] = 0
    mem[ceil32(return_data.size) + 384] = ceil32(return_data.size) + 672
    mem[ceil32(return_data.size) + 416] = mem[_9 + 416]
    mem[ceil32(return_data.size) + 448] = mem[_9 + 448]
    mem[ceil32(return_data.size) + 480] = mem[_9 + 480]
    mem[ceil32(return_data.size) + 512] = mem[_9 + 512]
    mem[ceil32(return_data.size) + 544] = mem[_9 + 544]
    mem[ceil32(return_data.size) + 576] = mem[_9 + 576]
    require mem[_9 + 608] < 6
    mem[ceil32(return_data.size) + 608] = mem[_9 + 608]
    require mem[_9 + 640] < 6
    mem[ceil32(return_data.size) + 640] = mem[_9 + 640]
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 4:
        if mem[ceil32(return_data.size) + 640] == 5:
            _3127 = mem[ceil32(return_data.size) + 544]
            _3136 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and stor5.length > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor5.length:
                revert with 0, 17
            _3255 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3607 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600) and mem[_3607] > -1 / _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600), 
                       (_3255 * mem[_3607]) + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600 * mem[_3607]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3677 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600) and mem[_3677] > -1 / _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600), 
                       (_3255 * mem[_3677]) + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600 * mem[_3677]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3678 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600) and mem[_3678] > -1 / _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3255 + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600), 
                   (_3255 * mem[_3678]) + ((block.timestamp * _3127 * stor5.length) - (_3136 * _3127 * stor5.length) / 10000 / 24 * 3600 * mem[_3678]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        _3128 = mem[ceil32(return_data.size) + 448]
        _3137 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and stor5.length > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * stor5.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor5.length:
            revert with 0, 17
        _3256 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor5.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3612 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600) and mem[_3612] > -1 / _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600), 
                   (_3256 * mem[_3612]) + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600 * mem[_3612]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3680 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600) and mem[_3680] > -1 / _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600), 
                   (_3256 * mem[_3680]) + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600 * mem[_3680]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3681 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600) and mem[_3681] > -1 / _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3256 + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600), 
               (_3256 * mem[_3681]) + ((block.timestamp * _3128 * stor5.length) - (_3137 * _3128 * stor5.length) / 10000 / 24 * 3600 * mem[_3681]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    if mem[ceil32(return_data.size) + 640] != 5:
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3151 = mem[ceil32(return_data.size) + 544]
            _3167 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and stor4.length > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * stor4.length:
                revert with 0, 17
            _3323 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3687 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600) and mem[_3687] > -1 / _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600), 
                       (_3323 * mem[_3687]) + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600 * mem[_3687]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3759 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600) and mem[_3759] > -1 / _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600), 
                       (_3323 * mem[_3759]) + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600 * mem[_3759]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3760 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600) and mem[_3760] > -1 / _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3323 + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600), 
                   (_3323 * mem[_3760]) + ((block.timestamp * _3151 * stor4.length) - (_3167 * _3151 * stor4.length) / 10000 / 24 * 3600 * mem[_3760]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        _3152 = mem[ceil32(return_data.size) + 448]
        _3168 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and stor4.length > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * stor4.length and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * stor4.length:
            revert with 0, 17
        _3324 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * stor4.length) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3692 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600) and mem[_3692] > -1 / _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600), 
                   (_3324 * mem[_3692]) + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600 * mem[_3692]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3762 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600) and mem[_3762] > -1 / _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600), 
                   (_3324 * mem[_3762]) + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600 * mem[_3762]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3763 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600) and mem[_3763] > -1 / _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3324 + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600), 
               (_3324 * mem[_3763]) + ((block.timestamp * _3152 * stor4.length) - (_3168 * _3152 * stor4.length) / 10000 / 24 * 3600 * mem[_3763]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    mem[0] = arg1
    mem[32] = 12
    if sub_ded2abc3[arg1]:
        mem[0] = arg1
        mem[32] = 12
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            _3172 = mem[ceil32(return_data.size) + 544]
            _3177 = mem[ceil32(return_data.size) + 480]
            if block.timestamp < mem[ceil32(return_data.size) + 480]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 544]:
                revert with 0, 17
            if mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]:
                revert with 0, 17
            _3461 = mem[ceil32(return_data.size) + 512]
            if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            if mem[ceil32(return_data.size) + 640] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3795 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3795] > -1 / _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3461 * mem[_3795]) + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3795]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            if mem[ceil32(return_data.size) + 640] > 5:
                revert with 0, 33
            require ext_code.size(stor8)
            if mem[ceil32(return_data.size) + 640] != 4:
                staticcall stor8.0xae55ae5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3855 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3855] > -1 / _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 480] > !stor3.length:
                    revert with 0, 17
                return _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                       (_3461 * mem[_3855]) + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3855]) / 10000,
                       mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
            staticcall stor8.0x1ec4a4a8 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3856 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3856] > -1 / _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3461 + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3461 * mem[_3856]) + ((block.timestamp * _3172 * sub_ded2abc3[arg1]) - (_3177 * _3172 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3856]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        _3173 = mem[ceil32(return_data.size) + 448]
        _3178 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] and sub_ded2abc3[arg1] > -1 / mem[ceil32(return_data.size) + 448]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]:
            revert with 0, 17
        _3462 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3800 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3800] > -1 / _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3462 * mem[_3800]) + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3800]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3858 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3858] > -1 / _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
                   (_3462 * mem[_3858]) + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3858]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3859 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600) and mem[_3859] > -1 / _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3462 + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600), 
               (_3462 * mem[_3859]) + ((block.timestamp * _3173 * sub_ded2abc3[arg1]) - (_3178 * _3173 * sub_ded2abc3[arg1]) / 10000 / 24 * 3600 * mem[_3859]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    mem[mem[64] + 4] = arg1
    require ext_code.size(stor8)
    staticcall stor8.0xded2abc3 with:
            gas gas_remaining wei
           args arg1
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3166 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3174 = mem[_3166]
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 5:
        _3207 = mem[ceil32(return_data.size) + 544]
        _3227 = mem[ceil32(return_data.size) + 480]
        if block.timestamp < mem[ceil32(return_data.size) + 480]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 544] and mem[_3166] > -1 / mem[ceil32(return_data.size) + 544]:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 544] * mem[_3166] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 544] * mem[_3166]:
            revert with 0, 17
        _3619 = mem[ceil32(return_data.size) + 512]
        if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 544] * mem[_3166]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 544] * mem[_3166]) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        if mem[ceil32(return_data.size) + 640] == 5:
            require ext_code.size(stor8)
            staticcall stor8.0xe5d76232 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3995 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600) and mem[_3995] > -1 / _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600), 
                   (_3619 * mem[_3995]) + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600 * mem[_3995]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        if mem[ceil32(return_data.size) + 640] > 5:
            revert with 0, 33
        require ext_code.size(stor8)
        if mem[ceil32(return_data.size) + 640] != 4:
            staticcall stor8.0xae55ae5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4047 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600) and mem[_4047] > -1 / _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[ceil32(return_data.size) + 480] > !stor3.length:
                revert with 0, 17
            return _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600), 
                   (_3619 * mem[_4047]) + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600 * mem[_4047]) / 10000,
                   mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
        staticcall stor8.0x1ec4a4a8 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4048 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600) and mem[_4048] > -1 / _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3619 + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600), 
               (_3619 * mem[_4048]) + ((block.timestamp * _3207 * _3174) - (_3227 * _3207 * _3174) / 10000 / 24 * 3600 * mem[_4048]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    _3208 = mem[ceil32(return_data.size) + 448]
    _3228 = mem[ceil32(return_data.size) + 480]
    if block.timestamp < mem[ceil32(return_data.size) + 480]:
        revert with 0, 17
    if mem[ceil32(return_data.size) + 448] and mem[_3166] > -1 / mem[ceil32(return_data.size) + 448]:
        revert with 0, 17
    if mem[ceil32(return_data.size) + 448] * mem[_3166] and block.timestamp - mem[ceil32(return_data.size) + 480] > -1 / mem[ceil32(return_data.size) + 448] * mem[_3166]:
        revert with 0, 17
    _3620 = mem[ceil32(return_data.size) + 512]
    if mem[ceil32(return_data.size) + 512] > !((block.timestamp * mem[ceil32(return_data.size) + 448] * mem[_3166]) - (mem[ceil32(return_data.size) + 480] * mem[ceil32(return_data.size) + 448] * mem[_3166]) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    if mem[ceil32(return_data.size) + 640] == 5:
        require ext_code.size(stor8)
        staticcall stor8.0xe5d76232 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4000 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600) and mem[_4000] > -1 / _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600), 
               (_3620 * mem[_4000]) + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600 * mem[_4000]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    if mem[ceil32(return_data.size) + 640] > 5:
        revert with 0, 33
    require ext_code.size(stor8)
    if mem[ceil32(return_data.size) + 640] != 4:
        staticcall stor8.0xae55ae5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4050 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600) and mem[_4050] > -1 / _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600):
            revert with 0, 17
        if mem[ceil32(return_data.size) + 480] > !stor3.length:
            revert with 0, 17
        return _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600), 
               (_3620 * mem[_4050]) + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600 * mem[_4050]) / 10000,
               mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
    staticcall stor8.0x1ec4a4a8 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _4051 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600) and mem[_4051] > -1 / _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600):
        revert with 0, 17
    if mem[ceil32(return_data.size) + 480] > !stor3.length:
        revert with 0, 17
    return _3620 + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600), 
           (_3620 * mem[_4051]) + ((block.timestamp * _3208 * _3174) - (_3228 * _3208 * _3174) / 10000 / 24 * 3600 * mem[_4051]) / 10000,
           mem[ceil32(return_data.size) + 480] + stor3.length <= block.timestamp
}

function sub_162c3e16(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + ('cd', 4).length + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    s = cd[36] + 36
    t = 128
    idx = 0
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    mem[ceil32(32 * ('cd', 36).length) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(32 * ('cd', 36).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    if ('cd', 36).length != 4:
        revert with 0, 'Invalid array'
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 128] = call.data[calldata.size len 128]
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 641
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 353] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 417] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 449] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 481] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 513] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 545] = 0
    mem[var43002] = 0
    mem[var43002 + 32] = 0
    mem[var45002] = var45001
    if not var45003 - 1:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _710 = mem[(32 * uint8(idx)) + 128]
            _712 = mem[64]
            mem[64] = mem[64] + 288
            mem[_712] = 96
            mem[_712 + 32] = 0
            mem[_712 + 64] = 0
            mem[_712 + 96] = 0
            mem[_712 + 128] = 0
            mem[_712 + 160] = 0
            mem[_712 + 192] = 0
            mem[_712 + 224] = 0
            mem[_712 + 256] = 0
            mem[0] = _710
            mem[32] = 13
            if uint256(stor13[_710].field_512):
                mem[0] = _710
                mem[32] = 13
                _722 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_710].field_0):
                    if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _732 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_710].field_0)) * 0.5) + 32
                    mem[_732] = uint255(uint256(stor13[_710].field_0)) * 0.5
                    if bool(stor13[_710].field_0):
                        if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_710].field_0)):
                            if 31 >= uint255(uint256(stor13[_710].field_0)) * 0.5:
                                mem[_732 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_732 + 32] = uint256(stor13[_710].field_0)
                                s = _732 + 32
                                t = sha3(sha3(_710, 13))
                                while _732 + (uint255(uint256(stor13[_710].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_710].field_1 % 128:
                            if 31 >= stor13[_710].field_1 % 128:
                                mem[_732 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_732 + 32] = uint256(stor13[_710].field_0)
                                s = _732 + 32
                                t = sha3(sha3(_710, 13))
                                while _732 + stor13[_710].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_722] = _732
                else:
                    if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                        revert with 0, 34
                    _735 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_710].field_1 % 128) + 32
                    mem[_735] = stor13[_710].field_1 % 128
                    if bool(stor13[_710].field_0):
                        if bool(stor13[_710].field_0) == uint255(uint256(stor13[_710].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_710].field_0)):
                            if 31 >= uint255(uint256(stor13[_710].field_0)) * 0.5:
                                mem[_735 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_735 + 32] = uint256(stor13[_710].field_0)
                                s = _735 + 32
                                t = sha3(sha3(_710, 13))
                                while _735 + (uint255(uint256(stor13[_710].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_710].field_0) == stor13[_710].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_710].field_1 % 128:
                            if 31 >= stor13[_710].field_1 % 128:
                                mem[_735 + 32] = 256 * Mask(248, 0, stor13[_710].field_8)
                            else:
                                mem[0] = sha3(_710, 13)
                                mem[_735 + 32] = uint256(stor13[_710].field_0)
                                s = _735 + 32
                                t = sha3(sha3(_710, 13))
                                while _735 + stor13[_710].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_722] = _735
                mem[_722 + 32] = uint256(stor13[_710].field_256)
                mem[_722 + 64] = uint256(stor13[_710].field_512)
                mem[_722 + 96] = uint256(stor13[_710].field_768)
                mem[_722 + 128] = uint256(stor13[_710].field_1024)
                mem[_722 + 160] = uint256(stor13[_710].field_1280)
                mem[_722 + 192] = uint256(stor13[_710].field_1536)
                if uint8(stor13[_710].field_1792) > 5:
                    revert with 0, 33
                mem[_722 + 224] = uint8(stor13[_710].field_1792)
                if uint8(stor13[_710].field_1800) > 5:
                    revert with 0, 33
                mem[_722 + 256] = uint8(stor13[_710].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _722
                if uint256(stor13[_710].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_710].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_710].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_710].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _710
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _710
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _730 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _733 = mem[_730]
                require mem[_730] <= test266151307()
                require return_data.size - mem[_730] >= 288
                if not bool(_730 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _730 + ceil32(return_data.size) + 288
                _744 = mem[_730 + _733]
                require mem[_730 + _733] <= test266151307()
                require _730 + _733 + mem[_730 + _733] + 31 < _730 + return_data.size
                _754 = mem[_730 + _733 + mem[_730 + _733]]
                if mem[_730 + _733 + mem[_730 + _733]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289 < 288 or _730 + ceil32(return_data.size) + ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _730 + ceil32(return_data.size) + ceil32(ceil32(mem[_730 + _733 + mem[_730 + _733]])) + 289
                mem[_730 + ceil32(return_data.size) + 288] = _754
                require _733 + _744 + _754 + 32 <= return_data.size
                s = 0
                while s < _754:
                    mem[s + _730 + ceil32(return_data.size) + 320] = mem[s + _730 + _733 + _744 + 32]
                    s = s + 32
                    continue 
                if ceil32(_754) > _754:
                    mem[_754 + _730 + ceil32(return_data.size) + 320] = 0
                mem[_730 + ceil32(return_data.size)] = _730 + ceil32(return_data.size) + 288
                mem[_730 + ceil32(return_data.size) + 32] = mem[_730 + _733 + 32]
                mem[_730 + ceil32(return_data.size) + 64] = mem[_730 + _733 + 64]
                mem[_730 + ceil32(return_data.size) + 96] = mem[_730 + _733 + 96]
                mem[_730 + ceil32(return_data.size) + 128] = mem[_730 + _733 + 128]
                mem[_730 + ceil32(return_data.size) + 160] = mem[_730 + _733 + 160]
                mem[_730 + ceil32(return_data.size) + 192] = mem[_730 + _733 + 192]
                require mem[_730 + _733 + 224] < 6
                mem[_730 + ceil32(return_data.size) + 224] = mem[_730 + _733 + 224]
                require mem[_730 + _733 + 256] < 6
                mem[_730 + ceil32(return_data.size) + 256] = mem[_730 + _733 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _730 + ceil32(return_data.size)
                if mem[_730 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_730 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_730 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_730 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _728 = mem[64]
        mem[64] = mem[64] + 128
        mem[_728 len 128] = call.data[calldata.size len 128]
        s = 0
        t = 0
        u = 0
        while uint8(s) < 4:
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            mem[(32 * uint8(s)) + _728] = uint8(mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _1380 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if u > !mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            _1415 = mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            _1431 = mem[(32 * uint8(s)) + 128]
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1444 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1454 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _1580 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1809 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600) and mem[_1809] > -1 / _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1920 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1920
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1920, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1823 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600) and mem[_1823] > -1 / _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1925 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1925
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1925, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1824 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600) and mem[_1824] > -1 / _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1936 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1936
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1936, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _1580 + ((block.timestamp * _1444 * stor5.length) - (_1454 * _1444 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                _1445 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1455 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _1581 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1814 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1814] > -1 / _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1923 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1923
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1923, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1826 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1826] > -1 / _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1929 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1929
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1929, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1827 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600) and mem[_1827] > -1 / _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _1939 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _1939
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _1939, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                    uint256(stor[v].field_0) = 0
                    v = v + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                t = t + _1581 + ((block.timestamp * _1445 * stor5.length) - (_1455 * _1445 * stor5.length) / 10000 / 24 * 3600)
                u = u + _1380
                continue 
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1462 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1475 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _1624 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1833 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600) and mem[_1833] > -1 / _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1942 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1942
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1942, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _1380
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _1380
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1849 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600) and mem[_1849] > -1 / _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1951 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1951
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1951, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                                if uint8(s) == 255:
                                    revert with 0, 17
                                s = uint8(s) + 1
                                t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                                u = u + _1380
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _1380
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1850 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600) and mem[_1850] > -1 / _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1968 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1968
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1968, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1624 + ((block.timestamp * _1462 * stor4.length) - (_1475 * _1462 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                _1463 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1476 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _1625 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1838 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600) and mem[_1838] > -1 / _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1945 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1945
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1945, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1852 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600) and mem[_1852] > -1 / _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1955 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1955
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1955, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _1380
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _1380
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1853 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600) and mem[_1853] > -1 / _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1971 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1971
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1971, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _1625 + ((block.timestamp * _1463 * stor4.length) - (_1476 * _1463 * stor4.length) / 10000 / 24 * 3600)
                u = u + _1380
                continue 
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 12
                _1456 = sha3(mem[(32 * uint8(s)) + 128], 12)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _1485 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _1494 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                        revert with 0, 17
                    _1745 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1859 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1859] > -1 / _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1980 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1980
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1980, msg.sender
                    else:
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1873 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1873] > -1 / _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _1993 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _1993
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _1993, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1874 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1874] > -1 / _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _2008 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _2008
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _2008, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _1745 + ((block.timestamp * _1485 * uint256(stor[_1456].field_0)) - (_1494 * _1485 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)
                    u = u + _1380
                    continue 
                _1486 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _1495 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                    revert with 0, 17
                _1746 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1864 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1864] > -1 / _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _1983 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _1983
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _1983, msg.sender
                else:
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1876 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1876] > -1 / _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _1997 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _1997
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _1997, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1877 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600) and mem[_1877] > -1 / _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _2011 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2011
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2011, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _1746 + ((block.timestamp * _1486 * uint256(stor[_1456].field_0)) - (_1495 * _1486 * uint256(stor[_1456].field_0)) / 10000 / 24 * 3600)
                u = u + _1380
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(s)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _1431
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1474 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1487 = mem[_1474]
            if mem[_1415 + 256] > 5:
                revert with 0, 33
            if mem[_1415 + 256] == 5:
                _1507 = mem[_1415 + 160]
                _1520 = mem[_1415 + 96]
                if block.timestamp < mem[_1415 + 96]:
                    revert with 0, 17
                if mem[_1415 + 160] and mem[_1474] > -1 / mem[_1415 + 160]:
                    revert with 0, 17
                if mem[_1415 + 160] * mem[_1474] and block.timestamp - mem[_1415 + 96] > -1 / mem[_1415 + 160] * mem[_1474]:
                    revert with 0, 17
                _1821 = mem[_1415 + 128]
                if mem[_1415 + 128] > !((block.timestamp * mem[_1415 + 160] * mem[_1474]) - (mem[_1415 + 96] * mem[_1415 + 160] * mem[_1474]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_1415 + 256] > 5:
                    revert with 0, 33
                if mem[_1415 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1901 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600) and mem[_1901] > -1 / _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _2052 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2052
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2052, msg.sender
                else:
                    if mem[_1415 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_1415 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1907 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600) and mem[_1907] > -1 / _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _2061 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2061
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2061, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1908 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600) and mem[_1908] > -1 / _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _2074 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _2074
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _2074, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _1821 + ((block.timestamp * _1507 * _1487) - (_1520 * _1507 * _1487) / 10000 / 24 * 3600)
                u = u + _1380
                continue 
            _1508 = mem[_1415 + 64]
            _1521 = mem[_1415 + 96]
            if block.timestamp < mem[_1415 + 96]:
                revert with 0, 17
            if mem[_1415 + 64] and mem[_1474] > -1 / mem[_1415 + 64]:
                revert with 0, 17
            if mem[_1415 + 64] * mem[_1474] and block.timestamp - mem[_1415 + 96] > -1 / mem[_1415 + 64] * mem[_1474]:
                revert with 0, 17
            _1822 = mem[_1415 + 128]
            if mem[_1415 + 128] > !((block.timestamp * mem[_1415 + 64] * mem[_1474]) - (mem[_1415 + 96] * mem[_1415 + 64] * mem[_1474]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_1415 + 256] > 5:
                revert with 0, 33
            if mem[_1415 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1906 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600) and mem[_1906] > -1 / _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _2055 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _2055
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _2055, msg.sender
            else:
                if mem[_1415 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_1415 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1910 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600) and mem[_1910] > -1 / _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _2065 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2065
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2065, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1911 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600) and mem[_1911] > -1 / _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _2077 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _2077
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _2077, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
            if uint8(s) == 255:
                revert with 0, 17
            s = uint8(s) + 1
            t = t + _1822 + ((block.timestamp * _1508 * _1487) - (_1521 * _1508 * _1487) / 10000 / 24 * 3600)
            u = u + _1380
            continue 
        _1354 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_1354 + 288] = ('cd', 4).length
        mem[_1354 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_1354 + ('cd', 4).length + 320] = 0
        mem[_1354] = _1354 + 288
        mem[_1354 + 32] = 0
        mem[_1354 + 64] = u
        mem[_1354 + 96] = block.timestamp
        mem[_1354 + 128] = t
        mem[_1354 + 160] = u
        mem[_1354 + 192] = 0
        mem[_1354 + 224] = 0
        mem[_1354 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_1354 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var66001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = u
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = t
            mem[mem[64] + 228] = u
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2165 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2168 = mem[_2165]
            mem[0] = mem[_2165]
            mem[32] = 13
            _2170 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_2170)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_2170] = 0
                    stor2[_2170] = u
                    stor3[_2170] = block.timestamp
                    stor4[_2170] = t
                    stor5[_2170] = u
                    uint256(stor6[_2170]) = 0
                    uint256(stor7[_2170].field_0) = 0
                    Mask(248, 0, stor7[_2170].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3741 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2168] = mem[_3741]
                else:
                    uint256(stor[_2170].field_0) = 0
                    s = 0
                    while (uint255(uint256(stor[_2170].field_0)) * 0.5) + 31 / 32 > s:
                        uint256(stor[s + sha3(mem[0])].field_0) = 0
                        s = s + 1
                        continue 
                    stor1[_2170] = 0
                    stor2[_2170] = u
                    stor3[_2170] = block.timestamp
                    stor4[_2170] = t
                    stor5[_2170] = u
                    uint256(stor6[_2170]) = 0
                    uint256(stor7[_2170].field_0) = 0
                    Mask(248, 0, stor7[_2170].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    s = 0
                    t = _728
                    v = mem[64] + 36
                    while s < 4:
                        mem[v] = mem[t + 31 len 1]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2999 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2168] = mem[_2999]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_2170)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_2170] = 0
                    stor2[_2170] = u
                    stor3[_2170] = block.timestamp
                    stor4[_2170] = t
                    stor5[_2170] = u
                    uint256(stor6[_2170]) = 0
                    uint256(stor7[_2170].field_0) = 0
                    Mask(248, 0, stor7[_2170].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3742 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2168] = mem[_3742]
                else:
                    uint256(stor[_2170].field_0) = 0
                    idx = 0
                    while stor[_2170].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_2170] = 0
                    stor2[_2170] = u
                    stor3[_2170] = block.timestamp
                    stor4[_2170] = t
                    stor5[_2170] = u
                    uint256(stor6[_2170]) = 0
                    uint256(stor7[_2170].field_0) = 0
                    Mask(248, 0, stor7[_2170].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _728
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3003 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_2168] = mem[_3003]
            return _2168
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = u
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = t
        mem[mem[64] + 228] = u
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2166 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2169 = mem[_2166]
        mem[0] = mem[_2166]
        mem[32] = 13
        _2173 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_2173)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_2173] = 0
                stor2[_2173] = u
                stor3[_2173] = block.timestamp
                stor4[_2173] = t
                stor5[_2173] = u
                uint256(stor6[_2173]) = 0
                uint256(stor7[_2173].field_0) = 0
                Mask(248, 0, stor7[_2173].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _728
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3743 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_2169] = mem[_3743]
            else:
                uint256(stor[_2173].field_0) = 0
                s = 0
                while (uint255(uint256(stor[_2173].field_0)) * 0.5) + 31 / 32 > s:
                    uint256(stor[s + sha3(mem[0])].field_0) = 0
                    s = s + 1
                    continue 
                stor1[_2173] = 0
                stor2[_2173] = u
                stor3[_2173] = block.timestamp
                stor4[_2173] = t
                stor5[_2173] = u
                uint256(stor6[_2173]) = 0
                uint256(stor7[_2173].field_0) = 0
                Mask(248, 0, stor7[_2173].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                s = 0
                t = _728
                v = mem[64] + 36
                while s < 4:
                    mem[v] = mem[t + 31 len 1]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3007 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_2169] = mem[_3007]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_2173)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_2173] = 0
                stor2[_2173] = u
                stor3[_2173] = block.timestamp
                stor4[_2173] = t
                stor5[_2173] = u
                uint256(stor6[_2173]) = 0
                uint256(stor7[_2173].field_0) = 0
                Mask(248, 0, stor7[_2173].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _728
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3744 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_2169] = mem[_3744]
            else:
                uint256(stor[_2173].field_0) = 0
                idx = 0
                while stor[_2173].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_2173] = 0
                stor2[_2173] = u
                stor3[_2173] = block.timestamp
                stor4[_2173] = t
                stor5[_2173] = u
                uint256(stor6[_2173]) = 0
                uint256(stor7[_2173].field_0) = 0
                Mask(248, 0, stor7[_2173].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _728
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3011 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_2169] = mem[_3011]
        return _2169
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 929
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 641] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 673] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 705] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 737] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 769] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 801] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 833] = 0
    mem[var51002] = 0
    mem[var51002 + 32] = 0
    mem[var53002] = var53001
    if not var53003 - 1:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _2953 = mem[(32 * uint8(idx)) + 128]
            _2995 = mem[64]
            mem[64] = mem[64] + 288
            mem[_2995] = 96
            mem[_2995 + 32] = 0
            mem[_2995 + 64] = 0
            mem[_2995 + 96] = 0
            mem[_2995 + 128] = 0
            mem[_2995 + 160] = 0
            mem[_2995 + 192] = 0
            mem[_2995 + 224] = 0
            mem[_2995 + 256] = 0
            mem[0] = _2953
            mem[32] = 13
            if uint256(stor13[_2953].field_512):
                mem[0] = _2953
                mem[32] = 13
                _3041 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_2953].field_0):
                    if bool(stor13[_2953].field_0) == uint255(uint256(stor13[_2953].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_2953].field_0)) * 0.5) + 32
                    mem[_3091] = uint255(uint256(stor13[_2953].field_0)) * 0.5
                    if bool(stor13[_2953].field_0):
                        if bool(stor13[_2953].field_0) == uint255(uint256(stor13[_2953].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_2953].field_0)):
                            if 31 >= uint255(uint256(stor13[_2953].field_0)) * 0.5:
                                mem[_3091 + 32] = 256 * Mask(248, 0, stor13[_2953].field_8)
                            else:
                                mem[0] = sha3(_2953, 13)
                                mem[_3091 + 32] = uint256(stor13[_2953].field_0)
                                s = _3091 + 32
                                t = sha3(sha3(_2953, 13))
                                while _3091 + (uint255(uint256(stor13[_2953].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_2953].field_0) == stor13[_2953].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_2953].field_1 % 128:
                            if 31 >= stor13[_2953].field_1 % 128:
                                mem[_3091 + 32] = 256 * Mask(248, 0, stor13[_2953].field_8)
                            else:
                                mem[0] = sha3(_2953, 13)
                                mem[_3091 + 32] = uint256(stor13[_2953].field_0)
                                s = _3091 + 32
                                t = sha3(sha3(_2953, 13))
                                while _3091 + stor13[_2953].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_3041] = _3091
                else:
                    if bool(stor13[_2953].field_0) == stor13[_2953].field_1 % 128 < 32:
                        revert with 0, 34
                    _3094 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_2953].field_1 % 128) + 32
                    mem[_3094] = stor13[_2953].field_1 % 128
                    if bool(stor13[_2953].field_0):
                        if bool(stor13[_2953].field_0) == uint255(uint256(stor13[_2953].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_2953].field_0)):
                            if 31 >= uint255(uint256(stor13[_2953].field_0)) * 0.5:
                                mem[_3094 + 32] = 256 * Mask(248, 0, stor13[_2953].field_8)
                            else:
                                mem[0] = sha3(_2953, 13)
                                mem[_3094 + 32] = uint256(stor13[_2953].field_0)
                                s = _3094 + 32
                                t = sha3(sha3(_2953, 13))
                                while _3094 + (uint255(uint256(stor13[_2953].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_2953].field_0) == stor13[_2953].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_2953].field_1 % 128:
                            if 31 >= stor13[_2953].field_1 % 128:
                                mem[_3094 + 32] = 256 * Mask(248, 0, stor13[_2953].field_8)
                            else:
                                mem[0] = sha3(_2953, 13)
                                mem[_3094 + 32] = uint256(stor13[_2953].field_0)
                                s = _3094 + 32
                                t = sha3(sha3(_2953, 13))
                                while _3094 + stor13[_2953].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_3041] = _3094
                mem[_3041 + 32] = uint256(stor13[_2953].field_256)
                mem[_3041 + 64] = uint256(stor13[_2953].field_512)
                mem[_3041 + 96] = uint256(stor13[_2953].field_768)
                mem[_3041 + 128] = uint256(stor13[_2953].field_1024)
                mem[_3041 + 160] = uint256(stor13[_2953].field_1280)
                mem[_3041 + 192] = uint256(stor13[_2953].field_1536)
                if uint8(stor13[_2953].field_1792) > 5:
                    revert with 0, 33
                mem[_3041 + 224] = uint8(stor13[_2953].field_1792)
                if uint8(stor13[_2953].field_1800) > 5:
                    revert with 0, 33
                mem[_3041 + 256] = uint8(stor13[_2953].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _3041
                if uint256(stor13[_2953].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_2953].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_2953].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_2953].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_2953].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_2953].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _2953
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _2953
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3077 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3092 = mem[_3077]
                require mem[_3077] <= test266151307()
                require return_data.size - mem[_3077] >= 288
                if not bool(_3077 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _3077 + ceil32(return_data.size) + 288
                _3103 = mem[_3077 + _3092]
                require mem[_3077 + _3092] <= test266151307()
                require _3077 + _3092 + mem[_3077 + _3092] + 31 < _3077 + return_data.size
                _3113 = mem[_3077 + _3092 + mem[_3077 + _3092]]
                if mem[_3077 + _3092 + mem[_3077 + _3092]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_3077 + _3092 + mem[_3077 + _3092]])) + 289 < 288 or _3077 + ceil32(return_data.size) + ceil32(ceil32(mem[_3077 + _3092 + mem[_3077 + _3092]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _3077 + ceil32(return_data.size) + ceil32(ceil32(mem[_3077 + _3092 + mem[_3077 + _3092]])) + 289
                mem[_3077 + ceil32(return_data.size) + 288] = _3113
                require _3092 + _3103 + _3113 + 32 <= return_data.size
                s = 0
                while s < _3113:
                    mem[s + _3077 + ceil32(return_data.size) + 320] = mem[s + _3077 + _3092 + _3103 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3113) > _3113:
                    mem[_3113 + _3077 + ceil32(return_data.size) + 320] = 0
                mem[_3077 + ceil32(return_data.size)] = _3077 + ceil32(return_data.size) + 288
                mem[_3077 + ceil32(return_data.size) + 32] = mem[_3077 + _3092 + 32]
                mem[_3077 + ceil32(return_data.size) + 64] = mem[_3077 + _3092 + 64]
                mem[_3077 + ceil32(return_data.size) + 96] = mem[_3077 + _3092 + 96]
                mem[_3077 + ceil32(return_data.size) + 128] = mem[_3077 + _3092 + 128]
                mem[_3077 + ceil32(return_data.size) + 160] = mem[_3077 + _3092 + 160]
                mem[_3077 + ceil32(return_data.size) + 192] = mem[_3077 + _3092 + 192]
                require mem[_3077 + _3092 + 224] < 6
                mem[_3077 + ceil32(return_data.size) + 224] = mem[_3077 + _3092 + 224]
                require mem[_3077 + _3092 + 256] < 6
                mem[_3077 + ceil32(return_data.size) + 256] = mem[_3077 + _3092 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _3077 + ceil32(return_data.size)
                if mem[_3077 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_3077 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_3077 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_3077 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_3077 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_3077 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _3075 = mem[64]
        mem[64] = mem[64] + 128
        mem[_3075 len 128] = call.data[calldata.size len 128]
        s = 0
        t = 0
        u = 0
        while uint8(s) < 4:
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            mem[(32 * uint8(s)) + _3075] = uint8(mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _3759 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if u > !mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            _3802 = mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            _3818 = mem[(32 * uint8(s)) + 128]
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _3831 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _3841 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _3967 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4196 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600) and mem[_4196] > -1 / _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4307 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4307
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4307, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4210 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600) and mem[_4210] > -1 / _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4312 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4312
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4312, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4211 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600) and mem[_4211] > -1 / _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4323 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4323
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4323, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _3967 + ((block.timestamp * _3831 * stor5.length) - (_3841 * _3831 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                _3832 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _3842 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _3968 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4201 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600) and mem[_4201] > -1 / _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4310 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4310
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4310, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4213 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600) and mem[_4213] > -1 / _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4316 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4316
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4316, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4214 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600) and mem[_4214] > -1 / _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _4326 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4326
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _4326, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                    uint256(stor[v].field_0) = 0
                    v = v + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                t = t + _3968 + ((block.timestamp * _3832 * stor5.length) - (_3842 * _3832 * stor5.length) / 10000 / 24 * 3600)
                u = u + _3759
                continue 
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _3849 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _3862 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _4011 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600) and mem[_4220] > -1 / _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4329 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4329
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4329, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _3759
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _3759
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4236 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600) and mem[_4236] > -1 / _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4338 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4338
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4338, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                                if uint8(s) == 255:
                                    revert with 0, 17
                                s = uint8(s) + 1
                                t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                                u = u + _3759
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _3759
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4237 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600) and mem[_4237] > -1 / _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4355 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4355
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4355, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _4011 + ((block.timestamp * _3849 * stor4.length) - (_3862 * _3849 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                _3850 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _3863 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _4012 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4225 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600) and mem[_4225] > -1 / _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4332 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4332
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4332, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600) and mem[_4239] > -1 / _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4342 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4342
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4342, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _3759
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _3759
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4240 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600) and mem[_4240] > -1 / _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4358 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4358
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4358, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _4012 + ((block.timestamp * _3850 * stor4.length) - (_3863 * _3850 * stor4.length) / 10000 / 24 * 3600)
                u = u + _3759
                continue 
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 12
                _3843 = sha3(mem[(32 * uint8(s)) + 128], 12)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _3872 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _3881 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                        revert with 0, 17
                    _4132 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4246 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4246] > -1 / _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4367 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4367
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4367, msg.sender
                    else:
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4260 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4260] > -1 / _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _4380 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _4380
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _4380, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4261 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4261] > -1 / _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _4395 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _4395
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _4395, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _4132 + ((block.timestamp * _3872 * uint256(stor[_3843].field_0)) - (_3881 * _3872 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)
                    u = u + _3759
                    continue 
                _3873 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _3882 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                    revert with 0, 17
                _4133 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4251 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4251] > -1 / _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4370 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4370
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4370, msg.sender
                else:
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4263 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4263] > -1 / _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4384 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4384
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4384, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4264 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600) and mem[_4264] > -1 / _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4398 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4398
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4398, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _4133 + ((block.timestamp * _3873 * uint256(stor[_3843].field_0)) - (_3882 * _3873 * uint256(stor[_3843].field_0)) / 10000 / 24 * 3600)
                u = u + _3759
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(s)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _3818
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3861 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3874 = mem[_3861]
            if mem[_3802 + 256] > 5:
                revert with 0, 33
            if mem[_3802 + 256] == 5:
                _3894 = mem[_3802 + 160]
                _3907 = mem[_3802 + 96]
                if block.timestamp < mem[_3802 + 96]:
                    revert with 0, 17
                if mem[_3802 + 160] and mem[_3861] > -1 / mem[_3802 + 160]:
                    revert with 0, 17
                if mem[_3802 + 160] * mem[_3861] and block.timestamp - mem[_3802 + 96] > -1 / mem[_3802 + 160] * mem[_3861]:
                    revert with 0, 17
                _4208 = mem[_3802 + 128]
                if mem[_3802 + 128] > !((block.timestamp * mem[_3802 + 160] * mem[_3861]) - (mem[_3802 + 96] * mem[_3802 + 160] * mem[_3861]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_3802 + 256] > 5:
                    revert with 0, 33
                if mem[_3802 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4288 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600) and mem[_4288] > -1 / _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4439 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4439
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4439, msg.sender
                else:
                    if mem[_3802 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_3802 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4294 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600) and mem[_4294] > -1 / _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4448 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4448
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4448, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4295 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600) and mem[_4295] > -1 / _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _4461 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _4461
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _4461, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _4208 + ((block.timestamp * _3894 * _3874) - (_3907 * _3894 * _3874) / 10000 / 24 * 3600)
                u = u + _3759
                continue 
            _3895 = mem[_3802 + 64]
            _3908 = mem[_3802 + 96]
            if block.timestamp < mem[_3802 + 96]:
                revert with 0, 17
            if mem[_3802 + 64] and mem[_3861] > -1 / mem[_3802 + 64]:
                revert with 0, 17
            if mem[_3802 + 64] * mem[_3861] and block.timestamp - mem[_3802 + 96] > -1 / mem[_3802 + 64] * mem[_3861]:
                revert with 0, 17
            _4209 = mem[_3802 + 128]
            if mem[_3802 + 128] > !((block.timestamp * mem[_3802 + 64] * mem[_3861]) - (mem[_3802 + 96] * mem[_3802 + 64] * mem[_3861]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_3802 + 256] > 5:
                revert with 0, 33
            if mem[_3802 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4293 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600) and mem[_4293] > -1 / _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _4442 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4442
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _4442, msg.sender
            else:
                if mem[_3802 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_3802 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4297 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600) and mem[_4297] > -1 / _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4452 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4452
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4452, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4298 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600) and mem[_4298] > -1 / _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _4464 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _4464
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _4464, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
            if uint8(s) == 255:
                revert with 0, 17
            s = uint8(s) + 1
            t = t + _4209 + ((block.timestamp * _3895 * _3874) - (_3908 * _3895 * _3874) / 10000 / 24 * 3600)
            u = u + _3759
            continue 
        _3713 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_3713 + 288] = ('cd', 4).length
        mem[_3713 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_3713 + ('cd', 4).length + 320] = 0
        mem[_3713] = _3713 + 288
        mem[_3713 + 32] = 0
        mem[_3713 + 64] = u
        mem[_3713 + 96] = block.timestamp
        mem[_3713 + 128] = t
        mem[_3713 + 160] = u
        mem[_3713 + 192] = 0
        mem[_3713 + 224] = 0
        mem[_3713 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_3713 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var74001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = u
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = t
            mem[mem[64] + 228] = u
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4552 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _4555 = mem[_4552]
            mem[0] = mem[_4552]
            mem[32] = 13
            _4557 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_4557)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_4557] = 0
                    stor2[_4557] = u
                    stor3[_4557] = block.timestamp
                    stor4[_4557] = t
                    stor5[_4557] = u
                    uint256(stor6[_4557]) = 0
                    uint256(stor7[_4557].field_0) = 0
                    Mask(248, 0, stor7[_4557].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _3075
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6128 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4555] = mem[_6128]
                else:
                    uint256(stor[_4557].field_0) = 0
                    s = 0
                    while (uint255(uint256(stor[_4557].field_0)) * 0.5) + 31 / 32 > s:
                        uint256(stor[s + sha3(mem[0])].field_0) = 0
                        s = s + 1
                        continue 
                    stor1[_4557] = 0
                    stor2[_4557] = u
                    stor3[_4557] = block.timestamp
                    stor4[_4557] = t
                    stor5[_4557] = u
                    uint256(stor6[_4557]) = 0
                    uint256(stor7[_4557].field_0) = 0
                    Mask(248, 0, stor7[_4557].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    s = 0
                    t = _3075
                    v = mem[64] + 36
                    while s < 4:
                        mem[v] = mem[t + 31 len 1]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5386 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4555] = mem[_5386]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_4557)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_4557] = 0
                    stor2[_4557] = u
                    stor3[_4557] = block.timestamp
                    stor4[_4557] = t
                    stor5[_4557] = u
                    uint256(stor6[_4557]) = 0
                    uint256(stor7[_4557].field_0) = 0
                    Mask(248, 0, stor7[_4557].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _3075
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6129 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4555] = mem[_6129]
                else:
                    uint256(stor[_4557].field_0) = 0
                    idx = 0
                    while stor[_4557].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_4557] = 0
                    stor2[_4557] = u
                    stor3[_4557] = block.timestamp
                    stor4[_4557] = t
                    stor5[_4557] = u
                    uint256(stor6[_4557]) = 0
                    uint256(stor7[_4557].field_0) = 0
                    Mask(248, 0, stor7[_4557].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _3075
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5390 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_4555] = mem[_5390]
            return _4555
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = u
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = t
        mem[mem[64] + 228] = u
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _4553 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _4556 = mem[_4553]
        mem[0] = mem[_4553]
        mem[32] = 13
        _4560 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_4560)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_4560] = 0
                stor2[_4560] = u
                stor3[_4560] = block.timestamp
                stor4[_4560] = t
                stor5[_4560] = u
                uint256(stor6[_4560]) = 0
                uint256(stor7[_4560].field_0) = 0
                Mask(248, 0, stor7[_4560].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _3075
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6130 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_4556] = mem[_6130]
            else:
                uint256(stor[_4560].field_0) = 0
                s = 0
                while (uint255(uint256(stor[_4560].field_0)) * 0.5) + 31 / 32 > s:
                    uint256(stor[s + sha3(mem[0])].field_0) = 0
                    s = s + 1
                    continue 
                stor1[_4560] = 0
                stor2[_4560] = u
                stor3[_4560] = block.timestamp
                stor4[_4560] = t
                stor5[_4560] = u
                uint256(stor6[_4560]) = 0
                uint256(stor7[_4560].field_0) = 0
                Mask(248, 0, stor7[_4560].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                s = 0
                t = _3075
                v = mem[64] + 36
                while s < 4:
                    mem[v] = mem[t + 31 len 1]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5394 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_4556] = mem[_5394]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_4560)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_4560] = 0
                stor2[_4560] = u
                stor3[_4560] = block.timestamp
                stor4[_4560] = t
                stor5[_4560] = u
                uint256(stor6[_4560]) = 0
                uint256(stor7[_4560].field_0) = 0
                Mask(248, 0, stor7[_4560].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _3075
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6131 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_4556] = mem[_6131]
            else:
                uint256(stor[_4560].field_0) = 0
                idx = 0
                while stor[_4560].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_4560] = 0
                stor2[_4560] = u
                stor3[_4560] = block.timestamp
                stor4[_4560] = t
                stor5[_4560] = u
                uint256(stor6[_4560]) = 0
                uint256(stor7[_4560].field_0) = 0
                Mask(248, 0, stor7[_4560].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _3075
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5398 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_4556] = mem[_5398]
        return _4556
    mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1217
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 929] = 96
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 961] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 993] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1025] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1057] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1089] = 0
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1121] = 0
    mem[var59002] = 0
    mem[var59002 + 32] = 0
    mem[var61002] = var61001
    if var61003 - 1:
        mem[64] = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1505
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1217] = 96
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1249] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1281] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1313] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1345] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1377] = 0
        mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 1409] = 0
        mem[var67002] = 0
        mem[var67002 + 32] = 0
        mem[var69002] = var69001
        if var69003 - 1:
            # nil
        else:
            idx = 0
            while uint8(idx) < 4:
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _7727 = mem[(32 * uint8(idx)) + 128]
                _7769 = mem[64]
                mem[64] = mem[64] + 288
                mem[_7769] = 96
                mem[_7769 + 32] = 0
                mem[_7769 + 64] = 0
                mem[_7769 + 96] = 0
                mem[_7769 + 128] = 0
                mem[_7769 + 160] = 0
                mem[_7769 + 192] = 0
                mem[_7769 + 224] = 0
                mem[_7769 + 256] = 0
                mem[0] = _7727
                mem[32] = 13
                if uint256(stor13[_7727].field_512):
                    mem[0] = _7727
                    mem[32] = 13
                    _7815 = mem[64]
                    mem[64] = mem[64] + 288
                    if bool(stor13[_7727].field_0):
                        if bool(stor13[_7727].field_0) == uint255(uint256(stor13[_7727].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        _7865 = mem[64]
                        mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_7727].field_0)) * 0.5) + 32
                        mem[_7865] = uint255(uint256(stor13[_7727].field_0)) * 0.5
                        if bool(stor13[_7727].field_0):
                            if bool(stor13[_7727].field_0) == uint255(uint256(stor13[_7727].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, uint256(stor13[_7727].field_0)):
                                if 31 >= uint255(uint256(stor13[_7727].field_0)) * 0.5:
                                    mem[_7865 + 32] = 256 * Mask(248, 0, stor13[_7727].field_8)
                                else:
                                    mem[0] = sha3(_7727, 13)
                                    mem[_7865 + 32] = uint256(stor13[_7727].field_0)
                                    s = _7865 + 32
                                    t = sha3(sha3(_7727, 13))
                                    while _7865 + (uint255(uint256(stor13[_7727].field_0)) * 0.5) > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor13[_7727].field_0) == stor13[_7727].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[_7727].field_1 % 128:
                                if 31 >= stor13[_7727].field_1 % 128:
                                    mem[_7865 + 32] = 256 * Mask(248, 0, stor13[_7727].field_8)
                                else:
                                    mem[0] = sha3(_7727, 13)
                                    mem[_7865 + 32] = uint256(stor13[_7727].field_0)
                                    s = _7865 + 32
                                    t = sha3(sha3(_7727, 13))
                                    while _7865 + stor13[_7727].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        mem[_7815] = _7865
                    else:
                        if bool(stor13[_7727].field_0) == stor13[_7727].field_1 % 128 < 32:
                            revert with 0, 34
                        _7868 = mem[64]
                        mem[64] = mem[64] + ceil32(stor13[_7727].field_1 % 128) + 32
                        mem[_7868] = stor13[_7727].field_1 % 128
                        if bool(stor13[_7727].field_0):
                            if bool(stor13[_7727].field_0) == uint255(uint256(stor13[_7727].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, uint256(stor13[_7727].field_0)):
                                if 31 >= uint255(uint256(stor13[_7727].field_0)) * 0.5:
                                    mem[_7868 + 32] = 256 * Mask(248, 0, stor13[_7727].field_8)
                                else:
                                    mem[0] = sha3(_7727, 13)
                                    mem[_7868 + 32] = uint256(stor13[_7727].field_0)
                                    s = _7868 + 32
                                    t = sha3(sha3(_7727, 13))
                                    while _7868 + (uint255(uint256(stor13[_7727].field_0)) * 0.5) > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        else:
                            if bool(stor13[_7727].field_0) == stor13[_7727].field_1 % 128 < 32:
                                revert with 0, 34
                            if stor13[_7727].field_1 % 128:
                                if 31 >= stor13[_7727].field_1 % 128:
                                    mem[_7868 + 32] = 256 * Mask(248, 0, stor13[_7727].field_8)
                                else:
                                    mem[0] = sha3(_7727, 13)
                                    mem[_7868 + 32] = uint256(stor13[_7727].field_0)
                                    s = _7868 + 32
                                    t = sha3(sha3(_7727, 13))
                                    while _7868 + stor13[_7727].field_1 % 128 > s:
                                        mem[s + 32] = stor1[t]
                                        s = s + 32
                                        t = t + 1
                                        continue 
                        mem[_7815] = _7868
                    mem[_7815 + 32] = uint256(stor13[_7727].field_256)
                    mem[_7815 + 64] = uint256(stor13[_7727].field_512)
                    mem[_7815 + 96] = uint256(stor13[_7727].field_768)
                    mem[_7815 + 128] = uint256(stor13[_7727].field_1024)
                    mem[_7815 + 160] = uint256(stor13[_7727].field_1280)
                    mem[_7815 + 192] = uint256(stor13[_7727].field_1536)
                    if uint8(stor13[_7727].field_1792) > 5:
                        revert with 0, 33
                    mem[_7815 + 224] = uint8(stor13[_7727].field_1792)
                    if uint8(stor13[_7727].field_1800) > 5:
                        revert with 0, 33
                    mem[_7815 + 256] = uint8(stor13[_7727].field_1800)
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _7815
                    if uint256(stor13[_7727].field_1280) != stor1.length:
                        revert with 0, 'Invalid tier'
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    if uint8(stor13[_7727].field_1800) > 5:
                        revert with 0, 33
                    if uint8(stor13[_7727].field_1800) >= 4:
                        revert with 0, 50
                    if mem[(32 * uint8(stor13[_7727].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                        revert with 0, 17
                    mem[(32 * uint8(stor13[_7727].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_7727].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
                else:
                    mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _7727
                    require ext_code.size(stor8)
                    staticcall stor8.0x36dac2cc with:
                            gas gas_remaining wei
                           args _7727
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7851 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7866 = mem[_7851]
                    require mem[_7851] <= test266151307()
                    require return_data.size - mem[_7851] >= 288
                    if not bool(_7851 + ceil32(return_data.size) + 288 <= test266151307()):
                        revert with 0, 65
                    mem[64] = _7851 + ceil32(return_data.size) + 288
                    _7877 = mem[_7851 + _7866]
                    require mem[_7851 + _7866] <= test266151307()
                    require _7851 + _7866 + mem[_7851 + _7866] + 31 < _7851 + return_data.size
                    _7887 = mem[_7851 + _7866 + mem[_7851 + _7866]]
                    if mem[_7851 + _7866 + mem[_7851 + _7866]] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[_7851 + _7866 + mem[_7851 + _7866]])) + 289 < 288 or _7851 + ceil32(return_data.size) + ceil32(ceil32(mem[_7851 + _7866 + mem[_7851 + _7866]])) + 289 > test266151307():
                        revert with 0, 65
                    mem[64] = _7851 + ceil32(return_data.size) + ceil32(ceil32(mem[_7851 + _7866 + mem[_7851 + _7866]])) + 289
                    mem[_7851 + ceil32(return_data.size) + 288] = _7887
                    require _7866 + _7877 + _7887 + 32 <= return_data.size
                    s = 0
                    while s < _7887:
                        mem[s + _7851 + ceil32(return_data.size) + 320] = mem[s + _7851 + _7866 + _7877 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_7887) > _7887:
                        mem[_7887 + _7851 + ceil32(return_data.size) + 320] = 0
                    mem[_7851 + ceil32(return_data.size)] = _7851 + ceil32(return_data.size) + 288
                    mem[_7851 + ceil32(return_data.size) + 32] = mem[_7851 + _7866 + 32]
                    mem[_7851 + ceil32(return_data.size) + 64] = mem[_7851 + _7866 + 64]
                    mem[_7851 + ceil32(return_data.size) + 96] = mem[_7851 + _7866 + 96]
                    mem[_7851 + ceil32(return_data.size) + 128] = mem[_7851 + _7866 + 128]
                    mem[_7851 + ceil32(return_data.size) + 160] = mem[_7851 + _7866 + 160]
                    mem[_7851 + ceil32(return_data.size) + 192] = mem[_7851 + _7866 + 192]
                    require mem[_7851 + _7866 + 224] < 6
                    mem[_7851 + ceil32(return_data.size) + 224] = mem[_7851 + _7866 + 224]
                    require mem[_7851 + _7866 + 256] < 6
                    mem[_7851 + ceil32(return_data.size) + 256] = mem[_7851 + _7866 + 256]
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _7851 + ceil32(return_data.size)
                    if mem[_7851 + ceil32(return_data.size) + 160] != stor1.length:
                        revert with 0, 'Invalid tier'
                    if uint8(idx) >= 4:
                        revert with 0, 50
                    if mem[_7851 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_7851 + ceil32(return_data.size) + 256] >= 4:
                        revert with 0, 50
                    if mem[(32 * mem[_7851 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                        revert with 0, 17
                    mem[(32 * mem[_7851 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_7851 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
                if uint8(idx) == 255:
                    revert with 0, 17
                idx = uint8(idx) + 1
                continue 
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
                revert with 0, 'Invalid token type'
            if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
                revert with 0, 'Invalid token type'
            _7849 = mem[64]
            mem[64] = mem[64] + 128
            mem[_7849 len 128] = call.data[calldata.size len 128]
            idx = 0
            s = 0
            t = 0
            while uint8(idx) < 4:
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                    revert with 0, 33
                if 1 > -mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                    revert with 0, 17
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + _7849] = uint8(mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
                _8533 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                if t > !mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if uint8(idx) >= 4:
                    revert with 0, 50
                _8576 = mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
                if uint8(idx) >= mem[96]:
                    revert with 0, 50
                _8592 = mem[(32 * uint8(idx)) + 128]
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        _8605 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                        _8615 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                        if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                            revert with 0, 17
                        _8741 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8970 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600) and mem[_8970] > -1 / _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _9081 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _9081
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _9081, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 13
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _8533
                                    continue 
                            else:
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _8533
                                    continue 
                        else:
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8984 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600) and mem[_8984] > -1 / _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9086 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9086
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9086, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8985 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600) and mem[_8985] > -1 / _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9097 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9097
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9097, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8741 + ((block.timestamp * _8605 * stor5.length) - (_8615 * _8605 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                    else:
                        _8606 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                        _8616 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                        if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                            revert with 0, 17
                        _8742 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            require ext_code.size(stor8)
                            staticcall stor8.0xe5d76232 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8975 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600) and mem[_8975] > -1 / _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if s > !(_8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            _9084 = mem[(32 * uint8(idx)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _9084
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _9084, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint8(idx) >= mem[96]:
                                revert with 0, 50
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 13
                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _8533
                                    continue 
                            else:
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                    revert with 0, 34
                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                    # nil
                                else:
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                    uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                    if uint8(idx) == 255:
                                        revert with 0, 17
                                    idx = uint8(idx) + 1
                                    s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                    t = t + _8533
                                    continue 
                        else:
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            require ext_code.size(stor8)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                staticcall stor8.0xae55ae5 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8987 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600) and mem[_8987] > -1 / _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9090 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9090
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9090, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                            else:
                                staticcall stor8.0x1ec4a4a8 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8988 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600) and mem[_8988] > -1 / _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9100 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9100
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9100, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8742 + ((block.timestamp * _8606 * stor5.length) - (_8616 * _8606 * stor5.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                else:
                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                            _8623 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                            _8636 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                            if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                                revert with 0, 17
                            _8785 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8994 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600) and mem[_8994] > -1 / _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9103 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9103
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9103, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                            else:
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9010 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600) and mem[_9010] > -1 / _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9112 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9112
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9112, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9011 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600) and mem[_9011] > -1 / _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9129 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9129
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9129, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8785 + ((block.timestamp * _8623 * stor4.length) - (_8636 * _8623 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                        else:
                            _8624 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                            _8637 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                            if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                                revert with 0, 17
                            _8786 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8999 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600) and mem[_8999] > -1 / _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if s > !(_8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)):
                                    revert with 0, 17
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                _9106 = mem[(32 * uint8(idx)) + 128]
                                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = _9106
                                mem[mem[64] + 36] = msg.sender
                                require ext_code.size(stor8)
                                call stor8.0x37c14e70 with:
                                     gas gas_remaining wei
                                    args _9106, msg.sender
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint8(idx) >= mem[96]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * uint8(idx)) + 128]
                                mem[32] = 13
                                if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                                else:
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                        revert with 0, 34
                                    uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                    if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                        # nil
                                    else:
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                        uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                        if uint8(idx) == 255:
                                            revert with 0, 17
                                        idx = uint8(idx) + 1
                                        s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                        t = t + _8533
                                        continue 
                            else:
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9013 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600) and mem[_9013] > -1 / _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9116 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9116
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9116, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9014 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600) and mem[_9014] > -1 / _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9132 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9132
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9132, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8786 + ((block.timestamp * _8624 * stor4.length) - (_8637 * _8624 * stor4.length) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                    else:
                        mem[0] = mem[(32 * uint8(idx)) + 128]
                        mem[32] = 12
                        if sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                            mem[0] = mem[(32 * uint8(idx)) + 128]
                            mem[32] = 12
                            _8617 = sha3(mem[(32 * uint8(idx)) + 128], 12)
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                revert with 0, 33
                            if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                _8646 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                                _8655 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                                    revert with 0, 17
                                _8906 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9020 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9020] > -1 / _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9141 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9141
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9141, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9034 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9034] > -1 / _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9154 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9154
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9154, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9035 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9035] > -1 / _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9169 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9169
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9169, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8906 + ((block.timestamp * _8646 * uint256(stor[_8617].field_0)) - (_8655 * _8646 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                            else:
                                _8647 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                                _8656 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                                if block.timestamp < mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]] and block.timestamp - mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]:
                                    revert with 0, 17
                                _8907 = mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) - (mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(idx)) + 128]]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                    revert with 0, 33
                                if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9025 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9025] > -1 / _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9144 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9144
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9144, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9037 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9037] > -1 / _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9158 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9158
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9158, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9038 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600) and mem[_9038] > -1 / _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9172 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9172
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9172, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8907 + ((block.timestamp * _8647 * uint256(stor[_8617].field_0)) - (_8656 * _8647 * uint256(stor[_8617].field_0)) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                        else:
                            mem[mem[64] + 4] = mem[(32 * uint8(idx)) + 128]
                            require ext_code.size(stor8)
                            staticcall stor8.0xded2abc3 with:
                                    gas gas_remaining wei
                                   args _8592
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8635 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8648 = mem[_8635]
                            if mem[_8576 + 256] > 5:
                                revert with 0, 33
                            if mem[_8576 + 256] == 5:
                                _8668 = mem[_8576 + 160]
                                _8681 = mem[_8576 + 96]
                                if block.timestamp < mem[_8576 + 96]:
                                    revert with 0, 17
                                if mem[_8576 + 160] and mem[_8635] > -1 / mem[_8576 + 160]:
                                    revert with 0, 17
                                if mem[_8576 + 160] * mem[_8635] and block.timestamp - mem[_8576 + 96] > -1 / mem[_8576 + 160] * mem[_8635]:
                                    revert with 0, 17
                                _8982 = mem[_8576 + 128]
                                if mem[_8576 + 128] > !((block.timestamp * mem[_8576 + 160] * mem[_8635]) - (mem[_8576 + 96] * mem[_8576 + 160] * mem[_8635]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_8576 + 256] > 5:
                                    revert with 0, 33
                                if mem[_8576 + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9062 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600) and mem[_9062] > -1 / _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9213 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9213
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9213, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    if mem[_8576 + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_8576 + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9068 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600) and mem[_9068] > -1 / _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9222 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9222
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9222, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9069 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600) and mem[_9069] > -1 / _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9235 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9235
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9235, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8982 + ((block.timestamp * _8668 * _8648) - (_8681 * _8668 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                            else:
                                _8669 = mem[_8576 + 64]
                                _8682 = mem[_8576 + 96]
                                if block.timestamp < mem[_8576 + 96]:
                                    revert with 0, 17
                                if mem[_8576 + 64] and mem[_8635] > -1 / mem[_8576 + 64]:
                                    revert with 0, 17
                                if mem[_8576 + 64] * mem[_8635] and block.timestamp - mem[_8576 + 96] > -1 / mem[_8576 + 64] * mem[_8635]:
                                    revert with 0, 17
                                _8983 = mem[_8576 + 128]
                                if mem[_8576 + 128] > !((block.timestamp * mem[_8576 + 64] * mem[_8635]) - (mem[_8576 + 96] * mem[_8576 + 64] * mem[_8635]) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_8576 + 256] > 5:
                                    revert with 0, 33
                                if mem[_8576 + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9067 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600) and mem[_9067] > -1 / _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if s > !(_8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    _9216 = mem[(32 * uint8(idx)) + 128]
                                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = _9216
                                    mem[mem[64] + 36] = msg.sender
                                    require ext_code.size(stor8)
                                    call stor8.0x37c14e70 with:
                                         gas gas_remaining wei
                                        args _9216, msg.sender
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint8(idx) >= mem[96]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * uint8(idx)) + 128]
                                    mem[32] = 13
                                    if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                    else:
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                            revert with 0, 34
                                        uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                        if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                            # nil
                                        else:
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                            uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                            if uint8(idx) == 255:
                                                revert with 0, 17
                                            idx = uint8(idx) + 1
                                            s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                            t = t + _8533
                                            continue 
                                else:
                                    if mem[_8576 + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_8576 + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9071 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600) and mem[_9071] > -1 / _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9226 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9226
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9226, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9072 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600) and mem[_9072] > -1 / _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if s > !(_8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        _9238 = mem[(32 * uint8(idx)) + 128]
                                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = _9238
                                        mem[mem[64] + 36] = msg.sender
                                        require ext_code.size(stor8)
                                        call stor8.0x37c14e70 with:
                                             gas gas_remaining wei
                                            args _9238, msg.sender
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint8(idx) >= mem[96]:
                                            revert with 0, 50
                                        mem[0] = mem[(32 * uint8(idx)) + 128]
                                        mem[32] = 13
                                        if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0):
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0)) * 0.5:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
                                        else:
                                            if bool(stor13[mem[(32 * uint8(idx)) + 128]].field_0) == stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128 < 32:
                                                revert with 0, 34
                                            uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_0) = 0
                                            if 31 < stor13[mem[(32 * uint8(idx)) + 128]].field_1 % 128:
                                                # nil
                                            else:
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_256) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_512) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_768) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1024) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1280) = 0
                                                uint256(stor13[mem[(32 * uint8(idx)) + 128]].field_1536) = 0
                                                uint16(stor13[mem[(32 * uint8(idx)) + 128]].field_1792) = 0
                                                if uint8(idx) == 255:
                                                    revert with 0, 17
                                                idx = uint8(idx) + 1
                                                s = s + _8983 + ((block.timestamp * _8669 * _8648) - (_8682 * _8669 * _8648) / 10000 / 24 * 3600)
                                                t = t + _8533
                                                continue 
            # nil
    else:
        idx = 0
        while uint8(idx) < 4:
            if uint8(idx) >= mem[96]:
                revert with 0, 50
            _5340 = mem[(32 * uint8(idx)) + 128]
            _5382 = mem[64]
            mem[64] = mem[64] + 288
            mem[_5382] = 96
            mem[_5382 + 32] = 0
            mem[_5382 + 64] = 0
            mem[_5382 + 96] = 0
            mem[_5382 + 128] = 0
            mem[_5382 + 160] = 0
            mem[_5382 + 192] = 0
            mem[_5382 + 224] = 0
            mem[_5382 + 256] = 0
            mem[0] = _5340
            mem[32] = 13
            if uint256(stor13[_5340].field_512):
                mem[0] = _5340
                mem[32] = 13
                _5428 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_5340].field_0):
                    if bool(stor13[_5340].field_0) == uint255(uint256(stor13[_5340].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _5478 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_5340].field_0)) * 0.5) + 32
                    mem[_5478] = uint255(uint256(stor13[_5340].field_0)) * 0.5
                    if bool(stor13[_5340].field_0):
                        if bool(stor13[_5340].field_0) == uint255(uint256(stor13[_5340].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_5340].field_0)):
                            if 31 >= uint255(uint256(stor13[_5340].field_0)) * 0.5:
                                mem[_5478 + 32] = 256 * Mask(248, 0, stor13[_5340].field_8)
                            else:
                                mem[0] = sha3(_5340, 13)
                                mem[_5478 + 32] = uint256(stor13[_5340].field_0)
                                s = _5478 + 32
                                t = sha3(sha3(_5340, 13))
                                while _5478 + (uint255(uint256(stor13[_5340].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_5340].field_0) == stor13[_5340].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_5340].field_1 % 128:
                            if 31 >= stor13[_5340].field_1 % 128:
                                mem[_5478 + 32] = 256 * Mask(248, 0, stor13[_5340].field_8)
                            else:
                                mem[0] = sha3(_5340, 13)
                                mem[_5478 + 32] = uint256(stor13[_5340].field_0)
                                s = _5478 + 32
                                t = sha3(sha3(_5340, 13))
                                while _5478 + stor13[_5340].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_5428] = _5478
                else:
                    if bool(stor13[_5340].field_0) == stor13[_5340].field_1 % 128 < 32:
                        revert with 0, 34
                    _5481 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_5340].field_1 % 128) + 32
                    mem[_5481] = stor13[_5340].field_1 % 128
                    if bool(stor13[_5340].field_0):
                        if bool(stor13[_5340].field_0) == uint255(uint256(stor13[_5340].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if Mask(256, -1, uint256(stor13[_5340].field_0)):
                            if 31 >= uint255(uint256(stor13[_5340].field_0)) * 0.5:
                                mem[_5481 + 32] = 256 * Mask(248, 0, stor13[_5340].field_8)
                            else:
                                mem[0] = sha3(_5340, 13)
                                mem[_5481 + 32] = uint256(stor13[_5340].field_0)
                                s = _5481 + 32
                                t = sha3(sha3(_5340, 13))
                                while _5481 + (uint255(uint256(stor13[_5340].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    else:
                        if bool(stor13[_5340].field_0) == stor13[_5340].field_1 % 128 < 32:
                            revert with 0, 34
                        if stor13[_5340].field_1 % 128:
                            if 31 >= stor13[_5340].field_1 % 128:
                                mem[_5481 + 32] = 256 * Mask(248, 0, stor13[_5340].field_8)
                            else:
                                mem[0] = sha3(_5340, 13)
                                mem[_5481 + 32] = uint256(stor13[_5340].field_0)
                                s = _5481 + 32
                                t = sha3(sha3(_5340, 13))
                                while _5481 + stor13[_5340].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                    mem[_5428] = _5481
                mem[_5428 + 32] = uint256(stor13[_5340].field_256)
                mem[_5428 + 64] = uint256(stor13[_5340].field_512)
                mem[_5428 + 96] = uint256(stor13[_5340].field_768)
                mem[_5428 + 128] = uint256(stor13[_5340].field_1024)
                mem[_5428 + 160] = uint256(stor13[_5340].field_1280)
                mem[_5428 + 192] = uint256(stor13[_5340].field_1536)
                if uint8(stor13[_5340].field_1792) > 5:
                    revert with 0, 33
                mem[_5428 + 224] = uint8(stor13[_5340].field_1792)
                if uint8(stor13[_5340].field_1800) > 5:
                    revert with 0, 33
                mem[_5428 + 256] = uint8(stor13[_5340].field_1800)
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _5428
                if uint256(stor13[_5340].field_1280) != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if uint8(stor13[_5340].field_1800) > 5:
                    revert with 0, 33
                if uint8(stor13[_5340].field_1800) >= 4:
                    revert with 0, 50
                if mem[(32 * uint8(stor13[_5340].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * uint8(stor13[_5340].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * uint8(stor13[_5340].field_1800)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _5340
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _5340
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5464 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _5479 = mem[_5464]
                require mem[_5464] <= test266151307()
                require return_data.size - mem[_5464] >= 288
                if not bool(_5464 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _5464 + ceil32(return_data.size) + 288
                _5490 = mem[_5464 + _5479]
                require mem[_5464 + _5479] <= test266151307()
                require _5464 + _5479 + mem[_5464 + _5479] + 31 < _5464 + return_data.size
                _5500 = mem[_5464 + _5479 + mem[_5464 + _5479]]
                if mem[_5464 + _5479 + mem[_5464 + _5479]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_5464 + _5479 + mem[_5464 + _5479]])) + 289 < 288 or _5464 + ceil32(return_data.size) + ceil32(ceil32(mem[_5464 + _5479 + mem[_5464 + _5479]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _5464 + ceil32(return_data.size) + ceil32(ceil32(mem[_5464 + _5479 + mem[_5464 + _5479]])) + 289
                mem[_5464 + ceil32(return_data.size) + 288] = _5500
                require _5479 + _5490 + _5500 + 32 <= return_data.size
                s = 0
                while s < _5500:
                    mem[s + _5464 + ceil32(return_data.size) + 320] = mem[s + _5464 + _5479 + _5490 + 32]
                    s = s + 32
                    continue 
                if ceil32(_5500) > _5500:
                    mem[_5500 + _5464 + ceil32(return_data.size) + 320] = 0
                mem[_5464 + ceil32(return_data.size)] = _5464 + ceil32(return_data.size) + 288
                mem[_5464 + ceil32(return_data.size) + 32] = mem[_5464 + _5479 + 32]
                mem[_5464 + ceil32(return_data.size) + 64] = mem[_5464 + _5479 + 64]
                mem[_5464 + ceil32(return_data.size) + 96] = mem[_5464 + _5479 + 96]
                mem[_5464 + ceil32(return_data.size) + 128] = mem[_5464 + _5479 + 128]
                mem[_5464 + ceil32(return_data.size) + 160] = mem[_5464 + _5479 + 160]
                mem[_5464 + ceil32(return_data.size) + 192] = mem[_5464 + _5479 + 192]
                require mem[_5464 + _5479 + 224] < 6
                mem[_5464 + ceil32(return_data.size) + 224] = mem[_5464 + _5479 + 224]
                require mem[_5464 + _5479 + 256] < 6
                mem[_5464 + ceil32(return_data.size) + 256] = mem[_5464 + _5479 + 256]
                if uint8(idx) >= 4:
                    revert with 0, 50
                mem[(32 * uint8(idx)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] = _5464 + ceil32(return_data.size)
                if mem[_5464 + ceil32(return_data.size) + 160] != stor1.length:
                    revert with 0, 'Invalid tier'
                if uint8(idx) >= 4:
                    revert with 0, 50
                if mem[_5464 + ceil32(return_data.size) + 256] > 5:
                    revert with 0, 33
                if mem[_5464 + ceil32(return_data.size) + 256] >= 4:
                    revert with 0, 50
                if mem[(32 * mem[_5464 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] > -2:
                    revert with 0, 17
                mem[(32 * mem[_5464 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = mem[(32 * mem[_5464 + ceil32(return_data.size) + 256]) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] + 1
            if uint8(idx) == 255:
                revert with 0, 17
            idx = uint8(idx) + 1
            continue 
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 129] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 161] != 1:
            revert with 0, 'Invalid token type'
        if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 193] != 1:
            revert with 0, 'Invalid token type'
        _5462 = mem[64]
        mem[64] = mem[64] + 128
        mem[_5462 len 128] = call.data[calldata.size len 128]
        s = 0
        t = 0
        u = 0
        while uint8(s) < 4:
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 224] > 5:
                revert with 0, 33
            if 1 > -mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 255:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            mem[(32 * uint8(s)) + _5462] = uint8(mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 255 len 1] + 1)
            _6146 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
            if u > !mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                revert with 0, 17
            if uint8(s) >= 4:
                revert with 0, 50
            _6189 = mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            _6205 = mem[(32 * uint8(s)) + 128]
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                revert with 0, 33
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 4:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6218 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6228 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length:
                        revert with 0, 17
                    _6354 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6583 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600) and mem[_6583] > -1 / _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6694 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6694
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6694, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6597 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600) and mem[_6597] > -1 / _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6699 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6699
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6699, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6598 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600) and mem[_6598] > -1 / _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6710 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6710
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6710, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _6354 + ((block.timestamp * _6218 * stor5.length) - (_6228 * _6218 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                _6219 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6229 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor5.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length:
                    revert with 0, 17
                _6355 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6588 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600) and mem[_6588] > -1 / _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6697 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6697
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6697, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6600 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600) and mem[_6600] > -1 / _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6703 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6703
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6703, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                staticcall stor8.0x1ec4a4a8 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6601 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600) and mem[_6601] > -1 / _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _6713 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _6713
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _6713, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                    uint256(stor[v].field_0) = 0
                    v = v + 1
                    continue 
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                    revert with 0, 17
                v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                t = t + _6355 + ((block.timestamp * _6219 * stor5.length) - (_6229 * _6219 * stor5.length) / 10000 / 24 * 3600)
                u = u + _6146
                continue 
            if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 5:
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6236 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6249 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length:
                        revert with 0, 17
                    _6398 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6607 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600) and mem[_6607] > -1 / _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6716 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6716
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6716, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _6146
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _6146
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                        t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600) and mem[_6623] > -1 / _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6725 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6725
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6725, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                                if uint8(s) == 255:
                                    revert with 0, 17
                                s = uint8(s) + 1
                                t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                                u = u + _6146
                                continue 
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                            if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                                revert with 0, 17
                            v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                            t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _6146
                            continue 
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6624 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600) and mem[_6624] > -1 / _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6742 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6742
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6742, msg.sender
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        mem[0] = mem[(32 * uint8(s)) + 128]
                        mem[32] = 13
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                        else:
                            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                                revert with 0, 34
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                            if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                                mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                                v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                                while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                    uint256(stor[v].field_0) = 0
                                    v = v + 1
                                    continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6398 + ((block.timestamp * _6236 * stor4.length) - (_6249 * _6236 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                _6237 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6250 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and stor4.length > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length:
                    revert with 0, 17
                _6399 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * stor4.length) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6612 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600) and mem[_6612] > -1 / _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6719 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6719
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6719, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 >= stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                        if uint8(s) == 255:
                            revert with 0, 17
                        s = uint8(s) + 1
                        t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                    if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) == 255:
                        revert with 0, 17
                    v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + (stor13[mem[(32 * uint8(v)) + 128]].field_1 % 128 + 31 / 32)) + 1
                    t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6626 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600) and mem[_6626] > -1 / _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6729 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6729
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6729, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 >= uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                            if uint8(s) == 255:
                                revert with 0, 17
                            s = uint8(s) + 1
                            t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                            u = u + _6146
                            continue 
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(v)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_256) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_512) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_768) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1024) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1280) = 0
                        uint256(stor13[mem[(32 * uint8(v)) + 128]].field_1536) = 0
                        uint16(stor13[mem[(32 * uint8(v)) + 128]].field_1792) = 0
                        if uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) == 255:
                            revert with 0, 17
                        v = uint8(sha3(sha3(mem[(32 * uint8(v)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(v)) + 128]].field_0)) * 0.5) + 31 / 32)) + 1
                        t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                        u = u + _6146
                        continue 
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6627 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600) and mem[_6627] > -1 / _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6745 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6745
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6745, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _6399 + ((block.timestamp * _6237 * stor4.length) - (_6250 * _6237 * stor4.length) / 10000 / 24 * 3600)
                u = u + _6146
                continue 
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 12
            if sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 12
                _6230 = sha3(mem[(32 * uint8(s)) + 128], 12)
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    _6259 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]
                    _6268 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                    if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160]:
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                        revert with 0, 17
                    _6519 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 160] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                        require ext_code.size(stor8)
                        staticcall stor8.0xe5d76232 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6633 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6633] > -1 / _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6754 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6754
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6754, msg.sender
                    else:
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                            revert with 0, 33
                        require ext_code.size(stor8)
                        if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                            staticcall stor8.0xae55ae5 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6647 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6647] > -1 / _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _6767 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _6767
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _6767, msg.sender
                        else:
                            staticcall stor8.0x1ec4a4a8 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6648 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6648] > -1 / _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if t > !(_6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                                revert with 0, 17
                            if uint8(s) >= mem[96]:
                                revert with 0, 50
                            _6782 = mem[(32 * uint8(s)) + 128]
                            mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = _6782
                            mem[mem[64] + 36] = msg.sender
                            require ext_code.size(stor8)
                            call stor8.0x37c14e70 with:
                                 gas gas_remaining wei
                                args _6782, msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    mem[0] = mem[(32 * uint8(s)) + 128]
                    mem[32] = 13
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    else:
                        if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                        if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                            mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                            v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                            while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                                uint256(stor[v].field_0) = 0
                                v = v + 1
                                continue 
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                    uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                    if uint8(s) == 255:
                        revert with 0, 17
                    s = uint8(s) + 1
                    t = t + _6519 + ((block.timestamp * _6259 * uint256(stor[_6230].field_0)) - (_6268 * _6259 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)
                    u = u + _6146
                    continue 
                _6260 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]
                _6269 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]
                if block.timestamp < mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] and sub_ded2abc3[mem[(32 * uint8(s)) + 128]] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64]:
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]] and block.timestamp - mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] > -1 / mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]:
                    revert with 0, 17
                _6520 = mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128]
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 128] > !((block.timestamp * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) - (mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 96] * mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 64] * sub_ded2abc3[mem[(32 * uint8(s)) + 128]]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                    revert with 0, 33
                if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6638 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6638] > -1 / _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6757 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6757
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6757, msg.sender
                else:
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[mem[(32 * uint8(s)) + ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 225] + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6650 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6650] > -1 / _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6771 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6771
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6771, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6651 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600) and mem[_6651] > -1 / _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6785 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6785
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6785, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _6520 + ((block.timestamp * _6260 * uint256(stor[_6230].field_0)) - (_6269 * _6260 * uint256(stor[_6230].field_0)) / 10000 / 24 * 3600)
                u = u + _6146
                continue 
            mem[mem[64] + 4] = mem[(32 * uint8(s)) + 128]
            require ext_code.size(stor8)
            staticcall stor8.0xded2abc3 with:
                    gas gas_remaining wei
                   args _6205
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _6261 = mem[_6248]
            if mem[_6189 + 256] > 5:
                revert with 0, 33
            if mem[_6189 + 256] == 5:
                _6281 = mem[_6189 + 160]
                _6294 = mem[_6189 + 96]
                if block.timestamp < mem[_6189 + 96]:
                    revert with 0, 17
                if mem[_6189 + 160] and mem[_6248] > -1 / mem[_6189 + 160]:
                    revert with 0, 17
                if mem[_6189 + 160] * mem[_6248] and block.timestamp - mem[_6189 + 96] > -1 / mem[_6189 + 160] * mem[_6248]:
                    revert with 0, 17
                _6595 = mem[_6189 + 128]
                if mem[_6189 + 128] > !((block.timestamp * mem[_6189 + 160] * mem[_6248]) - (mem[_6189 + 96] * mem[_6189 + 160] * mem[_6248]) / 10000 / 24 * 3600):
                    revert with 0, 17
                if mem[_6189 + 256] > 5:
                    revert with 0, 33
                if mem[_6189 + 256] == 5:
                    require ext_code.size(stor8)
                    staticcall stor8.0xe5d76232 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6675 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600) and mem[_6675] > -1 / _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6826 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6826
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6826, msg.sender
                else:
                    if mem[_6189 + 256] > 5:
                        revert with 0, 33
                    require ext_code.size(stor8)
                    if mem[_6189 + 256] != 4:
                        staticcall stor8.0xae55ae5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6681 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600) and mem[_6681] > -1 / _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6835 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6835
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6835, msg.sender
                    else:
                        staticcall stor8.0x1ec4a4a8 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6682 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600) and mem[_6682] > -1 / _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600):
                            revert with 0, 17
                        if t > !(_6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600)):
                            revert with 0, 17
                        if uint8(s) >= mem[96]:
                            revert with 0, 50
                        _6848 = mem[(32 * uint8(s)) + 128]
                        mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = _6848
                        mem[mem[64] + 36] = msg.sender
                        require ext_code.size(stor8)
                        call stor8.0x37c14e70 with:
                             gas gas_remaining wei
                            args _6848, msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                mem[0] = mem[(32 * uint8(s)) + 128]
                mem[32] = 13
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                else:
                    if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                        revert with 0, 34
                    uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                    if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                        mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                        v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                        while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                            uint256(stor[v].field_0) = 0
                            v = v + 1
                            continue 
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
                uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
                if uint8(s) == 255:
                    revert with 0, 17
                s = uint8(s) + 1
                t = t + _6595 + ((block.timestamp * _6281 * _6261) - (_6294 * _6281 * _6261) / 10000 / 24 * 3600)
                u = u + _6146
                continue 
            _6282 = mem[_6189 + 64]
            _6295 = mem[_6189 + 96]
            if block.timestamp < mem[_6189 + 96]:
                revert with 0, 17
            if mem[_6189 + 64] and mem[_6248] > -1 / mem[_6189 + 64]:
                revert with 0, 17
            if mem[_6189 + 64] * mem[_6248] and block.timestamp - mem[_6189 + 96] > -1 / mem[_6189 + 64] * mem[_6248]:
                revert with 0, 17
            _6596 = mem[_6189 + 128]
            if mem[_6189 + 128] > !((block.timestamp * mem[_6189 + 64] * mem[_6248]) - (mem[_6189 + 96] * mem[_6189 + 64] * mem[_6248]) / 10000 / 24 * 3600):
                revert with 0, 17
            if mem[_6189 + 256] > 5:
                revert with 0, 33
            if mem[_6189 + 256] == 5:
                require ext_code.size(stor8)
                staticcall stor8.0xe5d76232 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6680 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600) and mem[_6680] > -1 / _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600):
                    revert with 0, 17
                if t > !(_6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600)):
                    revert with 0, 17
                if uint8(s) >= mem[96]:
                    revert with 0, 50
                _6829 = mem[(32 * uint8(s)) + 128]
                mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _6829
                mem[mem[64] + 36] = msg.sender
                require ext_code.size(stor8)
                call stor8.0x37c14e70 with:
                     gas gas_remaining wei
                    args _6829, msg.sender
            else:
                if mem[_6189 + 256] > 5:
                    revert with 0, 33
                require ext_code.size(stor8)
                if mem[_6189 + 256] != 4:
                    staticcall stor8.0xae55ae5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6684 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600) and mem[_6684] > -1 / _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6839 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6839
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6839, msg.sender
                else:
                    staticcall stor8.0x1ec4a4a8 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6685 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600) and mem[_6685] > -1 / _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600):
                        revert with 0, 17
                    if t > !(_6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600)):
                        revert with 0, 17
                    if uint8(s) >= mem[96]:
                        revert with 0, 50
                    _6851 = mem[(32 * uint8(s)) + 128]
                    mem[mem[64]] = 0x37c14e7000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = _6851
                    mem[mem[64] + 36] = msg.sender
                    require ext_code.size(stor8)
                    call stor8.0x37c14e70 with:
                         gas gas_remaining wei
                        args _6851, msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if uint8(s) >= mem[96]:
                revert with 0, 50
            mem[0] = mem[(32 * uint8(s)) + 128]
            mem[32] = 13
            if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0):
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + ((uint255(uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0)) * 0.5) + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            else:
                if bool(stor13[mem[(32 * uint8(s)) + 128]].field_0) == stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor13[mem[(32 * uint8(s)) + 128]].field_0) = 0
                if 31 < stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128:
                    mem[0] = sha3(mem[(32 * uint8(s)) + 128], 13)
                    v = sha3(sha3(mem[(32 * uint8(s)) + 128], 13))
                    while sha3(sha3(mem[(32 * uint8(s)) + 128], 13)) + (stor13[mem[(32 * uint8(s)) + 128]].field_1 % 128 + 31 / 32) > v:
                        uint256(stor[v].field_0) = 0
                        v = v + 1
                        continue 
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_256) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_512) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_768) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1024) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1280) = 0
            uint256(stor13[mem[(32 * uint8(s)) + 128]].field_1536) = 0
            uint16(stor13[mem[(32 * uint8(s)) + 128]].field_1792) = 0
            if uint8(s) == 255:
                revert with 0, 17
            s = uint8(s) + 1
            t = t + _6596 + ((block.timestamp * _6282 * _6261) - (_6295 * _6282 * _6261) / 10000 / 24 * 3600)
            u = u + _6146
            continue 
        _6100 = mem[64]
        mem[64] = mem[64] + ceil32(('cd', 4).length) + 320
        mem[_6100 + 288] = ('cd', 4).length
        mem[_6100 + 320 len ('cd', 4).length] = call.data[cd[4] + 36 len ('cd', 4).length]
        mem[_6100 + ('cd', 4).length + 320] = 0
        mem[_6100] = _6100 + 288
        mem[_6100 + 32] = 0
        mem[_6100 + 64] = u
        mem[_6100 + 96] = block.timestamp
        mem[_6100 + 128] = t
        mem[_6100 + 160] = u
        mem[_6100 + 192] = 0
        mem[_6100 + 224] = 0
        mem[_6100 + 256] = 5
        mem[mem[64]] = 0xa5a1fd2900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = 288
        mem[mem[64] + 356] = ('cd', 4).length
        mem[mem[64] + 388 len ceil32(('cd', 4).length)] = call.data[cd[4] + 36 len ('cd', 4).length], mem[_6100 + ('cd', 4).length + 320 len ceil32(('cd', 4).length) - ('cd', 4).length]
        var82001 = ceil32(('cd', 4).length)
        if ceil32(('cd', 4).length) <= ('cd', 4).length:
            mem[mem[64] + 100] = 0
            mem[mem[64] + 132] = u
            mem[mem[64] + 164] = block.timestamp
            mem[mem[64] + 196] = t
            mem[mem[64] + 228] = u
            mem[mem[64] + 260] = 0
            mem[mem[64] + 292] = 0
            mem[mem[64] + 324] = 5
            mem[mem[64] + 36] = msg.sender
            require ext_code.size(stor8)
            call stor8.0xa5a1fd29 with:
                 gas gas_remaining wei
                args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6939 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _6942 = mem[_6939]
            mem[0] = mem[_6939]
            mem[32] = 13
            _6944 = sha3(mem[0], 13)
            if bool(stor13[mem[0]].field_0):
                if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_6944)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_6944] = 0
                    stor2[_6944] = u
                    stor3[_6944] = block.timestamp
                    stor4[_6944] = t
                    stor5[_6944] = u
                    uint256(stor6[_6944]) = 0
                    uint256(stor7[_6944].field_0) = 0
                    Mask(248, 0, stor7[_6944].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _5462
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8515 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_6942] = mem[_8515]
                else:
                    uint256(stor[_6944].field_0) = 0
                    s = 0
                    while (uint255(uint256(stor[_6944].field_0)) * 0.5) + 31 / 32 > s:
                        uint256(stor[s + sha3(mem[0])].field_0) = 0
                        s = s + 1
                        continue 
                    stor1[_6944] = 0
                    stor2[_6944] = u
                    stor3[_6944] = block.timestamp
                    stor4[_6944] = t
                    stor5[_6944] = u
                    uint256(stor6[_6944]) = 0
                    uint256(stor7[_6944].field_0) = 0
                    Mask(248, 0, stor7[_6944].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    s = 0
                    t = _5462
                    v = mem[64] + 36
                    while s < 4:
                        mem[v] = mem[t + 31 len 1]
                        s = s + 1
                        t = t + 32
                        v = v + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7773 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_6942] = mem[_7773]
            else:
                if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[0], 13)
                if ('cd', 4).length:
                    uint256(stor[sha3(_6944)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                    stor1[_6944] = 0
                    stor2[_6944] = u
                    stor3[_6944] = block.timestamp
                    stor4[_6944] = t
                    stor5[_6944] = u
                    uint256(stor6[_6944]) = 0
                    uint256(stor7[_6944].field_0) = 0
                    Mask(248, 0, stor7[_6944].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _5462
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8516 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_6942] = mem[_8516]
                else:
                    uint256(stor[_6944].field_0) = 0
                    idx = 0
                    while stor[_6944].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor[idx + sha3(mem[0])].field_0) = 0
                        idx = idx + 1
                        continue 
                    stor1[_6944] = 0
                    stor2[_6944] = u
                    stor3[_6944] = block.timestamp
                    stor4[_6944] = t
                    stor5[_6944] = u
                    uint256(stor6[_6944]) = 0
                    uint256(stor7[_6944].field_0) = 0
                    Mask(248, 0, stor7[_6944].field_8) = 5
                    mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = u
                    idx = 0
                    s = _5462
                    t = mem[64] + 36
                    while idx < 4:
                        mem[t] = mem[s + 31 len 1]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(stor9)
                    staticcall stor9.0x90b82ddb with:
                            gas gas_remaining wei
                           args u, mem[mem[64] + 36 len 128]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7777 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    sub_ded2abc3[_6942] = mem[_7777]
            return _6942
        mem[('cd', 4).length + mem[64] + 388] = 0
        mem[mem[64] + 100] = 0
        mem[mem[64] + 132] = u
        mem[mem[64] + 164] = block.timestamp
        mem[mem[64] + 196] = t
        mem[mem[64] + 228] = u
        mem[mem[64] + 260] = 0
        mem[mem[64] + 292] = 0
        mem[mem[64] + 324] = 5
        mem[mem[64] + 36] = msg.sender
        require ext_code.size(stor8)
        call stor8.0xa5a1fd29 with:
             gas gas_remaining wei
            args 64, msg.sender, 288, 0, u, block.timestamp, t, u, 0, 0, 5, ('cd', 4).length, mem[mem[64] + 388 len ceil32(('cd', 4).length)]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _6940 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _6943 = mem[_6940]
        mem[0] = mem[_6940]
        mem[32] = 13
        _6947 = sha3(mem[0], 13)
        if bool(stor13[mem[0]].field_0):
            if bool(stor13[mem[0]].field_0) == uint255(uint256(stor13[mem[0]].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_6947)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_6947] = 0
                stor2[_6947] = u
                stor3[_6947] = block.timestamp
                stor4[_6947] = t
                stor5[_6947] = u
                uint256(stor6[_6947]) = 0
                uint256(stor7[_6947].field_0) = 0
                Mask(248, 0, stor7[_6947].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _5462
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8517 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_6943] = mem[_8517]
            else:
                uint256(stor[_6947].field_0) = 0
                s = 0
                while (uint255(uint256(stor[_6947].field_0)) * 0.5) + 31 / 32 > s:
                    uint256(stor[s + sha3(mem[0])].field_0) = 0
                    s = s + 1
                    continue 
                stor1[_6947] = 0
                stor2[_6947] = u
                stor3[_6947] = block.timestamp
                stor4[_6947] = t
                stor5[_6947] = u
                uint256(stor6[_6947]) = 0
                uint256(stor7[_6947].field_0) = 0
                Mask(248, 0, stor7[_6947].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                s = 0
                t = _5462
                v = mem[64] + 36
                while s < 4:
                    mem[v] = mem[t + 31 len 1]
                    s = s + 1
                    t = t + 32
                    v = v + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7781 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_6943] = mem[_7781]
        else:
            if bool(stor13[mem[0]].field_0) == stor13[mem[0]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[0], 13)
            if ('cd', 4).length:
                uint256(stor[sha3(_6947)][].field_0) = Array(len=('cd', 4).length, data=call.data[cd[4] + 36 len ('cd', 4).length])
                stor1[_6947] = 0
                stor2[_6947] = u
                stor3[_6947] = block.timestamp
                stor4[_6947] = t
                stor5[_6947] = u
                uint256(stor6[_6947]) = 0
                uint256(stor7[_6947].field_0) = 0
                Mask(248, 0, stor7[_6947].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _5462
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8518 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_6943] = mem[_8518]
            else:
                uint256(stor[_6947].field_0) = 0
                idx = 0
                while stor[_6947].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(mem[0])].field_0) = 0
                    idx = idx + 1
                    continue 
                stor1[_6947] = 0
                stor2[_6947] = u
                stor3[_6947] = block.timestamp
                stor4[_6947] = t
                stor5[_6947] = u
                uint256(stor6[_6947]) = 0
                uint256(stor7[_6947].field_0) = 0
                Mask(248, 0, stor7[_6947].field_8) = 5
                mem[mem[64]] = 0x90b82ddb00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = u
                idx = 0
                s = _5462
                t = mem[64] + 36
                while idx < 4:
                    mem[t] = mem[s + 31 len 1]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor9)
                staticcall stor9.0x90b82ddb with:
                        gas gas_remaining wei
                       args u, mem[mem[64] + 36 len 128]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7785 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                sub_ded2abc3[_6943] = mem[_7785]
        return _6943
}

function sub_335ce7a9(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    mem[ceil32(32 * ('cd', 4).length) + 101] = msg.sender
    require ext_code.size(address(stor7.length))
    staticcall address(stor7.length).Blacklisted(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[ceil32(32 * ('cd', 4).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if ext_call.return_data[0]:
        revert with 0, 'Blacklisted'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        if mem[(32 * idx) + 128] != 0:
            if idx >= mem[96]:
                revert with 0, 50
            _4696 = mem[(32 * idx) + 128]
            _4697 = mem[64]
            mem[64] = mem[64] + 288
            mem[_4697] = 96
            mem[_4697 + 32] = 0
            mem[_4697 + 64] = 0
            mem[_4697 + 96] = 0
            mem[_4697 + 128] = 0
            mem[_4697 + 160] = 0
            mem[_4697 + 192] = 0
            mem[_4697 + 224] = 0
            mem[_4697 + 256] = 0
            mem[0] = _4696
            mem[32] = 13
            if uint256(stor13[_4696].field_512):
                mem[0] = _4696
                mem[32] = 13
                _4700 = mem[64]
                mem[64] = mem[64] + 288
                if bool(stor13[_4696].field_0):
                    if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _4704 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor13[_4696].field_0)) * 0.5) + 32
                    mem[_4704] = uint255(uint256(stor13[_4696].field_0)) * 0.5
                    if bool(stor13[_4696].field_0):
                        if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor13[_4696].field_0)):
                            mem[_4700] = _4704
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5226 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5226] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5226]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5226]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5310 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5310] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5310]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5310]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5311 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5311] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5311]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5311]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5231 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5231] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5231]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5231]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5313 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5313] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5313]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5313]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5314 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5314] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5314]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5314]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5320 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5320] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5320]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5320]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5466 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5466] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5466]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5466]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5467 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5467] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5467]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5467]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5325 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5325] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5325]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5325]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5469 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5469] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5469]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5469]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5470 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5470] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5470]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5470]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5554 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5554] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5554]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5554]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5764 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5764] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5764]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5764]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5765 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5765] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5765]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5765]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5559 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5559] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5559]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5559]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5767 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5767] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5767]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5767]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5768 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5768] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5768]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5768]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4786 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4847 = mem[_4786]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4786] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4786] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4786]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4786]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4786]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6108 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600) and mem[_6108] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6108]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600 * mem[_6108]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6216 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600) and mem[_6216] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6216]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600 * mem[_6216]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6217 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600) and mem[_6217] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6217]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4847) / 10000 / 24 * 3600 * mem[_6217]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4786] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4786] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4786]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4786]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4786]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6113 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600) and mem[_6113] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6113]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600 * mem[_6113]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6219 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600) and mem[_6219] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6219]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600 * mem[_6219]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6220 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600) and mem[_6220] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6220]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4847) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4847) / 10000 / 24 * 3600 * mem[_6220]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= uint255(uint256(stor13[_4696].field_0)) * 0.5:
                                mem[_4704 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5336 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5336] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5336]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5336]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5486 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5486] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5486]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5486]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5487 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5487] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5487]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5487]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5341 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5341] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5341]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5341]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5489 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5489] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5489]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5489]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5490 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5490] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5490]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5490]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5496 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5496] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5496]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5496]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5682 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5682] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5682]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5682]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5683 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5683] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5683]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5683]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5501 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5501] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5501]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5501]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5685 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5685] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5685]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5685]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5686 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5686] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5686]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5686]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5778 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5778] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5778]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5778]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5974 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5974] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5974]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5974]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5975 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5975] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5975]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5975]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5783 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5783] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5783]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5783]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5977 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5977] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5977]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5977]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _5978 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5978] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5978]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5978]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4854 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4932 = mem[_4854]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4854] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4854] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4854]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4854]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4854]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6234 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600) and mem[_6234] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6234]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600 * mem[_6234]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6350 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600) and mem[_6350] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6350]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600 * mem[_6350]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6351 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600) and mem[_6351] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6351]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4932) / 10000 / 24 * 3600 * mem[_6351]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4854] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4854] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4854]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4854]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4854]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6239 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600) and mem[_6239] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6239]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600 * mem[_6239]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6353 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600) and mem[_6353] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6353]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600 * mem[_6353]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6354 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600) and mem[_6354] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6354]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4932) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4932) / 10000 / 24 * 3600 * mem[_6354]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4704 + 32] = uint256(stor13[_4696].field_0)
                                s = _4704 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4704 + (uint255(uint256(stor13[_4696].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7285 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7285] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7285]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7285]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7349 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7349] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7349]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7349]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7350 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7350] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7350]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7350]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7290 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7290] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7290]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7290]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7352 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7352] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7352]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7352]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7353 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7353] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7353]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7353]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7359 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7359] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7359]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7359]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7439 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7439] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7439]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7439]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7440 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7440] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7440]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7440]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7364 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7364] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7364]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7364]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7442 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7442] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7442]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7442]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7443 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7443] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7443]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7443]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7493 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7493] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7493]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7493]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7545 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7545] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7545]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7545]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7546 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7546] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7546]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7546]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7498 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7498] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7498]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7498]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7548 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7548] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7548]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7548]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7549 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7549] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7549]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7549]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7102 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7121 = mem[_7102]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7102] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7102] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7102]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7102]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7102]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7649 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600) and mem[_7649] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7649]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600 * mem[_7649]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7735 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600) and mem[_7735] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7735]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600 * mem[_7735]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7736 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600) and mem[_7736] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7736]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7121) / 10000 / 24 * 3600 * mem[_7736]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7102] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7102] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7102]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7102]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7102]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7654 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600) and mem[_7654] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7654]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600 * mem[_7654]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7738 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600) and mem[_7738] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7738]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600 * mem[_7738]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7739 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600) and mem[_7739] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7739]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7121) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7121) / 10000 / 24 * 3600 * mem[_7739]) / 10000):
                                                                revert with 0, 17
                    else:
                        if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor13[_4696].field_1 % 128:
                            mem[_4700] = _4704
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5270 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5270] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5270]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5270]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5382 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5382] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5382]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5382]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5383 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5383] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5383]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5383]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5275 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5275] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5275]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5275]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5385 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5385] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5385]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5385]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5386 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5386] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5386]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5386]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5392 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5392] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5392]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5392]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5572 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5572] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5572]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5572]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5573 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5573] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5573]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5573]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5397 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5397] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5397]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5397]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5575 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5575] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5575]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5575]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5576 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5576] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5576]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5576]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5692 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5692] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5692]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5692]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5880 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5880] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5880]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5880]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5881 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5881] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5881]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5881]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5697 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5697] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5697]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5697]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5883 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5883] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5883]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5883]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5884 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5884] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5884]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5884]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4821 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4896 = mem[_4821]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4821] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4821] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4821]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4821]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4821]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6166 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600) and mem[_6166] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6166]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600 * mem[_6166]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6280 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600) and mem[_6280] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6280]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600 * mem[_6280]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6281 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600) and mem[_6281] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6281]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4896) / 10000 / 24 * 3600 * mem[_6281]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4821] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4821] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4821]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4821]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4821]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6171 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600) and mem[_6171] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6171]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600 * mem[_6171]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6283 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600) and mem[_6283] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6283]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600 * mem[_6283]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6284 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600) and mem[_6284] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6284]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4896) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4896) / 10000 / 24 * 3600 * mem[_6284]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= stor13[_4696].field_1 % 128:
                                mem[_4704 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5408 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5408] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5408]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5408]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5592 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5592] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5592]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5592]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5593 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5593] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5593]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5593]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5413 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5413] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5413]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5413]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5595 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5595] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5595]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5595]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5596 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5596] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5596]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5596]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5602 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5602] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5602]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5602]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5810 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5810] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5810]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5810]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5811 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5811] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5811]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5811]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5607 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5607] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5607]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5607]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5813 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5813] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5813]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5813]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5814 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5814] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5814]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5814]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5894 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5894] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5894]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5894]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6058 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6058] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6058]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6058]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6059 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6059] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6059]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6059]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5899 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5899] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5899]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5899]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6061 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6061] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6061]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6061]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6062 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6062] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6062]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6062]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4903 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4961 = mem[_4903]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4903] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4903] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4903]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4903]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4903]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6298 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600) and mem[_6298] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6298]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600 * mem[_6298]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6424 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600) and mem[_6424] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6424]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600 * mem[_6424]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6425 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600) and mem[_6425] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6425]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4961) / 10000 / 24 * 3600 * mem[_6425]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4903] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4903] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4903]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4903]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4903]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6303 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600) and mem[_6303] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6303]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600 * mem[_6303]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6427 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600) and mem[_6427] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6427]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600 * mem[_6427]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6428 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600) and mem[_6428] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6428]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4961) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4961) / 10000 / 24 * 3600 * mem[_6428]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4704 + 32] = uint256(stor13[_4696].field_0)
                                s = _4704 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4704 + stor13[_4696].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4704
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7299 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7299] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7299]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7299]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7365 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7365] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7365]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7365]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7366 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7366] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7366]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7366]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7304 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7304] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7304]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7304]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7368 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7368] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7368]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7368]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7369 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7369] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7369]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7369]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7375 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7375] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7375]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7375]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7451 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7451] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7451]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7451]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7452 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7452] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7452]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7452]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7380 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7380] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7380]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7380]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7454 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7454] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7454]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7454]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7455 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7455] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7455]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7455]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7503 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7503] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7503]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7503]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7551 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7551] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7551]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7551]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7552 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7552] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7552]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7552]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7508 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7508] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7508]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7508]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7554 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7554] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7554]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7554]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7555 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7555] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7555]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7555]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7106 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7124 = mem[_7106]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7106] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7106] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7106]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7106]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7106]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7659 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600) and mem[_7659] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7659]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600 * mem[_7659]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7743 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600) and mem[_7743] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7743]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600 * mem[_7743]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7744 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600) and mem[_7744] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7744]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7124) / 10000 / 24 * 3600 * mem[_7744]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7106] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7106] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7106]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7106]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7106]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7664 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600) and mem[_7664] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7664]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600 * mem[_7664]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7746 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600) and mem[_7746] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7746]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600 * mem[_7746]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7747 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600) and mem[_7747] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7747]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7124) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7124) / 10000 / 24 * 3600 * mem[_7747]) / 10000):
                                                                revert with 0, 17
                else:
                    if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                        revert with 0, 34
                    _4706 = mem[64]
                    mem[64] = mem[64] + ceil32(stor13[_4696].field_1 % 128) + 32
                    mem[_4706] = stor13[_4696].field_1 % 128
                    if bool(stor13[_4696].field_0):
                        if bool(stor13[_4696].field_0) == uint255(uint256(stor13[_4696].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor13[_4696].field_0)):
                            mem[_4700] = _4706
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5290 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5290] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5290]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5290]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5418 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5418] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5418]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5418]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5419 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5419] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5419]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5419]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5295 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5295] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5295]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5295]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5421 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5421] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5421]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5421]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5422 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5422] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5422]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5422]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5428 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5428] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5428]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5428]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5614 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5614] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5614]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5614]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5615 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5615] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5615]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5615]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5433 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5433] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5433]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5433]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5617 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5617] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5617]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5617]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5618 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5618] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5618]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5618]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5708 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5708] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5708]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5708]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5900 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5900] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5900]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5900]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5901 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5901] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5901]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5901]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5713 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5713] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5713]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5713]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5903 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5903] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5903]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5903]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5904 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5904] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5904]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5904]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4830 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4908 = mem[_4830]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4830] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4830] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4830]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4830]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4830]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6190 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600) and mem[_6190] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6190]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600 * mem[_6190]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6306 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600) and mem[_6306] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6306]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600 * mem[_6306]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6307 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600) and mem[_6307] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6307]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4908) / 10000 / 24 * 3600 * mem[_6307]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4830] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4830] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4830]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4830]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4830]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6195 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600) and mem[_6195] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6195]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600 * mem[_6195]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6309 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600) and mem[_6309] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6309]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600 * mem[_6309]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6310 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600) and mem[_6310] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6310]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4908) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4908) / 10000 / 24 * 3600 * mem[_6310]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= uint255(uint256(stor13[_4696].field_0)) * 0.5:
                                mem[_4706 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5444 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5444] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5444]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5444]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5634 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5634] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5634]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5634]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5635 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5635] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5635]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5635]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5449 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5449] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5449]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5449]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5637 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5637] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5637]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5637]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5638 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5638] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5638]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5638]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5644 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5644] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5644]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5644]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5842 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5842] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5842]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5842]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5843 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5843] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5843]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5843]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5649 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5649] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5649]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5649]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5845 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5845] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5845]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5845]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5846 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5846] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5846]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5846]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5914 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5914] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5914]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5914]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6082 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6082] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6082]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6082]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6083 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6083] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6083]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6083]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5919 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5919] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5919]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5919]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6085 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6085] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6085]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6085]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6086 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6086] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6086]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6086]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4915 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4968 = mem[_4915]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4915] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4915] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4915]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4915]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4915]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6324 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600) and mem[_6324] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6324]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600 * mem[_6324]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6448 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600) and mem[_6448] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6448]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600 * mem[_6448]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6449 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600) and mem[_6449] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6449]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4968) / 10000 / 24 * 3600 * mem[_6449]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4915] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4915] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4915]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4915]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4915]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6329 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600) and mem[_6329] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6329]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600 * mem[_6329]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6451 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600) and mem[_6451] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6451]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600 * mem[_6451]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6452 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600) and mem[_6452] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6452]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4968) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4968) / 10000 / 24 * 3600 * mem[_6452]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4706 + 32] = uint256(stor13[_4696].field_0)
                                s = _4706 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4706 + (uint255(uint256(stor13[_4696].field_0)) * 0.5) > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7313 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7313] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7313]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7313]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7381 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7381] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7381]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7381]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7382 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7382] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7382]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7382]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7318 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7318] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7318]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7318]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7384 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7384] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7384]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7384]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7385 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7385] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7385]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7385]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7391 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7391] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7391]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7391]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7463 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7463] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7463]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7463]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7464 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7464] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7464]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7464]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7396 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7396] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7396]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7396]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7466 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7466] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7466]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7466]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7467 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7467] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7467]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7467]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7513 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7513] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7513]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7513]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7557 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7557] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7557]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7557]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7558 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7558] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7558]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7558]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7518 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7518] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7518]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7518]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7560 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7560] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7560]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7560]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7561 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7561] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7561]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7561]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7110 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7127 = mem[_7110]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7110] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7110] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7110]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7110]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7110]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7669 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7669] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7669]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7669]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7751 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7751] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7751]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7751]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7752 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600) and mem[_7752] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7752]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7127) / 10000 / 24 * 3600 * mem[_7752]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7110] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7110] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7110]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7110]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7110]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7674 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7674] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7674]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7674]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7754 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7754] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7754]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7754]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7755 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600) and mem[_7755] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7755]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7127) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7127) / 10000 / 24 * 3600 * mem[_7755]) / 10000):
                                                                revert with 0, 17
                    else:
                        if bool(stor13[_4696].field_0) == stor13[_4696].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor13[_4696].field_1 % 128:
                            mem[_4700] = _4706
                            mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                            mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                            mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                            mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                            mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                            mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                            if uint8(stor13[_4696].field_1792) > 5:
                                revert with 0, 33
                            mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) > 5:
                                revert with 0, 33
                            if uint8(stor13[_4696].field_1800) == 4:
                                if block.timestamp < uint256(stor13[_4696].field_768):
                                    revert with 0, 17
                                if uint8(stor13[_4696].field_1800) == 5:
                                    if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5354 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5354] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5354]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5354]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5514 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5514] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5514]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5514]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5515 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5515] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5515]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5515]) / 10000):
                                                    revert with 0, 17
                                else:
                                    if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                        revert with 0, 17
                                    if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5359 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5359] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5359]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5359]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if uint8(stor13[_4696].field_1800) != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5517 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5517] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5517]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5517]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5518 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5518] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5518]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5518]) / 10000):
                                                    revert with 0, 17
                            else:
                                if uint8(stor13[_4696].field_1800) != 5:
                                    if uint8(stor13[_4696].field_1800) > 5:
                                        revert with 0, 33
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5524 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5524] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5524]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5524]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5726 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5726] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5726]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5726]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5727 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5727] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5727]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5727]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5529 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5529] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5529]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5529]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5729 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5729] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5729]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5729]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5730 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5730] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5730]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5730]) / 10000):
                                                        revert with 0, 17
                                else:
                                    mem[0] = _4696
                                    mem[32] = 12
                                    if sub_ded2abc3[_4696]:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5852 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5852] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5852]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5852]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6012 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6012] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6012]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6012]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6013 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6013] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6013]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6013]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5857 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_5857] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5857]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_5857]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6015 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6015] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6015]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6015]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6016 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6016] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6016]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6016]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[mem[64] + 4] = _4696
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xded2abc3 with:
                                                gas gas_remaining wei
                                               args _4696
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4870 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _4943 = mem[_4870]
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and mem[_4870] > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * mem[_4870] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4870]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4870]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4870]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6248 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600) and mem[_6248] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6248]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600 * mem[_6248]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6370 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600) and mem[_6370] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6370]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600 * mem[_6370]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6371 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600) and mem[_6371] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6371]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4943) / 10000 / 24 * 3600 * mem[_6371]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and mem[_4870] > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * mem[_4870] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4870]:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4870]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4870]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _6253 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600) and mem[_6253] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6253]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600 * mem[_6253]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6373 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600) and mem[_6373] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6373]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600 * mem[_6373]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6374 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600) and mem[_6374] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6374]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4943) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4943) / 10000 / 24 * 3600 * mem[_6374]) / 10000):
                                                            revert with 0, 17
                        else:
                            if 31 >= stor13[_4696].field_1 % 128:
                                mem[_4706 + 32] = 256 * Mask(248, 0, stor13[_4696].field_8)
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5540 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5540] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5540]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5540]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5746 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5746] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5746]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5746]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5747 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_5747] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5747]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_5747]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5545 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5545] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5545]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5545]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5749 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5749] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5749]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5749]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5750 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_5750] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5750]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_5750]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5756 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5756] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5756]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5756]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5946 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5946] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5946]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5946]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5947 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_5947] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5947]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_5947]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _5761 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5761] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5761]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5761]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5949 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5949] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5949]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5949]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _5950 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_5950] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_5950]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_5950]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6026 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6026] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6026]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6026]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6154 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6154] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6154]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6154]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6155 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6155] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6155]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6155]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6031 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6031] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6031]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6031]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6157 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6157] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6157]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6157]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6158 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_6158] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6158]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_6158]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4950 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4987 = mem[_4950]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_4950] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_4950] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_4950]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_4950]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_4950]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6388 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600) and mem[_6388] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6388]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600 * mem[_6388]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6514 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600) and mem[_6514] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6514]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600 * mem[_6514]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6515 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600) and mem[_6515] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6515]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _4987) / 10000 / 24 * 3600 * mem[_6515]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_4950] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_4950] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_4950]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_4950]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_4950]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6393 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600) and mem[_6393] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6393]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600 * mem[_6393]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6517 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600) and mem[_6517] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6517]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600 * mem[_6517]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6518 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600) and mem[_6518] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_6518]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _4987) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _4987) / 10000 / 24 * 3600 * mem[_6518]) / 10000):
                                                                revert with 0, 17
                            else:
                                mem[0] = sha3(_4696, 13)
                                mem[_4706 + 32] = uint256(stor13[_4696].field_0)
                                s = _4706 + 32
                                t = sha3(sha3(_4696, 13))
                                while _4706 + stor13[_4696].field_1 % 128 > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                mem[_4700] = _4706
                                mem[_4700 + 32] = uint256(stor13[_4696].field_256)
                                mem[_4700 + 64] = uint256(stor13[_4696].field_512)
                                mem[_4700 + 96] = uint256(stor13[_4696].field_768)
                                mem[_4700 + 128] = uint256(stor13[_4696].field_1024)
                                mem[_4700 + 160] = uint256(stor13[_4696].field_1280)
                                mem[_4700 + 192] = uint256(stor13[_4696].field_1536)
                                if uint8(stor13[_4696].field_1792) > 5:
                                    revert with 0, 33
                                mem[_4700 + 224] = uint8(stor13[_4696].field_1792)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                mem[_4700 + 256] = uint8(stor13[_4696].field_1800)
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) > 5:
                                    revert with 0, 33
                                if uint8(stor13[_4696].field_1800) == 4:
                                    if block.timestamp < uint256(stor13[_4696].field_768):
                                        revert with 0, 17
                                    if uint8(stor13[_4696].field_1800) == 5:
                                        if uint256(stor13[_4696].field_1280) and stor5.length > -1 / uint256(stor13[_4696].field_1280):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1280) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7327 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7327] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7327]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7327]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7397 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7397] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7397]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7397]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7398 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600) and mem[_7398] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7398]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor5.length) / 10000 / 24 * 3600 * mem[_7398]) / 10000):
                                                        revert with 0, 17
                                    else:
                                        if uint256(stor13[_4696].field_512) and stor5.length > -1 / uint256(stor13[_4696].field_512):
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_512) * stor5.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor5.length:
                                            revert with 0, 17
                                        if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xe5d76232 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7332 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7332] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) > !stor3.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7332]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7332]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            require ext_code.size(stor8)
                                            if uint8(stor13[_4696].field_1800) != 4:
                                                staticcall stor8.0xae55ae5 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7400 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7400] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7400]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7400]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                staticcall stor8.0x1ec4a4a8 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7401 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600) and mem[_7401] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7401]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor5.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor5.length) / 10000 / 24 * 3600 * mem[_7401]) / 10000):
                                                        revert with 0, 17
                                else:
                                    if uint8(stor13[_4696].field_1800) != 5:
                                        if uint8(stor13[_4696].field_1800) > 5:
                                            revert with 0, 33
                                        if block.timestamp < uint256(stor13[_4696].field_768):
                                            revert with 0, 17
                                        if uint8(stor13[_4696].field_1800) == 5:
                                            if uint256(stor13[_4696].field_1280) and stor4.length > -1 / uint256(stor13[_4696].field_1280):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1280) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7407 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7407] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7407]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7407]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7475 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7475] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7475]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7475]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7476 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600) and mem[_7476] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7476]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * stor4.length) / 10000 / 24 * 3600 * mem[_7476]) / 10000):
                                                            revert with 0, 17
                                        else:
                                            if uint256(stor13[_4696].field_512) and stor4.length > -1 / uint256(stor13[_4696].field_512):
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_512) * stor4.length and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * stor4.length:
                                                revert with 0, 17
                                            if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                require ext_code.size(stor8)
                                                staticcall stor8.0xe5d76232 with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7412 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7412] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) > !stor3.length:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                    if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                        revert with 0, 17
                                                    if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7412]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7412]) / 10000):
                                                        revert with 0, 17
                                            else:
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                require ext_code.size(stor8)
                                                if uint8(stor13[_4696].field_1800) != 4:
                                                    staticcall stor8.0xae55ae5 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7478 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7478] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7478]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7478]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    staticcall stor8.0x1ec4a4a8 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7479 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600) and mem[_7479] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7479]) + ((block.timestamp * uint256(stor13[_4696].field_512) * stor4.length) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * stor4.length) / 10000 / 24 * 3600 * mem[_7479]) / 10000):
                                                            revert with 0, 17
                                    else:
                                        mem[0] = _4696
                                        mem[32] = 12
                                        if sub_ded2abc3[_4696]:
                                            mem[0] = _4696
                                            mem[32] = 12
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7523 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7523] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7523]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7523]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7563 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7563] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7563]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7563]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7564 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7564] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7564]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7564]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and sub_ded2abc3[_4696] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7528 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7528] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7528]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7528]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7566 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7566] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7566]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7566]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7567 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7567] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7567]) + ((block.timestamp * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7567]) / 10000):
                                                                revert with 0, 17
                                        else:
                                            mem[mem[64] + 4] = _4696
                                            require ext_code.size(stor8)
                                            staticcall stor8.0xded2abc3 with:
                                                    gas gas_remaining wei
                                                   args _4696
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7114 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7130 = mem[_7114]
                                            if uint8(stor13[_4696].field_1800) > 5:
                                                revert with 0, 33
                                            if block.timestamp < uint256(stor13[_4696].field_768):
                                                revert with 0, 17
                                            if uint8(stor13[_4696].field_1800) == 5:
                                                if uint256(stor13[_4696].field_1280) and mem[_7114] > -1 / uint256(stor13[_4696].field_1280):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1280) * mem[_7114] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_1280) * mem[_7114]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_1280) * mem[_7114]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * mem[_7114]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7679 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7679] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7679]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7679]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7759 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7759] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7759]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7759]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7760 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600) and mem[_7760] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7760]) + ((block.timestamp * uint256(stor13[_4696].field_1280) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_1280) * _7130) / 10000 / 24 * 3600 * mem[_7760]) / 10000):
                                                                revert with 0, 17
                                            else:
                                                if uint256(stor13[_4696].field_512) and mem[_7114] > -1 / uint256(stor13[_4696].field_512):
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_512) * mem[_7114] and block.timestamp - uint256(stor13[_4696].field_768) > -1 / uint256(stor13[_4696].field_512) * mem[_7114]:
                                                    revert with 0, 17
                                                if uint256(stor13[_4696].field_1024) > !((block.timestamp * uint256(stor13[_4696].field_512) * mem[_7114]) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * mem[_7114]) / 10000 / 24 * 3600):
                                                    revert with 0, 17
                                                if uint8(stor13[_4696].field_1800) > 5:
                                                    revert with 0, 33
                                                if uint8(stor13[_4696].field_1800) == 5:
                                                    require ext_code.size(stor8)
                                                    staticcall stor8.0xe5d76232 with:
                                                            gas gas_remaining wei
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7684 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7684] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) > !stor3.length:
                                                        revert with 0, 17
                                                    if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                        if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                            revert with 0, 17
                                                        if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7684]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7684]) / 10000):
                                                            revert with 0, 17
                                                else:
                                                    if uint8(stor13[_4696].field_1800) > 5:
                                                        revert with 0, 33
                                                    require ext_code.size(stor8)
                                                    if uint8(stor13[_4696].field_1800) != 4:
                                                        staticcall stor8.0xae55ae5 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7762 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7762] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7762]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7762]) / 10000):
                                                                revert with 0, 17
                                                    else:
                                                        staticcall stor8.0x1ec4a4a8 with:
                                                                gas gas_remaining wei
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _7763 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        if uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600) and mem[_7763] > -1 / uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600):
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) > !stor3.length:
                                                            revert with 0, 17
                                                        if uint256(stor13[_4696].field_768) + stor3.length <= block.timestamp:
                                                            if 0 > !(uint256(stor13[_4696].field_1024) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600)):
                                                                revert with 0, 17
                                                            if 0 > !((uint256(stor13[_4696].field_1024) * mem[_7763]) + ((block.timestamp * uint256(stor13[_4696].field_512) * _7130) - (uint256(stor13[_4696].field_768) * uint256(stor13[_4696].field_512) * _7130) / 10000 / 24 * 3600 * mem[_7763]) / 10000):
                                                                revert with 0, 17
            else:
                mem[mem[64]] = 0x36dac2cc00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = _4696
                require ext_code.size(stor8)
                staticcall stor8.0x36dac2cc with:
                        gas gas_remaining wei
                       args _4696
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4703 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4705 = mem[_4703]
                require mem[_4703] <= test266151307()
                require return_data.size - mem[_4703] >= 288
                if not bool(_4703 + ceil32(return_data.size) + 288 <= test266151307()):
                    revert with 0, 65
                mem[64] = _4703 + ceil32(return_data.size) + 288
                _4708 = mem[_4703 + _4705]
                require mem[_4703 + _4705] <= test266151307()
                require _4703 + _4705 + mem[_4703 + _4705] + 31 < _4703 + return_data.size
                _4713 = mem[_4703 + _4705 + mem[_4703 + _4705]]
                if mem[_4703 + _4705 + mem[_4703 + _4705]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289 < 288 or _4703 + ceil32(return_data.size) + ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289 > test266151307():
                    revert with 0, 65
                mem[64] = _4703 + ceil32(return_data.size) + ceil32(ceil32(mem[_4703 + _4705 + mem[_4703 + _4705]])) + 289
                mem[_4703 + ceil32(return_data.size) + 288] = _4713
                require _4705 + _4708 + _4713 + 32 <= return_data.size
                s = 0
                while s < _4713:
                    mem[s + _4703 + ceil32(return_data.size) + 320] = mem[s + _4703 + _4705 + _4708 + 32]
                    s = s + 32
                    continue 
                if ceil32(_4713) <= _4713:
                    mem[_4703 + ceil32(return_data.size)] = _4703 + ceil32(return_data.size) + 288
                    mem[_4703 + ceil32(return_data.size) + 32] = mem[_4703 + _4705 + 32]
                    mem[_4703 + ceil32(return_data.size) + 64] = mem[_4703 + _4705 + 64]
                    mem[_4703 + ceil32(return_data.size) + 96] = mem[_4703 + _4705 + 96]
                    mem[_4703 + ceil32(return_data.size) + 128] = mem[_4703 + _4705 + 128]
                    mem[_4703 + ceil32(return_data.size) + 160] = mem[_4703 + _4705 + 160]
                    mem[_4703 + ceil32(return_data.size) + 192] = mem[_4703 + _4705 + 192]
                    require mem[_4703 + _4705 + 224] < 6
                    mem[_4703 + ceil32(return_data.size) + 224] = mem[_4703 + _4705 + 224]
                    require mem[_4703 + _4705 + 256] < 6
                    mem[_4703 + ceil32(return_data.size) + 256] = mem[_4703 + _4705 + 256]
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] == 4:
                        if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                            _7147 = mem[_4703 + ceil32(return_data.size) + 160]
                            _7155 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor5.length:
                                revert with 0, 17
                            _7277 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7617 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600) and mem[_7617] > -1 / _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                    if 0 > !(_7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7277 * mem[_7617]) + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600 * mem[_7617]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7685 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600) and mem[_7685] > -1 / _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7277 * mem[_7685]) + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600 * mem[_7685]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7686 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600) and mem[_7686] > -1 / _7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7277 + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7277 * mem[_7686]) + ((block.timestamp * _7147 * stor5.length) - (_7155 * _7147 * stor5.length) / 10000 / 24 * 3600 * mem[_7686]) / 10000):
                                            revert with 0, 17
                        else:
                            _7148 = mem[_4703 + ceil32(return_data.size) + 64]
                            _7156 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor5.length:
                                revert with 0, 17
                            _7278 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7622 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600) and mem[_7622] > -1 / _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                    if 0 > !(_7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7278 * mem[_7622]) + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600 * mem[_7622]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7688 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600) and mem[_7688] > -1 / _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7278 * mem[_7688]) + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600 * mem[_7688]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7689 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600) and mem[_7689] > -1 / _7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7278 + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7278 * mem[_7689]) + ((block.timestamp * _7148 * stor5.length) - (_7156 * _7148 * stor5.length) / 10000 / 24 * 3600 * mem[_7689]) / 10000):
                                            revert with 0, 17
                    else:
                        if mem[_4703 + ceil32(return_data.size) + 256] != 5:
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                _7173 = mem[_4703 + ceil32(return_data.size) + 160]
                                _7187 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor4.length:
                                    revert with 0, 17
                                _7345 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7695 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600) and mem[_7695] > -1 / _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7345 * mem[_7695]) + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600 * mem[_7695]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7771 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600) and mem[_7771] > -1 / _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7345 * mem[_7771]) + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600 * mem[_7771]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7772 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600) and mem[_7772] > -1 / _7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7345 + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7345 * mem[_7772]) + ((block.timestamp * _7173 * stor4.length) - (_7187 * _7173 * stor4.length) / 10000 / 24 * 3600 * mem[_7772]) / 10000):
                                                revert with 0, 17
                            else:
                                _7174 = mem[_4703 + ceil32(return_data.size) + 64]
                                _7188 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor4.length:
                                    revert with 0, 17
                                _7346 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7700 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600) and mem[_7700] > -1 / _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7346 * mem[_7700]) + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600 * mem[_7700]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7774 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600) and mem[_7774] > -1 / _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7346 * mem[_7774]) + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600 * mem[_7774]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7775 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600) and mem[_7775] > -1 / _7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7346 + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7346 * mem[_7775]) + ((block.timestamp * _7174 * stor4.length) - (_7188 * _7174 * stor4.length) / 10000 / 24 * 3600 * mem[_7775]) / 10000):
                                                revert with 0, 17
                        else:
                            mem[0] = _4696
                            mem[32] = 12
                            if sub_ded2abc3[_4696]:
                                mem[0] = _4696
                                mem[32] = 12
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7193 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7199 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7481 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7809 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7809] > -1 / _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7481 * mem[_7809]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7809]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7865 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7865] > -1 / _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7481 * mem[_7865]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7865]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7866 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7866] > -1 / _7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7481 + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7481 * mem[_7866]) + ((block.timestamp * _7193 * sub_ded2abc3[_4696]) - (_7199 * _7193 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7866]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7194 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7200 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7482 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7814 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7814] > -1 / _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7482 * mem[_7814]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7814]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7868 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7868] > -1 / _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7482 * mem[_7868]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7868]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7869 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7869] > -1 / _7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7482 + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7482 * mem[_7869]) + ((block.timestamp * _7194 * sub_ded2abc3[_4696]) - (_7200 * _7194 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7869]) / 10000):
                                                    revert with 0, 17
                            else:
                                mem[mem[64] + 4] = _4696
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args _4696
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7186 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _7195 = mem[_7186]
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7229 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7249 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and mem[_7186] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]:
                                        revert with 0, 17
                                    _7641 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7186]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7921 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600) and mem[_7921] > -1 / _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7641 * mem[_7921]) + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600 * mem[_7921]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7943 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600) and mem[_7943] > -1 / _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7641 * mem[_7943]) + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600 * mem[_7943]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7944 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600) and mem[_7944] > -1 / _7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7641 + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7641 * mem[_7944]) + ((block.timestamp * _7229 * _7195) - (_7249 * _7229 * _7195) / 10000 / 24 * 3600 * mem[_7944]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7230 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7250 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and mem[_7186] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]:
                                        revert with 0, 17
                                    _7642 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7186]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7926 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600) and mem[_7926] > -1 / _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7642 * mem[_7926]) + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600 * mem[_7926]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7946 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600) and mem[_7946] > -1 / _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7642 * mem[_7946]) + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600 * mem[_7946]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600) and mem[_7947] > -1 / _7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7642 + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7642 * mem[_7947]) + ((block.timestamp * _7230 * _7195) - (_7250 * _7230 * _7195) / 10000 / 24 * 3600 * mem[_7947]) / 10000):
                                                    revert with 0, 17
                else:
                    mem[_4713 + _4703 + ceil32(return_data.size) + 320] = 0
                    mem[_4703 + ceil32(return_data.size)] = _4703 + ceil32(return_data.size) + 288
                    mem[_4703 + ceil32(return_data.size) + 32] = mem[_4703 + _4705 + 32]
                    mem[_4703 + ceil32(return_data.size) + 64] = mem[_4703 + _4705 + 64]
                    mem[_4703 + ceil32(return_data.size) + 96] = mem[_4703 + _4705 + 96]
                    mem[_4703 + ceil32(return_data.size) + 128] = mem[_4703 + _4705 + 128]
                    mem[_4703 + ceil32(return_data.size) + 160] = mem[_4703 + _4705 + 160]
                    mem[_4703 + ceil32(return_data.size) + 192] = mem[_4703 + _4705 + 192]
                    require mem[_4703 + _4705 + 224] < 6
                    mem[_4703 + ceil32(return_data.size) + 224] = mem[_4703 + _4705 + 224]
                    require mem[_4703 + _4705 + 256] < 6
                    mem[_4703 + ceil32(return_data.size) + 256] = mem[_4703 + _4705 + 256]
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                        revert with 0, 33
                    if mem[_4703 + ceil32(return_data.size) + 256] == 4:
                        if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                            _7151 = mem[_4703 + ceil32(return_data.size) + 160]
                            _7160 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 160] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor5.length:
                                revert with 0, 17
                            _7279 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7631 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600) and mem[_7631] > -1 / _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                    if 0 > !(_7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7279 * mem[_7631]) + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600 * mem[_7631]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7701 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600) and mem[_7701] > -1 / _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7279 * mem[_7701]) + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600 * mem[_7701]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7702 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600) and mem[_7702] > -1 / _7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7279 + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7279 * mem[_7702]) + ((block.timestamp * _7151 * stor5.length) - (_7160 * _7151 * stor5.length) / 10000 / 24 * 3600 * mem[_7702]) / 10000):
                                            revert with 0, 17
                        else:
                            _7152 = mem[_4703 + ceil32(return_data.size) + 64]
                            _7161 = mem[_4703 + ceil32(return_data.size) + 96]
                            if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] and stor5.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 64] * stor5.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor5.length:
                                revert with 0, 17
                            _7280 = mem[_4703 + ceil32(return_data.size) + 128]
                            if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor5.length) / 10000 / 24 * 3600):
                                revert with 0, 17
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                require ext_code.size(stor8)
                                staticcall stor8.0xe5d76232 with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7636 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600) and mem[_7636] > -1 / _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                    if 0 > !(_7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600)):
                                        revert with 0, 17
                                    if 0 > !((_7280 * mem[_7636]) + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600 * mem[_7636]) / 10000):
                                        revert with 0, 17
                            else:
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                require ext_code.size(stor8)
                                if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                    staticcall stor8.0xae55ae5 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7704 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600) and mem[_7704] > -1 / _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7280 * mem[_7704]) + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600 * mem[_7704]) / 10000):
                                            revert with 0, 17
                                else:
                                    staticcall stor8.0x1ec4a4a8 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7705 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600) and mem[_7705] > -1 / _7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7280 + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7280 * mem[_7705]) + ((block.timestamp * _7152 * stor5.length) - (_7161 * _7152 * stor5.length) / 10000 / 24 * 3600 * mem[_7705]) / 10000):
                                            revert with 0, 17
                    else:
                        if mem[_4703 + ceil32(return_data.size) + 256] != 5:
                            if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                revert with 0, 33
                            if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                _7175 = mem[_4703 + ceil32(return_data.size) + 160]
                                _7191 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 160] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * stor4.length:
                                    revert with 0, 17
                                _7347 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7711 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600) and mem[_7711] > -1 / _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7347 * mem[_7711]) + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600 * mem[_7711]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7783 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600) and mem[_7783] > -1 / _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7347 * mem[_7783]) + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600 * mem[_7783]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7784 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600) and mem[_7784] > -1 / _7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7347 + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7347 * mem[_7784]) + ((block.timestamp * _7175 * stor4.length) - (_7191 * _7175 * stor4.length) / 10000 / 24 * 3600 * mem[_7784]) / 10000):
                                                revert with 0, 17
                            else:
                                _7176 = mem[_4703 + ceil32(return_data.size) + 64]
                                _7192 = mem[_4703 + ceil32(return_data.size) + 96]
                                if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] and stor4.length > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 64] * stor4.length and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * stor4.length:
                                    revert with 0, 17
                                _7348 = mem[_4703 + ceil32(return_data.size) + 128]
                                if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * stor4.length) / 10000 / 24 * 3600):
                                    revert with 0, 17
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    require ext_code.size(stor8)
                                    staticcall stor8.0xe5d76232 with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7716 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600) and mem[_7716] > -1 / _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                        if 0 > !(_7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600)):
                                            revert with 0, 17
                                        if 0 > !((_7348 * mem[_7716]) + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600 * mem[_7716]) / 10000):
                                            revert with 0, 17
                                else:
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    require ext_code.size(stor8)
                                    if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                        staticcall stor8.0xae55ae5 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7786 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600) and mem[_7786] > -1 / _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7348 * mem[_7786]) + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600 * mem[_7786]) / 10000):
                                                revert with 0, 17
                                    else:
                                        staticcall stor8.0x1ec4a4a8 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7787 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600) and mem[_7787] > -1 / _7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7348 + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7348 * mem[_7787]) + ((block.timestamp * _7176 * stor4.length) - (_7192 * _7176 * stor4.length) / 10000 / 24 * 3600 * mem[_7787]) / 10000):
                                                revert with 0, 17
                        else:
                            mem[0] = _4696
                            mem[32] = 12
                            if sub_ded2abc3[_4696]:
                                mem[0] = _4696
                                mem[32] = 12
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7196 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7201 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7485 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7819 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7819] > -1 / _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7485 * mem[_7819]) + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7819]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7871 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7871] > -1 / _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7485 * mem[_7871]) + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7871]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7872 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7872] > -1 / _7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7485 + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7485 * mem[_7872]) + ((block.timestamp * _7196 * sub_ded2abc3[_4696]) - (_7201 * _7196 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7872]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7197 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7202 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and sub_ded2abc3[_4696] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]:
                                        revert with 0, 17
                                    _7486 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7824 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7824] > -1 / _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7486 * mem[_7824]) + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7824]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7874 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7874] > -1 / _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7486 * mem[_7874]) + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7874]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7875 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600) and mem[_7875] > -1 / _7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7486 + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7486 * mem[_7875]) + ((block.timestamp * _7197 * sub_ded2abc3[_4696]) - (_7202 * _7197 * sub_ded2abc3[_4696]) / 10000 / 24 * 3600 * mem[_7875]) / 10000):
                                                    revert with 0, 17
                            else:
                                mem[mem[64] + 4] = _4696
                                require ext_code.size(stor8)
                                staticcall stor8.0xded2abc3 with:
                                        gas gas_remaining wei
                                       args _4696
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _7190 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _7198 = mem[_7190]
                                if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                    revert with 0, 33
                                if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                    _7231 = mem[_4703 + ceil32(return_data.size) + 160]
                                    _7251 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] and mem[_7190] > -1 / mem[_4703 + ceil32(return_data.size) + 160]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 160] * mem[_7190] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 160] * mem[_7190]:
                                        revert with 0, 17
                                    _7643 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7190]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 160] * mem[_7190]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600) and mem[_7931] > -1 / _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7643 * mem[_7931]) + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600 * mem[_7931]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600) and mem[_7951] > -1 / _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7643 * mem[_7951]) + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600 * mem[_7951]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7952 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600) and mem[_7952] > -1 / _7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7643 + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7643 * mem[_7952]) + ((block.timestamp * _7231 * _7198) - (_7251 * _7231 * _7198) / 10000 / 24 * 3600 * mem[_7952]) / 10000):
                                                    revert with 0, 17
                                else:
                                    _7232 = mem[_4703 + ceil32(return_data.size) + 64]
                                    _7252 = mem[_4703 + ceil32(return_data.size) + 96]
                                    if block.timestamp < mem[_4703 + ceil32(return_data.size) + 96]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] and mem[_7190] > -1 / mem[_4703 + ceil32(return_data.size) + 64]:
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 64] * mem[_7190] and block.timestamp - mem[_4703 + ceil32(return_data.size) + 96] > -1 / mem[_4703 + ceil32(return_data.size) + 64] * mem[_7190]:
                                        revert with 0, 17
                                    _7644 = mem[_4703 + ceil32(return_data.size) + 128]
                                    if mem[_4703 + ceil32(return_data.size) + 128] > !((block.timestamp * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7190]) - (mem[_4703 + ceil32(return_data.size) + 96] * mem[_4703 + ceil32(return_data.size) + 64] * mem[_7190]) / 10000 / 24 * 3600):
                                        revert with 0, 17
                                    if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                        revert with 0, 33
                                    if mem[_4703 + ceil32(return_data.size) + 256] == 5:
                                        require ext_code.size(stor8)
                                        staticcall stor8.0xe5d76232 with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7936 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600) and mem[_7936] > -1 / _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600):
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                            revert with 0, 17
                                        if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                            if 0 > !(_7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600)):
                                                revert with 0, 17
                                            if 0 > !((_7644 * mem[_7936]) + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600 * mem[_7936]) / 10000):
                                                revert with 0, 17
                                    else:
                                        if mem[_4703 + ceil32(return_data.size) + 256] > 5:
                                            revert with 0, 33
                                        require ext_code.size(stor8)
                                        if mem[_4703 + ceil32(return_data.size) + 256] != 4:
                                            staticcall stor8.0xae55ae5 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7954 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600) and mem[_7954] > -1 / _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7644 * mem[_7954]) + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600 * mem[_7954]) / 10000):
                                                    revert with 0, 17
                                        else:
                                            staticcall stor8.0x1ec4a4a8 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7955 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600) and mem[_7955] > -1 / _7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600):
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] > !stor3.length:
                                                revert with 0, 17
                                            if mem[_4703 + ceil32(return_data.size) + 96] + stor3.length <= block.timestamp:
                                                if 0 > !(_7644 + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600)):
                                                    revert with 0, 17
                                                if 0 > !((_7644 * mem[_7955]) + ((block.timestamp * _7232 * _7198) - (_7252 * _7232 * _7198) / 10000 / 24 * 3600 * mem[_7955]) / 10000):
                                                    revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    revert with 0, 'Nothing to compound'
}



}

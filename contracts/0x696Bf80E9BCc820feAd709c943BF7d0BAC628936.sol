contract main {




// =====================  Runtime code  =====================


#
#  - uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#  - sub_272ec434(?)
#  - joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#  - pangolinCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#
const sub_c0da1e68(?) = ext_call.return_data[18 len 14], ext_call.return_data[32] << 144, ext_call.return_data[18 len 14], ext_call.return_data[32] << 144, ext_call.return_data[18 len 14], ext_call.return_data[32] << 144, ext_call.return_data[18 len 14], ext_call.return_data[32] << 144, ext_call.return_data[0]


address owner;

function owner() {
    return owner
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function recoverEth() {
    call owner with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function recoverToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args owner, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require 1 == bool(ext_call.return_data[0])
}

function getReserve(address arg1, address arg2, address arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require ext_code.size(arg1)
    staticcall arg1.getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    return ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
}

function sub_369e5867(?) {
    require calldata.size - 4 >= 96
    require arg2 == bool(arg2)
    require arg3 == address(arg3)
    mem[96] = 2
    mem[64] = 288
    mem[192] = 0
    mem[224] = 96
    mem[256] = 96
    mem[var16001] = 192
    s = var16001
    idx = var16002
    while idx - 1:
        mem[64] = mem[64] + 96
        mem[192] = 0
        mem[224] = 96
        mem[256] = 96
        mem[s + 32] = 192
        s = s + 32
        idx = idx - 1
        continue 
    if not arg2:
        _137 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        require 0 < mem[_137]
        mem[_137 + 32] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
        require 1 < mem[_137]
        mem[_137 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[_137 + 96] = address(arg3)
        mem[_137 + 128] = _137
        mem[_137 + 192] = 0
        mem[_137 + 160] = _137 + 192
        require mem[96]
        mem[128] = _137 + 96
        mem[_137 + 224] = 2
        mem[_137 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[_137 + 288] = 0x130966628846bfd36ff31a822705796e8cb8c18d
        mem[_137 + 320] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
        mem[_137 + 352] = _137 + 224
        mem[_137 + 416] = 0
        mem[64] = _137 + 448
        mem[_137 + 384] = _137 + 416
        require 1 < mem[96]
        mem[160] = _137 + 320
        if arg2:
            idx = mem[96]
            s = arg1
            while idx:
                require idx - 1 < mem[96]
                _275 = mem[(32 * idx - 1) + 128]
                _276 = mem[mem[(32 * idx - 1) + 128]]
                _277 = mem[mem[(32 * idx - 1) + 128] + 32]
                _278 = mem[64]
                mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = s
                mem[mem[64] + 36] = 64
                _293 = mem[_277]
                mem[mem[64] + 68] = mem[_277]
                s = 0
                t = _277 + 32
                u = mem[64] + 100
                while s < _293:
                    mem[u] = mem[t + 12 len 20]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                require ext_code.size(address(_276))
                staticcall address(_276).mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _278 + (32 * _293) + -mem[64] + 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _420 = mem[_409]
                require mem[_409] <= test266151307()
                require _409 + return_data.size > _409 + mem[_409] + 31
                _427 = mem[_409 + mem[_409]]
                if mem[_409 + mem[_409]] <= test266151307():
                    if (32 * mem[_409 + mem[_409]]) + 32 >= 0 and _409 + ceil32(return_data.size) + (32 * mem[_409 + mem[_409]]) + 32 <= test266151307():
                        mem[64] = _409 + ceil32(return_data.size) + (32 * mem[_409 + mem[_409]]) + 32
                        mem[_409 + ceil32(return_data.size)] = _427
                        require return_data.size >= _420 + (32 * _427) + 32
                        t = _409 + _420 + 32
                        u = _409 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _427:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                        mem[_275 + 64] = _409 + ceil32(return_data.size)
                        if _427:
                            t = _409 + _420 + (32 * _427) + 31
                            s = mem[_409 + ceil32(return_data.size) + 32]
                            continue 
                revert
            _291 = mem[64]
            mem[mem[64]] = 32
            _297 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _297:
                mem[u] = t + -_291 - 64
                _375 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                _377 = mem[_375 + 32]
                mem[t + 32] = 96
                _391 = mem[_377]
                mem[t + 96] = mem[_377]
                v = 0
                w = _377 + 32
                x = t + 128
                while v < _391:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _455 = mem[_375 + 64]
                mem[t + 64] = (32 * _391) + 128
                _456 = mem[_455]
                mem[t + (32 * _391) + 128] = mem[_455]
                w = t + (32 * _391) + 160
                v = 0
                x = _455 + 32
                while v < _456:
                    mem[w] = mem[x]
                    w = w + 32
                    v = v + 1
                    x = x + 32
                    continue 
                idx = idx + 1
                s = s + 32
                t = t + (32 * _391) + (32 * _456) + 160
                u = u + 32
                continue 
        else:
            _269 = mem[96]
            idx = 0
            s = arg1
            while idx < _269:
                require idx < mem[96]
                _279 = mem[(32 * idx) + 128]
                _280 = mem[mem[(32 * idx) + 128]]
                _281 = mem[mem[(32 * idx) + 128] + 32]
                _282 = mem[64]
                mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = s
                mem[mem[64] + 36] = 64
                _294 = mem[_281]
                mem[mem[64] + 68] = mem[_281]
                s = 0
                t = _281 + 32
                u = mem[64] + 100
                while s < _294:
                    mem[u] = mem[t + 12 len 20]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                require ext_code.size(address(_280))
                staticcall address(_280).mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _282 + (32 * _294) + -mem[64] + 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _412 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _422 = mem[_412]
                require mem[_412] <= test266151307()
                require _412 + return_data.size > _412 + mem[_412] + 31
                _428 = mem[_412 + mem[_412]]
                if mem[_412 + mem[_412]] <= test266151307():
                    if (32 * mem[_412 + mem[_412]]) + 32 >= 0 and _412 + ceil32(return_data.size) + (32 * mem[_412 + mem[_412]]) + 32 <= test266151307():
                        mem[64] = _412 + ceil32(return_data.size) + (32 * mem[_412 + mem[_412]]) + 32
                        mem[_412 + ceil32(return_data.size)] = _428
                        require return_data.size >= _422 + (32 * _428) + 32
                        t = _412 + _422 + 32
                        u = _412 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _428:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                        mem[_279 + 64] = _412 + ceil32(return_data.size)
                        if _428 - 1 < _428:
                            t = _412 + _422 + (32 * _428) + 33
                            s = mem[(32 * _428 - 1) + _412 + ceil32(return_data.size) + 32]
                            continue 
                revert
            _298 = mem[64]
            mem[mem[64]] = 32
            _308 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _308:
                mem[u] = t + -_298 - 64
                _379 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                _381 = mem[_379 + 32]
                mem[t + 32] = 96
                _392 = mem[_381]
                mem[t + 96] = mem[_381]
                v = 0
                w = _381 + 32
                x = t + 128
                while v < _392:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _458 = mem[_379 + 64]
                mem[t + 64] = (32 * _392) + 128
                _459 = mem[_458]
                mem[t + (32 * _392) + 128] = mem[_458]
                w = t + (32 * _392) + 160
                v = 0
                x = _458 + 32
                while v < _459:
                    mem[w] = mem[x]
                    w = w + 32
                    v = v + 1
                    x = x + 32
                    continue 
                idx = idx + 1
                s = s + 32
                t = t + (32 * _392) + (32 * _459) + 160
                u = u + 32
                continue 
    else:
        _139 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        require 0 < mem[_139]
        mem[_139 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
        require 1 < mem[_139]
        mem[_139 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[_139 + 96] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
        mem[_139 + 128] = _139
        mem[_139 + 192] = 0
        mem[_139 + 160] = _139 + 192
        require mem[96]
        mem[128] = _139 + 96
        mem[_139 + 224] = 2
        mem[_139 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        mem[_139 + 288] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
        mem[_139 + 320] = address(arg3)
        mem[_139 + 352] = _139 + 224
        mem[_139 + 416] = 0
        mem[64] = _139 + 448
        mem[_139 + 384] = _139 + 416
        require 1 < mem[96]
        mem[160] = _139 + 320
        if arg2:
            idx = mem[96]
            s = arg1
            while idx:
                require idx - 1 < mem[96]
                _283 = mem[(32 * idx - 1) + 128]
                _284 = mem[mem[(32 * idx - 1) + 128]]
                _285 = mem[mem[(32 * idx - 1) + 128] + 32]
                mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = s
                mem[mem[64] + 36] = 64
                _295 = mem[_285]
                mem[mem[64] + 68] = mem[_285]
                t = 0
                u = _285 + 32
                v = mem[64] + 100
                while t < _295:
                    mem[v] = mem[u + 12 len 20]
                    t = t + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(address(_284))
                staticcall address(_284).getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s, 64, mem[mem[64] + 68 len (32 * _295) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _415 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _424 = mem[_415]
                require mem[_415] <= test266151307()
                require _415 + return_data.size > _415 + mem[_415] + 31
                _429 = mem[_415 + mem[_415]]
                if mem[_415 + mem[_415]] <= test266151307():
                    if (32 * mem[_415 + mem[_415]]) + 32 >= 0 and _415 + ceil32(return_data.size) + (32 * mem[_415 + mem[_415]]) + 32 <= test266151307():
                        mem[64] = _415 + ceil32(return_data.size) + (32 * mem[_415 + mem[_415]]) + 32
                        mem[_415 + ceil32(return_data.size)] = _429
                        require return_data.size >= _424 + (32 * _429) + 32
                        t = _415 + _424 + 32
                        u = _415 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _429:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                        mem[_283 + 64] = _415 + ceil32(return_data.size)
                        if _429:
                            t = _415 + _424 + (32 * _429) + 31
                            s = mem[_415 + ceil32(return_data.size) + 32]
                            continue 
                revert
            _292 = mem[64]
            mem[mem[64]] = 32
            _299 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _299:
                mem[u] = t + -_292 - 64
                _383 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                _385 = mem[_383 + 32]
                mem[t + 32] = 96
                _393 = mem[_385]
                mem[t + 96] = mem[_385]
                v = 0
                w = _385 + 32
                x = t + 128
                while v < _393:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _461 = mem[_383 + 64]
                mem[t + 64] = (32 * _393) + 128
                _462 = mem[_461]
                mem[t + (32 * _393) + 128] = mem[_461]
                w = t + (32 * _393) + 160
                v = 0
                x = _461 + 32
                while v < _462:
                    mem[w] = mem[x]
                    w = w + 32
                    v = v + 1
                    x = x + 32
                    continue 
                idx = idx + 1
                s = s + 32
                t = t + (32 * _393) + (32 * _462) + 160
                u = u + 32
                continue 
        else:
            _270 = mem[96]
            idx = 0
            s = arg1
            while idx < _270:
                require idx < mem[96]
                _287 = mem[(32 * idx) + 128]
                _288 = mem[mem[(32 * idx) + 128]]
                _289 = mem[mem[(32 * idx) + 128] + 32]
                _290 = mem[64]
                mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = s
                mem[mem[64] + 36] = 64
                _296 = mem[_289]
                mem[mem[64] + 68] = mem[_289]
                s = 0
                t = _289 + 32
                u = mem[64] + 100
                while s < _296:
                    mem[u] = mem[t + 12 len 20]
                    s = s + 1
                    t = t + 32
                    u = u + 32
                    continue 
                require ext_code.size(address(_288))
                staticcall address(_288).mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _290 + (32 * _296) + -mem[64] + 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _418 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _426 = mem[_418]
                require mem[_418] <= test266151307()
                require _418 + return_data.size > _418 + mem[_418] + 31
                _430 = mem[_418 + mem[_418]]
                if mem[_418 + mem[_418]] <= test266151307():
                    if (32 * mem[_418 + mem[_418]]) + 32 >= 0 and _418 + ceil32(return_data.size) + (32 * mem[_418 + mem[_418]]) + 32 <= test266151307():
                        mem[64] = _418 + ceil32(return_data.size) + (32 * mem[_418 + mem[_418]]) + 32
                        mem[_418 + ceil32(return_data.size)] = _430
                        require return_data.size >= _426 + (32 * _430) + 32
                        t = _418 + _426 + 32
                        u = _418 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _430:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                        mem[_287 + 64] = _418 + ceil32(return_data.size)
                        if _430 - 1 < _430:
                            t = _418 + _426 + (32 * _430) + 33
                            s = mem[(32 * _430 - 1) + _418 + ceil32(return_data.size) + 32]
                            continue 
                revert
            _300 = mem[64]
            mem[mem[64]] = 32
            _312 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + (32 * mem[96]) + 64
            u = mem[64] + 64
            while idx < _312:
                mem[u] = t + -_300 - 64
                _387 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                _389 = mem[_387 + 32]
                mem[t + 32] = 96
                _394 = mem[_389]
                mem[t + 96] = mem[_389]
                v = 0
                w = _389 + 32
                x = t + 128
                while v < _394:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _464 = mem[_387 + 64]
                mem[t + 64] = (32 * _394) + 128
                _465 = mem[_464]
                mem[t + (32 * _394) + 128] = mem[_464]
                w = t + (32 * _394) + 160
                v = 0
                x = _464 + 32
                while v < _465:
                    mem[w] = mem[x]
                    w = w + 32
                    v = v + 1
                    x = x + 32
                    continue 
                idx = idx + 1
                s = s + 32
                t = t + (32 * _394) + (32 * _465) + 160
                u = u + 32
                continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function sub_d0453d1e(?) {
    require calldata.size - 4 >= 96
    require arg2 == bool(arg2)
    require arg3 == address(arg3)
    mem[96] = 2
    mem[64] = 288
    mem[192] = 0
    mem[224] = 96
    mem[256] = 96
    mem[var17001] = 192
    s = var17001
    idx = var17002
    while idx - 1:
        mem[64] = mem[64] + 96
        mem[192] = 0
        mem[224] = 96
        mem[256] = 96
        mem[s + 32] = 192
        s = s + 32
        idx = idx - 1
        continue 
    if not arg2:
        _2901 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 < mem[_2901]:
            mem[_2901 + 32] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
            if 1 < mem[_2901]:
                mem[_2901 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[_2901 + 96] = address(arg3)
                mem[_2901 + 128] = _2901
                mem[_2901 + 192] = 0
                mem[_2901 + 160] = _2901 + 192
                if mem[96]:
                    mem[128] = _2901 + 96
                    mem[_2901 + 224] = 2
                    mem[_2901 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[_2901 + 288] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                    mem[_2901 + 320] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
                    mem[_2901 + 352] = _2901 + 224
                    mem[_2901 + 416] = 0
                    mem[64] = _2901 + 448
                    mem[_2901 + 384] = _2901 + 416
                    if 1 < mem[96]:
                        mem[160] = _2901 + 320
                        if arg2:
                            idx = mem[96]
                            s = arg1
                            while idx:
                                require idx - 1 < mem[96]
                                _5803 = mem[(32 * idx - 1) + 128]
                                _5804 = mem[mem[(32 * idx - 1) + 128]]
                                _5805 = mem[mem[(32 * idx - 1) + 128] + 32]
                                mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = s
                                mem[mem[64] + 36] = 64
                                _5820 = mem[_5805]
                                mem[mem[64] + 68] = mem[_5805]
                                t = 0
                                u = _5805 + 32
                                v = mem[64] + 100
                                while t < _5820:
                                    mem[v] = mem[u + 12 len 20]
                                    t = t + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(address(_5804))
                                staticcall address(_5804).getAmountsIn(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args s, 64, mem[mem[64] + 68 len (32 * _5820) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8779 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8831 = mem[_8779]
                                require mem[_8779] <= test266151307()
                                require _8779 + return_data.size > _8779 + mem[_8779] + 31
                                _8867 = mem[_8779 + mem[_8779]]
                                if mem[_8779 + mem[_8779]] <= test266151307():
                                    if (32 * mem[_8779 + mem[_8779]]) + 32 >= 0 and _8779 + ceil32(return_data.size) + (32 * mem[_8779 + mem[_8779]]) + 32 <= test266151307():
                                        mem[64] = _8779 + ceil32(return_data.size) + (32 * mem[_8779 + mem[_8779]]) + 32
                                        mem[_8779 + ceil32(return_data.size)] = _8867
                                        require return_data.size >= _8831 + (32 * _8867) + 32
                                        t = _8779 + _8831 + 32
                                        u = _8779 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _8867:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[_5803 + 64] = _8779 + ceil32(return_data.size)
                                        if _8867:
                                            t = _8779 + _8831 + (32 * _8867) + 31
                                            s = mem[_8779 + ceil32(return_data.size) + 32]
                                            continue 
                                revert
                            _5819 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5819 + 32 len 64] = call.data[calldata.size len 64]
                            if not arg2:
                                require mem[96] - 1 < mem[96]
                                require mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1 < mem[mem[mem[(32 * mem[96] - 1) + 128] + 64]]
                                _5853 = mem[(32 * mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1) + mem[mem[(32 * mem[96] - 1) + 128] + 64] + 32]
                                mem[_5819 + 100] = arg1
                                require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[_5819 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5819 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require 0 < mem[_5819]
                                mem[_5819 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                require 1 < mem[_5819]
                                mem[_5819 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                if mem[_5819] < 2:
                                    revert with 0, 
                                                32,
                                                34,
                                                0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                mem[_5819 + ceil32(return_data.size) + 198 len 30]
                                _5951 = mem[_5819]
                                require mem[_5819] <= test266151307()
                                mem[_5819 + ceil32(return_data.size) + 96] = mem[_5819]
                                mem[64] = _5819 + ceil32(return_data.size) + (32 * mem[_5819]) + 128
                                if not _5951:
                                    require mem[_5819 + ceil32(return_data.size) + 96] - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5819 + ceil32(return_data.size) + 96] - 1) + _5819 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5819] - 1
                                    while idx:
                                        require idx - 1 < mem[_5819]
                                        _8696 = mem[(32 * idx - 1) + _5819 + 32]
                                        require idx < mem[_5819]
                                        _8744 = mem[(32 * idx) + _5819 + 32]
                                        if mem[(32 * idx - 1) + _5819 + 44 len 20] == mem[(32 * idx) + _5819 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5819 + 44 len 20] < mem[(32 * idx) + _5819 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5819 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5819 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8744)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8696) == address(_8696):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5819 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5819 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8744)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8744) == address(_8696):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                else:
                                    mem[_5819 + ceil32(return_data.size) + 128 len 32 * _5951] = call.data[calldata.size len 32 * _5951]
                                    require mem[_5819 + ceil32(return_data.size) + 96] - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5819 + ceil32(return_data.size) + 96] - 1) + _5819 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5819] - 1
                                    while idx:
                                        require idx - 1 < mem[_5819]
                                        _8699 = mem[(32 * idx - 1) + _5819 + 32]
                                        require idx < mem[_5819]
                                        _8746 = mem[(32 * idx) + _5819 + 32]
                                        if mem[(32 * idx - 1) + _5819 + 44 len 20] == mem[(32 * idx) + _5819 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5819 + 44 len 20] < mem[(32 * idx) + _5819 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5819 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5819 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8746)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8699) == address(_8699):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5819 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5819 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8746)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8746) == address(_8699):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5819 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                require 0 < mem[_5819 + ceil32(return_data.size) + 96]
                                mem[mem[64]] = mem[_5819 + ceil32(return_data.size) + 128]
                                return mem[mem[64]], _5853
                            if 0 < mem[96]:
                                if 0 < mem[mem[mem[128] + 64]]:
                                    _5855 = mem[mem[mem[128] + 64] + 32]
                                    mem[_5819 + 100] = arg1
                                    require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                    staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[_5819 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5819 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    if 0 < mem[_5819]:
                                        mem[_5819 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                        if 1 < mem[_5819]:
                                            mem[_5819 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                            if mem[_5819] < 2:
                                                revert with 0, 
                                                            32,
                                                            34,
                                                            0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                            mem[_5819 + ceil32(return_data.size) + 198 len 30]
                                            _5954 = mem[_5819]
                                            require mem[_5819] <= test266151307()
                                            mem[_5819 + ceil32(return_data.size) + 96] = mem[_5819]
                                            mem[64] = _5819 + ceil32(return_data.size) + (32 * mem[_5819]) + 128
                                            if not _5954:
                                                if 0 < mem[_5819 + ceil32(return_data.size) + 96]:
                                                    mem[_5819 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8667 = mem[_5819]
                                                    idx = 0
                                                    while idx < _8667 - 1:
                                                        require idx < mem[_5819]
                                                        _8702 = mem[(32 * idx) + _5819 + 32]
                                                        require idx + 1 < mem[_5819]
                                                        _8748 = mem[(32 * idx + 1) + _5819 + 32]
                                                        if mem[(32 * idx) + _5819 + 44 len 20] == mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5819 + 44 len 20] < mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5819 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5819 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8748)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8702) == address(_8702):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5819 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8748)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8748) == address(_8702):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5819 + ceil32(return_data.size) + 96]:
                                                        return _5855, mem[_5819 + ceil32(return_data.size) + 160]
                                            else:
                                                mem[_5819 + ceil32(return_data.size) + 128 len 32 * _5954] = call.data[calldata.size len 32 * _5954]
                                                if 0 < mem[_5819 + ceil32(return_data.size) + 96]:
                                                    mem[_5819 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8668 = mem[_5819]
                                                    idx = 0
                                                    while idx < _8668 - 1:
                                                        require idx < mem[_5819]
                                                        _8705 = mem[(32 * idx) + _5819 + 32]
                                                        require idx + 1 < mem[_5819]
                                                        _8750 = mem[(32 * idx + 1) + _5819 + 32]
                                                        if mem[(32 * idx) + _5819 + 44 len 20] == mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5819 + 44 len 20] < mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5819 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5819 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8750)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8705) == address(_8705):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5819 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5819 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8750)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5819 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8750) == address(_8705):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5819 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5819 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5819 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5819 + ceil32(return_data.size) + 96]:
                                                        return _5855, mem[_5819 + ceil32(return_data.size) + 160]
                        else:
                            _5797 = mem[96]
                            idx = 0
                            s = arg1
                            while idx < _5797:
                                require idx < mem[96]
                                _5807 = mem[(32 * idx) + 128]
                                _5808 = mem[mem[(32 * idx) + 128]]
                                _5809 = mem[mem[(32 * idx) + 128] + 32]
                                _5810 = mem[64]
                                mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = s
                                mem[mem[64] + 36] = 64
                                _5821 = mem[_5809]
                                mem[mem[64] + 68] = mem[_5809]
                                s = 0
                                t = _5809 + 32
                                u = mem[64] + 100
                                while s < _5821:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(address(_5808))
                                staticcall address(_5808).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _5810 + (32 * _5821) + -mem[64] + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8780 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8832 = mem[_8780]
                                require mem[_8780] <= test266151307()
                                require _8780 + return_data.size > _8780 + mem[_8780] + 31
                                _8884 = mem[_8780 + mem[_8780]]
                                if mem[_8780 + mem[_8780]] <= test266151307():
                                    if (32 * mem[_8780 + mem[_8780]]) + 32 >= 0 and _8780 + ceil32(return_data.size) + (32 * mem[_8780 + mem[_8780]]) + 32 <= test266151307():
                                        mem[64] = _8780 + ceil32(return_data.size) + (32 * mem[_8780 + mem[_8780]]) + 32
                                        mem[_8780 + ceil32(return_data.size)] = _8884
                                        require return_data.size >= _8832 + (32 * _8884) + 32
                                        t = _8780 + _8832 + 32
                                        u = _8780 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _8884:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[_5807 + 64] = _8780 + ceil32(return_data.size)
                                        if _8884 - 1 < _8884:
                                            t = _8780 + _8832 + (32 * _8884) + 33
                                            s = mem[(32 * _8884 - 1) + _8780 + ceil32(return_data.size) + 32]
                                            continue 
                                revert
                            _5840 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5840 + 32 len 64] = call.data[calldata.size len 64]
                            if not arg2:
                                require mem[96] - 1 < mem[96]
                                require mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1 < mem[mem[mem[(32 * mem[96] - 1) + 128] + 64]]
                                _5889 = mem[(32 * mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1) + mem[mem[(32 * mem[96] - 1) + 128] + 64] + 32]
                                mem[_5840 + 100] = arg1
                                require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[_5840 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5840 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require 0 < mem[_5840]
                                mem[_5840 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                require 1 < mem[_5840]
                                mem[_5840 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                if mem[_5840] < 2:
                                    revert with 0, 
                                                32,
                                                34,
                                                0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                mem[_5840 + ceil32(return_data.size) + 198 len 30]
                                _5978 = mem[_5840]
                                require mem[_5840] <= test266151307()
                                mem[_5840 + ceil32(return_data.size) + 96] = mem[_5840]
                                mem[64] = _5840 + ceil32(return_data.size) + (32 * mem[_5840]) + 128
                                if not _5978:
                                    require mem[_5840 + ceil32(return_data.size) + 96] - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5840 + ceil32(return_data.size) + 96] - 1) + _5840 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5840] - 1
                                    while idx:
                                        require idx - 1 < mem[_5840]
                                        _8708 = mem[(32 * idx - 1) + _5840 + 32]
                                        require idx < mem[_5840]
                                        _8753 = mem[(32 * idx) + _5840 + 32]
                                        if mem[(32 * idx - 1) + _5840 + 44 len 20] == mem[(32 * idx) + _5840 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5840 + 44 len 20] < mem[(32 * idx) + _5840 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5840 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5840 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8753)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8708) == address(_8708):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5840 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5840 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8753)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8753) == address(_8708):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                else:
                                    mem[_5840 + ceil32(return_data.size) + 128 len 32 * _5978] = call.data[calldata.size len 32 * _5978]
                                    require mem[_5840 + ceil32(return_data.size) + 96] - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5840 + ceil32(return_data.size) + 96] - 1) + _5840 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5840] - 1
                                    while idx:
                                        require idx - 1 < mem[_5840]
                                        _8711 = mem[(32 * idx - 1) + _5840 + 32]
                                        require idx < mem[_5840]
                                        _8755 = mem[(32 * idx) + _5840 + 32]
                                        if mem[(32 * idx - 1) + _5840 + 44 len 20] == mem[(32 * idx) + _5840 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5840 + 44 len 20] < mem[(32 * idx) + _5840 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5840 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5840 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8755)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8711) == address(_8711):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5840 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5840 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8755)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8755) == address(_8711):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5840 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                require 0 < mem[_5840 + ceil32(return_data.size) + 96]
                                mem[mem[64]] = mem[_5840 + ceil32(return_data.size) + 128]
                                return mem[mem[64]], _5889
                            if 0 < mem[96]:
                                if 0 < mem[mem[mem[128] + 64]]:
                                    _5891 = mem[mem[mem[128] + 64] + 32]
                                    mem[_5840 + 100] = arg1
                                    require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                    staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[_5840 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5840 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    if 0 < mem[_5840]:
                                        mem[_5840 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                        if 1 < mem[_5840]:
                                            mem[_5840 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                            if mem[_5840] < 2:
                                                revert with 0, 
                                                            32,
                                                            34,
                                                            0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                            mem[_5840 + ceil32(return_data.size) + 198 len 30]
                                            _5981 = mem[_5840]
                                            require mem[_5840] <= test266151307()
                                            mem[_5840 + ceil32(return_data.size) + 96] = mem[_5840]
                                            mem[64] = _5840 + ceil32(return_data.size) + (32 * mem[_5840]) + 128
                                            if not _5981:
                                                if 0 < mem[_5840 + ceil32(return_data.size) + 96]:
                                                    mem[_5840 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8669 = mem[_5840]
                                                    idx = 0
                                                    while idx < _8669 - 1:
                                                        require idx < mem[_5840]
                                                        _8714 = mem[(32 * idx) + _5840 + 32]
                                                        require idx + 1 < mem[_5840]
                                                        _8757 = mem[(32 * idx + 1) + _5840 + 32]
                                                        if mem[(32 * idx) + _5840 + 44 len 20] == mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5840 + 44 len 20] < mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5840 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5840 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8757)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8714) == address(_8714):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5840 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8757)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8757) == address(_8714):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5840 + ceil32(return_data.size) + 96]:
                                                        return _5891, mem[_5840 + ceil32(return_data.size) + 160]
                                            else:
                                                mem[_5840 + ceil32(return_data.size) + 128 len 32 * _5981] = call.data[calldata.size len 32 * _5981]
                                                if 0 < mem[_5840 + ceil32(return_data.size) + 96]:
                                                    mem[_5840 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8670 = mem[_5840]
                                                    idx = 0
                                                    while idx < _8670 - 1:
                                                        require idx < mem[_5840]
                                                        _8717 = mem[(32 * idx) + _5840 + 32]
                                                        require idx + 1 < mem[_5840]
                                                        _8759 = mem[(32 * idx + 1) + _5840 + 32]
                                                        if mem[(32 * idx) + _5840 + 44 len 20] == mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5840 + 44 len 20] < mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5840 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5840 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8759)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8717) == address(_8717):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5840 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5840 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8759)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5840 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8759) == address(_8717):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5840 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5840 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5840 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5840 + ceil32(return_data.size) + 96]:
                                                        return _5891, mem[_5840 + ceil32(return_data.size) + 160]
    else:
        _2903 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 < mem[_2903]:
            mem[_2903 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
            if 1 < mem[_2903]:
                mem[_2903 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[_2903 + 96] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
                mem[_2903 + 128] = _2903
                mem[_2903 + 192] = 0
                mem[_2903 + 160] = _2903 + 192
                if mem[96]:
                    mem[128] = _2903 + 96
                    mem[_2903 + 224] = 2
                    mem[_2903 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[_2903 + 288] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
                    mem[_2903 + 320] = address(arg3)
                    mem[_2903 + 352] = _2903 + 224
                    mem[_2903 + 416] = 0
                    mem[64] = _2903 + 448
                    mem[_2903 + 384] = _2903 + 416
                    if 1 < mem[96]:
                        mem[160] = _2903 + 320
                        if arg2:
                            idx = mem[96]
                            s = arg1
                            while idx:
                                require idx - 1 < mem[96]
                                _5811 = mem[(32 * idx - 1) + 128]
                                _5812 = mem[mem[(32 * idx - 1) + 128]]
                                _5813 = mem[mem[(32 * idx - 1) + 128] + 32]
                                _5814 = mem[64]
                                mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = s
                                mem[mem[64] + 36] = 64
                                _5823 = mem[_5813]
                                mem[mem[64] + 68] = mem[_5813]
                                s = 0
                                t = _5813 + 32
                                u = mem[64] + 100
                                while s < _5823:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(address(_5812))
                                staticcall address(_5812).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _5814 + (32 * _5823) + -mem[64] + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8781 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8833 = mem[_8781]
                                require mem[_8781] <= test266151307()
                                require _8781 + return_data.size > _8781 + mem[_8781] + 31
                                _8901 = mem[_8781 + mem[_8781]]
                                if mem[_8781 + mem[_8781]] <= test266151307():
                                    if (32 * mem[_8781 + mem[_8781]]) + 32 >= 0 and _8781 + ceil32(return_data.size) + (32 * mem[_8781 + mem[_8781]]) + 32 <= test266151307():
                                        mem[64] = _8781 + ceil32(return_data.size) + (32 * mem[_8781 + mem[_8781]]) + 32
                                        mem[_8781 + ceil32(return_data.size)] = _8901
                                        require return_data.size >= _8833 + (32 * _8901) + 32
                                        t = _8781 + _8833 + 32
                                        u = _8781 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _8901:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[_5811 + 64] = _8781 + ceil32(return_data.size)
                                        if _8901:
                                            t = _8781 + _8833 + (32 * _8901) + 31
                                            s = mem[_8781 + ceil32(return_data.size) + 32]
                                            continue 
                                revert
                            _5822 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5822 + 32 len 64] = call.data[calldata.size len 64]
                            if not arg2:
                                require mem[96] - 1 < mem[96]
                                require mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1 < mem[mem[mem[(32 * mem[96] - 1) + 128] + 64]]
                                _5860 = mem[(32 * mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1) + mem[mem[(32 * mem[96] - 1) + 128] + 64] + 32]
                                mem[_5822 + 100] = arg1
                                require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[_5822 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5822 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require 0 < mem[_5822]
                                mem[_5822 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                require 1 < mem[_5822]
                                mem[_5822 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                if mem[_5822] < 2:
                                    revert with 0, 
                                                32,
                                                34,
                                                0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                mem[_5822 + ceil32(return_data.size) + 198 len 30]
                                _5959 = mem[_5822]
                                require mem[_5822] <= test266151307()
                                mem[_5822 + ceil32(return_data.size) + 96] = mem[_5822]
                                mem[64] = _5822 + ceil32(return_data.size) + (32 * mem[_5822]) + 128
                                if not _5959:
                                    require mem[_5822 + ceil32(return_data.size) + 96] - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5822 + ceil32(return_data.size) + 96] - 1) + _5822 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5822] - 1
                                    while idx:
                                        require idx - 1 < mem[_5822]
                                        _8720 = mem[(32 * idx - 1) + _5822 + 32]
                                        require idx < mem[_5822]
                                        _8762 = mem[(32 * idx) + _5822 + 32]
                                        if mem[(32 * idx - 1) + _5822 + 44 len 20] == mem[(32 * idx) + _5822 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5822 + 44 len 20] < mem[(32 * idx) + _5822 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5822 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5822 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8762)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8720) == address(_8720):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5822 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5822 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8762)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8762) == address(_8720):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                else:
                                    mem[_5822 + ceil32(return_data.size) + 128 len 32 * _5959] = call.data[calldata.size len 32 * _5959]
                                    require mem[_5822 + ceil32(return_data.size) + 96] - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5822 + ceil32(return_data.size) + 96] - 1) + _5822 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5822] - 1
                                    while idx:
                                        require idx - 1 < mem[_5822]
                                        _8723 = mem[(32 * idx - 1) + _5822 + 32]
                                        require idx < mem[_5822]
                                        _8764 = mem[(32 * idx) + _5822 + 32]
                                        if mem[(32 * idx - 1) + _5822 + 44 len 20] == mem[(32 * idx) + _5822 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5822 + 44 len 20] < mem[(32 * idx) + _5822 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5822 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5822 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8764)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8723) == address(_8723):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5822 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5822 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8764)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8764) == address(_8723):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5822 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                require 0 < mem[_5822 + ceil32(return_data.size) + 96]
                                mem[mem[64]] = mem[_5822 + ceil32(return_data.size) + 128]
                                return mem[mem[64]], _5860
                            if 0 < mem[96]:
                                if 0 < mem[mem[mem[128] + 64]]:
                                    _5862 = mem[mem[mem[128] + 64] + 32]
                                    mem[_5822 + 100] = arg1
                                    require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                    staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[_5822 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5822 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    if 0 < mem[_5822]:
                                        mem[_5822 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                        if 1 < mem[_5822]:
                                            mem[_5822 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                            if mem[_5822] < 2:
                                                revert with 0, 
                                                            32,
                                                            34,
                                                            0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                            mem[_5822 + ceil32(return_data.size) + 198 len 30]
                                            _5962 = mem[_5822]
                                            require mem[_5822] <= test266151307()
                                            mem[_5822 + ceil32(return_data.size) + 96] = mem[_5822]
                                            mem[64] = _5822 + ceil32(return_data.size) + (32 * mem[_5822]) + 128
                                            if not _5962:
                                                if 0 < mem[_5822 + ceil32(return_data.size) + 96]:
                                                    mem[_5822 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8671 = mem[_5822]
                                                    idx = 0
                                                    while idx < _8671 - 1:
                                                        require idx < mem[_5822]
                                                        _8726 = mem[(32 * idx) + _5822 + 32]
                                                        require idx + 1 < mem[_5822]
                                                        _8766 = mem[(32 * idx + 1) + _5822 + 32]
                                                        if mem[(32 * idx) + _5822 + 44 len 20] == mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5822 + 44 len 20] < mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5822 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5822 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8766)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8726) == address(_8726):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5822 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8766)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8766) == address(_8726):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5822 + ceil32(return_data.size) + 96]:
                                                        return _5862, mem[_5822 + ceil32(return_data.size) + 160]
                                            else:
                                                mem[_5822 + ceil32(return_data.size) + 128 len 32 * _5962] = call.data[calldata.size len 32 * _5962]
                                                if 0 < mem[_5822 + ceil32(return_data.size) + 96]:
                                                    mem[_5822 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8672 = mem[_5822]
                                                    idx = 0
                                                    while idx < _8672 - 1:
                                                        require idx < mem[_5822]
                                                        _8729 = mem[(32 * idx) + _5822 + 32]
                                                        require idx + 1 < mem[_5822]
                                                        _8768 = mem[(32 * idx + 1) + _5822 + 32]
                                                        if mem[(32 * idx) + _5822 + 44 len 20] == mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5822 + 44 len 20] < mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5822 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5822 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8768)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8729) == address(_8729):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5822 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5822 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8768)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5822 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8768) == address(_8729):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5822 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5822 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5822 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5822 + ceil32(return_data.size) + 96]:
                                                        return _5862, mem[_5822 + ceil32(return_data.size) + 160]
                        else:
                            _5798 = mem[96]
                            idx = 0
                            s = arg1
                            while idx < _5798:
                                require idx < mem[96]
                                _5815 = mem[(32 * idx) + 128]
                                _5816 = mem[mem[(32 * idx) + 128]]
                                _5817 = mem[mem[(32 * idx) + 128] + 32]
                                _5818 = mem[64]
                                mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = s
                                mem[mem[64] + 36] = 64
                                _5824 = mem[_5817]
                                mem[mem[64] + 68] = mem[_5817]
                                s = 0
                                t = _5817 + 32
                                u = mem[64] + 100
                                while s < _5824:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(address(_5816))
                                staticcall address(_5816).mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _5818 + (32 * _5824) + -mem[64] + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8782 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8834 = mem[_8782]
                                require mem[_8782] <= test266151307()
                                require _8782 + return_data.size > _8782 + mem[_8782] + 31
                                _8918 = mem[_8782 + mem[_8782]]
                                if mem[_8782 + mem[_8782]] <= test266151307():
                                    if (32 * mem[_8782 + mem[_8782]]) + 32 >= 0 and _8782 + ceil32(return_data.size) + (32 * mem[_8782 + mem[_8782]]) + 32 <= test266151307():
                                        mem[64] = _8782 + ceil32(return_data.size) + (32 * mem[_8782 + mem[_8782]]) + 32
                                        mem[_8782 + ceil32(return_data.size)] = _8918
                                        require return_data.size >= _8834 + (32 * _8918) + 32
                                        t = _8782 + _8834 + 32
                                        u = _8782 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _8918:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[_5815 + 64] = _8782 + ceil32(return_data.size)
                                        if _8918 - 1 < _8918:
                                            t = _8782 + _8834 + (32 * _8918) + 33
                                            s = mem[(32 * _8918 - 1) + _8782 + ceil32(return_data.size) + 32]
                                            continue 
                                revert
                            _5851 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            mem[_5851 + 32 len 64] = call.data[calldata.size len 64]
                            if not arg2:
                                require mem[96] - 1 < mem[96]
                                require mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1 < mem[mem[mem[(32 * mem[96] - 1) + 128] + 64]]
                                _5895 = mem[(32 * mem[mem[mem[(32 * mem[96] - 1) + 128] + 32]] - 1) + mem[mem[(32 * mem[96] - 1) + 128] + 64] + 32]
                                mem[_5851 + 100] = arg1
                                require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[_5851 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _5851 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require 0 < mem[_5851]
                                mem[_5851 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                require 1 < mem[_5851]
                                mem[_5851 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                if mem[_5851] < 2:
                                    revert with 0, 
                                                32,
                                                34,
                                                0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                mem[_5851 + ceil32(return_data.size) + 198 len 30]
                                _5987 = mem[_5851]
                                require mem[_5851] <= test266151307()
                                mem[_5851 + ceil32(return_data.size) + 96] = mem[_5851]
                                mem[64] = _5851 + ceil32(return_data.size) + (32 * mem[_5851]) + 128
                                if not _5987:
                                    require mem[_5851 + ceil32(return_data.size) + 96] - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5851 + ceil32(return_data.size) + 96] - 1) + _5851 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5851] - 1
                                    while idx:
                                        require idx - 1 < mem[_5851]
                                        _8732 = mem[(32 * idx - 1) + _5851 + 32]
                                        require idx < mem[_5851]
                                        _8771 = mem[(32 * idx) + _5851 + 32]
                                        if mem[(32 * idx - 1) + _5851 + 44 len 20] == mem[(32 * idx) + _5851 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5851 + 44 len 20] < mem[(32 * idx) + _5851 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5851 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5851 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8771)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8732) == address(_8732):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5851 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5851 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8771)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8771) == address(_8732):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                else:
                                    mem[_5851 + ceil32(return_data.size) + 128 len 32 * _5987] = call.data[calldata.size len 32 * _5987]
                                    require mem[_5851 + ceil32(return_data.size) + 96] - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                    mem[(32 * mem[_5851 + ceil32(return_data.size) + 96] - 1) + _5851 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    idx = mem[_5851] - 1
                                    while idx:
                                        require idx - 1 < mem[_5851]
                                        _8735 = mem[(32 * idx - 1) + _5851 + 32]
                                        require idx < mem[_5851]
                                        _8773 = mem[(32 * idx) + _5851 + 32]
                                        if mem[(32 * idx - 1) + _5851 + 44 len 20] == mem[(32 * idx) + _5851 + 44 len 20]:
                                            revert with 0, 
                                                        32,
                                                        41,
                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                        mem[mem[64] + 109 len 23]
                                        if mem[(32 * idx - 1) + _5851 + 44 len 20] < mem[(32 * idx) + _5851 + 44 len 20]:
                                            if not mem[(32 * idx - 1) + _5851 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5851 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8773)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8735) == address(_8735):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if not mem[(32 * idx) + _5851 + 44 len 20]:
                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                            mem[mem[64] + 4] = mem[(32 * idx - 1) + _5851 + 44 len 20]
                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_8773)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            48,
                                                            0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                            mem[mem[64] + 116 len 16]
                                            if address(_8773) == address(_8735):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                44,
                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 112 len 20]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                    if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                    if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                    mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                else:
                                                    if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                                    else:
                                                        if 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                        if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])
                                                        if (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx - 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                        mem[(32 * idx - 1) + _5851 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128])) + 1
                                        idx = idx - 1
                                        continue 
                                require 0 < mem[_5851 + ceil32(return_data.size) + 96]
                                mem[mem[64]] = mem[_5851 + ceil32(return_data.size) + 128]
                                return mem[mem[64]], _5895
                            if 0 < mem[96]:
                                if 0 < mem[mem[mem[128] + 64]]:
                                    _5897 = mem[mem[mem[128] + 64] + 32]
                                    mem[_5851 + 100] = arg1
                                    require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                                    staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[_5851 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5851 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    if 0 < mem[_5851]:
                                        mem[_5851 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                                        if 1 < mem[_5851]:
                                            mem[_5851 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                                            if mem[_5851] < 2:
                                                revert with 0, 
                                                            32,
                                                            34,
                                                            0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                                            mem[_5851 + ceil32(return_data.size) + 198 len 30]
                                            _5990 = mem[_5851]
                                            require mem[_5851] <= test266151307()
                                            mem[_5851 + ceil32(return_data.size) + 96] = mem[_5851]
                                            mem[64] = _5851 + ceil32(return_data.size) + (32 * mem[_5851]) + 128
                                            if not _5990:
                                                if 0 < mem[_5851 + ceil32(return_data.size) + 96]:
                                                    mem[_5851 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8673 = mem[_5851]
                                                    idx = 0
                                                    while idx < _8673 - 1:
                                                        require idx < mem[_5851]
                                                        _8738 = mem[(32 * idx) + _5851 + 32]
                                                        require idx + 1 < mem[_5851]
                                                        _8775 = mem[(32 * idx + 1) + _5851 + 32]
                                                        if mem[(32 * idx) + _5851 + 44 len 20] == mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5851 + 44 len 20] < mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5851 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5851 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8775)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8738) == address(_8738):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5851 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8775)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8775) == address(_8738):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5851 + ceil32(return_data.size) + 96]:
                                                        return _5897, mem[_5851 + ceil32(return_data.size) + 160]
                                            else:
                                                mem[_5851 + ceil32(return_data.size) + 128 len 32 * _5990] = call.data[calldata.size len 32 * _5990]
                                                if 0 < mem[_5851 + ceil32(return_data.size) + 96]:
                                                    mem[_5851 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    _8674 = mem[_5851]
                                                    idx = 0
                                                    while idx < _8674 - 1:
                                                        require idx < mem[_5851]
                                                        _8741 = mem[(32 * idx) + _5851 + 32]
                                                        require idx + 1 < mem[_5851]
                                                        _8777 = mem[(32 * idx + 1) + _5851 + 32]
                                                        if mem[(32 * idx) + _5851 + 44 len 20] == mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                            revert with 0, 
                                                                        32,
                                                                        41,
                                                                        0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                                        mem[mem[64] + 109 len 23]
                                                        if mem[(32 * idx) + _5851 + 44 len 20] < mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                            if not mem[(32 * idx) + _5851 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5851 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8777)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8741) == address(_8741):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if not mem[(32 * idx + 1) + _5851 + 44 len 20]:
                                                                revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                                            mem[mem[64] + 4] = mem[(32 * idx) + _5851 + 44 len 20]
                                                            require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                                            staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                                                    gas gas_remaining wei
                                                                   args mem[mem[64] + 4], address(_8777)
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            require ext_code.size(address(ext_call.return_data[0]))
                                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                                    gas gas_remaining wei
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 96
                                                            require idx < mem[_5851 + ceil32(return_data.size) + 96]
                                                            if mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] <= 0:
                                                                revert with 0, 
                                                                            32,
                                                                            47,
                                                                            0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                                            mem[mem[64] + 115 len 17]
                                                            if address(_8777) == address(_8741):
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[0])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[0]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                            else:
                                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                                    revert with 0, 
                                                                                32,
                                                                                44,
                                                                                0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                                mem[mem[64] + 112 len 20]
                                                                if not mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                    require Mask(112, 0, ext_call.return_data[32])
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                    require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                    mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                                else:
                                                                    if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != 997:
                                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                    if not 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]:
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                    else:
                                                                        if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                            revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                        if not Mask(112, 0, ext_call.return_data[32]):
                                                                            if 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / 997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]
                                                                        else:
                                                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                            if (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            require (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                            require idx + 1 < mem[_5851 + ceil32(return_data.size) + 96]
                                                                            mem[(32 * idx + 1) + _5851 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128] / (997 * mem[(32 * idx) + _5851 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        idx = idx + 1
                                                        continue 
                                                    if 1 < mem[_5851 + ceil32(return_data.size) + 96]:
                                                        return _5897, mem[_5851 + ceil32(return_data.size) + 160]
    revert
}

function sub_7b73b384(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (160 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
        require cd[((160 * idx) + cd[4] + 164)] == address(cd[((160 * idx) + cd[4] + 164)])
        _7368 = mem[64]
        _14735 = mem[64] + 96
        mem[64] = mem[64] + 192
        mem[_14735] = 0
        mem[_14735 + 32] = 96
        mem[_14735 + 64] = 96
        mem[var34001] = _14735
        t = var34001
        s = var34002
        while s - 1:
            _14735 = mem[64]
            mem[64] = mem[64] + 96
            mem[_14735] = 0
            mem[_14735 + 32] = 96
            mem[_14735 + 64] = 96
            mem[t + 32] = _14735
            t = t + 32
            s = s - 1
            continue 
        if not cd[((160 * idx) + cd[4] + 100)]:
            _14736 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            require 0 < mem[_14736]
            mem[_14736 + 32] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
            require 1 < mem[_14736]
            mem[_14736 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
            mem[_14736 + 96] = address(cd[((160 * idx) + cd[4] + 164)])
            mem[_14736 + 128] = _14736
            mem[_14736 + 192] = 0
            mem[64] = _14736 + 224
            mem[_14736 + 160] = _14736 + 192
            require mem[_7368]
            mem[_7368 + 32] = _14736 + 96
            mem[_14736 + 224] = 2
            mem[_14736 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
            mem[_14736 + 288] = 0x130966628846bfd36ff31a822705796e8cb8c18d
            mem[_14736 + 320] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
            mem[_14736 + 352] = _14736 + 224
            mem[_14736 + 416] = 0
            mem[64] = _14736 + 448
            mem[_14736 + 384] = _14736 + 416
            require 1 < mem[_7368]
            mem[_7368 + 64] = _14736 + 320
            if cd[((160 * idx) + cd[4] + 100)]:
                s = mem[_7368]
                t = cd[((160 * idx) + cd[4] + 36)]
                while s:
                    require s - 1 < mem[_7368]
                    _22106 = mem[(32 * s - 1) + _7368 + 32]
                    _22107 = mem[mem[(32 * s - 1) + _7368 + 32]]
                    _22108 = mem[mem[(32 * s - 1) + _7368 + 32] + 32]
                    _22109 = mem[64]
                    mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = t
                    mem[mem[64] + 36] = 64
                    _22122 = mem[_22108]
                    mem[mem[64] + 68] = mem[_22108]
                    idx = 0
                    t = _22108 + 32
                    u = mem[64] + 100
                    while idx < _22122:
                        mem[u] = mem[t + 12 len 20]
                        idx = idx + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    require ext_code.size(address(_22107))
                    staticcall address(_22107).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _22109 + (32 * _22122) + -mem[64] + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _29628 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _29688 = mem[_29628]
                    require mem[_29628] <= test266151307()
                    require _29628 + return_data.size > _29628 + mem[_29628] + 31
                    _29736 = mem[_29628 + mem[_29628]]
                    if mem[_29628 + mem[_29628]] <= test266151307():
                        if (32 * mem[_29628 + mem[_29628]]) + 32 >= 0 and _29628 + ceil32(return_data.size) + (32 * mem[_29628 + mem[_29628]]) + 32 <= test266151307():
                            mem[64] = _29628 + ceil32(return_data.size) + (32 * mem[_29628 + mem[_29628]]) + 32
                            mem[_29628 + ceil32(return_data.size)] = _29736
                            require return_data.size >= _29688 + (32 * _29736) + 32
                            t = _29628 + _29688 + 32
                            u = _29628 + ceil32(return_data.size) + 32
                            idx = 0
                            while idx < _29736:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx + 1
                                continue 
                            mem[_22106 + 64] = _29628 + ceil32(return_data.size)
                            if _29736:
                                t = _29628 + _29688 + (32 * _29736) + 31
                                t = mem[_29628 + ceil32(return_data.size) + 32]
                                continue 
                    revert
                require cd[((160 * idx) + cd[4] + 132)] == bool(cd[((160 * idx) + cd[4] + 132)])
                if not cd[((160 * idx) + cd[4] + 132)]:
                    _22138 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_22138] = _7368
                    mem[_22138 + 32] = cd[((160 * idx) + cd[4] + 36)]
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22138 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22138 + 96] = 1
                    _22150 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_22150] = 0
                    require mem[_7368] - 1 < mem[_7368]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22198 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                    _22222 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22258 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                    staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22298 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22316 = mem[_22298]
                    require mem[_22298] == mem[_22298 + 12 len 20]
                    mem[mem[64] + 4] = address(_22198)
                    mem[mem[64] + 36] = address(_22258)
                    require ext_code.size(address(_22316))
                    staticcall address(_22316).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args address(_22198), address(_22258)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22410 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22438 = mem[_22410]
                    require mem[_22410] == mem[_22410 + 12 len 20]
                    require ext_code.size(mem[_22410 + 12 len 20])
                    staticcall mem[_22410 + 12 len 20].token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_22578] == mem[_22578 + 12 len 20]
                    if address(_22198) == mem[_22578 + 12 len 20]:
                        _22970 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23126 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23126) + 256
                        v = mem[64] + 256
                        while s < _23126:
                            mem[v] = u + -_22970 - 256
                            _29446 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29448 = mem[_29446 + 32]
                            mem[u + 32] = 96
                            _29493 = mem[_29448]
                            mem[u + 96] = mem[_29448]
                            idx = 0
                            w = _29448 + 32
                            x = u + 128
                            while idx < _29493:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36550 = mem[_29446 + 64]
                            mem[u + 64] = (32 * _29493) + 128
                            _36551 = mem[_36550]
                            mem[u + (32 * _29493) + 128] = mem[_36550]
                            w = u + (32 * _29493) + 160
                            idx = 0
                            x = _36550 + 32
                            while idx < _36551:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29493) + (32 * _36551) + 160
                            v = v + 32
                            continue 
                        mem[_22970 + 128] = mem[_22138 + 32]
                        mem[_22970 + 160] = bool(mem[_22138 + 64])
                        mem[_22970 + 192] = bool(mem[_22138 + 96])
                        mem[_22970 + 64] = u + -_22970 - 32
                        _29570 = mem[_22150]
                        mem[u] = mem[_22150]
                        s = 0
                        while s < _29570:
                            mem[s + u + 32] = mem[_22150 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29570) <= _29570:
                            _36734 = mem[64]
                            mem[mem[64]] = ceil32(_29570) + u - mem[64]
                            mem[64] = ceil32(_29570) + u + 32
                            mem[ceil32(_29570) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29570) + u + 36] = _22222
                            mem[ceil32(_29570) + u + 68] = 0
                            mem[ceil32(_29570) + u + 100] = this.address
                            mem[ceil32(_29570) + u + 132] = 128
                            _36886 = mem[_36734]
                            mem[ceil32(_29570) + u + 164] = mem[_36734]
                            s = 0
                            while s < _36886:
                                mem[s + ceil32(_29570) + u + 196] = mem[_36734 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36886) <= _36886:
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22222, 0, address(this.address), 128, mem[ceil32(_29570) + u + 164 len ceil32(_36886) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29570) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29570) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29570) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43822 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43822] = return_data.size
                                    mem[_43822 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29570) + u + _36886 + 196] = 0
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22222, 0, address(this.address), 128, mem[ceil32(_29570) + u + 164 len ceil32(_36886) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29570) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29570) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29570) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43823 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43823] = return_data.size
                                    mem[_43823 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        else:
                            mem[u + _29570 + 32] = 0
                            _36782 = mem[64]
                            mem[mem[64]] = ceil32(_29570) + u - mem[64]
                            mem[64] = ceil32(_29570) + u + 32
                            mem[ceil32(_29570) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29570) + u + 36] = _22222
                            mem[ceil32(_29570) + u + 68] = 0
                            mem[ceil32(_29570) + u + 100] = this.address
                            mem[ceil32(_29570) + u + 132] = 128
                            _36894 = mem[_36782]
                            mem[ceil32(_29570) + u + 164] = mem[_36782]
                            s = 0
                            while s < _36894:
                                mem[s + ceil32(_29570) + u + 196] = mem[_36782 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36894) <= _36894:
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22222, 0, address(this.address), 128, mem[ceil32(_29570) + u + 164 len ceil32(_36894) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29570) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29570) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29570) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43824 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43824] = return_data.size
                                    mem[_43824 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29570) + u + _36894 + 196] = 0
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22222, 0, address(this.address), 128, mem[ceil32(_29570) + u + 164 len ceil32(_36894) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29570) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29570) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29570) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29570) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29570) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43825 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43825] = return_data.size
                                    mem[_43825 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    else:
                        _22971 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23127 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23127) + 256
                        v = mem[64] + 256
                        while s < _23127:
                            mem[v] = u + -_22971 - 256
                            _29449 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29451 = mem[_29449 + 32]
                            mem[u + 32] = 96
                            _29497 = mem[_29451]
                            mem[u + 96] = mem[_29451]
                            idx = 0
                            w = _29451 + 32
                            x = u + 128
                            while idx < _29497:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36552 = mem[_29449 + 64]
                            mem[u + 64] = (32 * _29497) + 128
                            _36553 = mem[_36552]
                            mem[u + (32 * _29497) + 128] = mem[_36552]
                            w = u + (32 * _29497) + 160
                            idx = 0
                            x = _36552 + 32
                            while idx < _36553:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29497) + (32 * _36553) + 160
                            v = v + 32
                            continue 
                        mem[_22971 + 128] = mem[_22138 + 32]
                        mem[_22971 + 160] = bool(mem[_22138 + 64])
                        mem[_22971 + 192] = bool(mem[_22138 + 96])
                        mem[_22971 + 64] = u + -_22971 - 32
                        _29571 = mem[_22150]
                        mem[u] = mem[_22150]
                        s = 0
                        while s < _29571:
                            mem[s + u + 32] = mem[_22150 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29571) <= _29571:
                            _36736 = mem[64]
                            mem[mem[64]] = ceil32(_29571) + u - mem[64]
                            mem[64] = ceil32(_29571) + u + 32
                            mem[ceil32(_29571) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29571) + u + 36] = 0
                            mem[ceil32(_29571) + u + 68] = _22222
                            mem[ceil32(_29571) + u + 100] = this.address
                            mem[ceil32(_29571) + u + 132] = 128
                            _36887 = mem[_36736]
                            mem[ceil32(_29571) + u + 164] = mem[_36736]
                            s = 0
                            while s < _36887:
                                mem[s + ceil32(_29571) + u + 196] = mem[_36736 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36887) <= _36887:
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22222, address(this.address), 128, mem[ceil32(_29571) + u + 164 len ceil32(_36887) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29571) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29571) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29571) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43826 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43826] = return_data.size
                                    mem[_43826 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29571) + u + _36887 + 196] = 0
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22222, address(this.address), 128, mem[ceil32(_29571) + u + 164 len ceil32(_36887) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29571) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29571) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29571) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43827 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43827] = return_data.size
                                    mem[_43827 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        else:
                            mem[u + _29571 + 32] = 0
                            _36783 = mem[64]
                            mem[mem[64]] = ceil32(_29571) + u - mem[64]
                            mem[64] = ceil32(_29571) + u + 32
                            mem[ceil32(_29571) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29571) + u + 36] = 0
                            mem[ceil32(_29571) + u + 68] = _22222
                            mem[ceil32(_29571) + u + 100] = this.address
                            mem[ceil32(_29571) + u + 132] = 128
                            _36895 = mem[_36783]
                            mem[ceil32(_29571) + u + 164] = mem[_36783]
                            s = 0
                            while s < _36895:
                                mem[s + ceil32(_29571) + u + 196] = mem[_36783 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36895) <= _36895:
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22222, address(this.address), 128, mem[ceil32(_29571) + u + 164 len ceil32(_36895) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29571) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29571) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29571) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43828 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43828] = return_data.size
                                    mem[_43828 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29571) + u + _36895 + 196] = 0
                                require ext_code.size(address(_22438))
                                call address(_22438).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22222, address(this.address), 128, mem[ceil32(_29571) + u + 164 len ceil32(_36895) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29571) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29571) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29571) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29571) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29571) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43829 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43829] = return_data.size
                                    mem[_43829 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                else:
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    _22156 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_22156 + 32 len 64] = call.data[calldata.size len 64]
                    if not cd[((160 * idx) + cd[4] + 100)]:
                        require mem[_7368] - 1 < mem[_7368]
                        require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                        _22201 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                        mem[_22156 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22156 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22156 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22156]
                        mem[_22156 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        require 1 < mem[_22156]
                        mem[_22156 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        if mem[_22156] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22156 + ceil32(return_data.size) + 198 len 30]
                        _22355 = mem[_22156]
                        require mem[_22156] <= test266151307()
                        mem[_22156 + ceil32(return_data.size) + 96] = mem[_22156]
                        mem[64] = _22156 + ceil32(return_data.size) + (32 * mem[_22156]) + 128
                        if not _22355:
                            require mem[_22156 + ceil32(return_data.size) + 96] - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22156 + ceil32(return_data.size) + 96] - 1) + _22156 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22156] - 1
                            while s:
                                require s - 1 < mem[_22156]
                                _29499 = mem[(32 * s - 1) + _22156 + 32]
                                require s < mem[_22156]
                                _29573 = mem[(32 * s) + _22156 + 32]
                                if mem[(32 * s - 1) + _22156 + 44 len 20] == mem[(32 * s) + _22156 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22156 + 44 len 20] < mem[(32 * s) + _22156 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29573)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29499) == address(_29499):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29573)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29573) == address(_29499):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22156 + ceil32(return_data.size) + 96]
                            if mem[_22156 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22201:
                            _29684 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29684] = _7368
                            mem[_29684 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29684 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29684 + 96] = 1
                            _30022 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30022] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30278 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30332 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30458 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30622 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30798 = mem[_30622]
                            require mem[_30622] == mem[_30622 + 12 len 20]
                            mem[mem[64] + 4] = address(_30278)
                            mem[mem[64] + 36] = address(_30458)
                            require ext_code.size(address(_30798))
                            staticcall address(_30798).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30278), address(_30458)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31352 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31448 = mem[_31352]
                            require mem[_31352] == mem[_31352 + 12 len 20]
                            require ext_code.size(mem[_31352 + 12 len 20])
                            staticcall mem[_31352 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32498 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32498] == mem[_32498 + 12 len 20]
                            if address(_30278) == mem[_32498 + 12 len 20]:
                                _33266 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33362 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33362) + 256
                                v = mem[64] + 256
                                while s < _33362:
                                    mem[v] = u + -_33266 - 256
                                    _36438 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36440 = mem[_36438 + 32]
                                    mem[u + 32] = 96
                                    _36557 = mem[_36440]
                                    mem[u + 96] = mem[_36440]
                                    idx = 0
                                    w = _36440 + 32
                                    x = u + 128
                                    while idx < _36557:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40270 = mem[_36438 + 64]
                                    mem[u + 64] = (32 * _36557) + 128
                                    _40271 = mem[_40270]
                                    mem[u + (32 * _36557) + 128] = mem[_40270]
                                    w = u + (32 * _36557) + 160
                                    idx = 0
                                    x = _40270 + 32
                                    while idx < _40271:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36557) + (32 * _40271) + 160
                                    v = v + 32
                                    continue 
                                mem[_33266 + 128] = mem[_29684 + 32]
                                mem[_33266 + 160] = bool(mem[_29684 + 64])
                                mem[_33266 + 192] = bool(mem[_29684 + 96])
                                mem[_33266 + 64] = u + -_33266 - 32
                                _36698 = mem[_30022]
                                mem[u] = mem[_30022]
                                s = 0
                                while s < _36698:
                                    mem[s + u + 32] = mem[_30022 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36698) <= _36698:
                                    _40338 = mem[64]
                                    mem[mem[64]] = ceil32(_36698) + u - mem[64]
                                    mem[64] = ceil32(_36698) + u + 32
                                    mem[ceil32(_36698) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36698) + u + 36] = _30332
                                    mem[ceil32(_36698) + u + 68] = 0
                                    mem[ceil32(_36698) + u + 100] = this.address
                                    mem[ceil32(_36698) + u + 132] = 128
                                    _40462 = mem[_40338]
                                    mem[ceil32(_36698) + u + 164] = mem[_40338]
                                    s = 0
                                    while s < _40462:
                                        mem[s + ceil32(_36698) + u + 196] = mem[_40338 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40462) <= _40462:
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30332, 0, address(this.address), 128, mem[ceil32(_36698) + u + 164 len ceil32(_40462) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36698) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36698) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36698) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46926 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46926] = return_data.size
                                            mem[_46926 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36698) + u + _40462 + 196] = 0
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30332, 0, address(this.address), 128, mem[ceil32(_36698) + u + 164 len ceil32(_40462) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36698) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36698) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36698) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46927 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46927] = return_data.size
                                            mem[_46927 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36698 + 32] = 0
                                    _40418 = mem[64]
                                    mem[mem[64]] = ceil32(_36698) + u - mem[64]
                                    mem[64] = ceil32(_36698) + u + 32
                                    mem[ceil32(_36698) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36698) + u + 36] = _30332
                                    mem[ceil32(_36698) + u + 68] = 0
                                    mem[ceil32(_36698) + u + 100] = this.address
                                    mem[ceil32(_36698) + u + 132] = 128
                                    _40494 = mem[_40418]
                                    mem[ceil32(_36698) + u + 164] = mem[_40418]
                                    s = 0
                                    while s < _40494:
                                        mem[s + ceil32(_36698) + u + 196] = mem[_40418 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40494) <= _40494:
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30332, 0, address(this.address), 128, mem[ceil32(_36698) + u + 164 len ceil32(_40494) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36698) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36698) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36698) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46928 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46928] = return_data.size
                                            mem[_46928 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36698) + u + _40494 + 196] = 0
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30332, 0, address(this.address), 128, mem[ceil32(_36698) + u + 164 len ceil32(_40494) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36698) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36698) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36698) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36698) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36698) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46929 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46929] = return_data.size
                                            mem[_46929 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33267 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33363 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33363) + 256
                                v = mem[64] + 256
                                while s < _33363:
                                    mem[v] = u + -_33267 - 256
                                    _36441 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36443 = mem[_36441 + 32]
                                    mem[u + 32] = 96
                                    _36561 = mem[_36443]
                                    mem[u + 96] = mem[_36443]
                                    idx = 0
                                    w = _36443 + 32
                                    x = u + 128
                                    while idx < _36561:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40272 = mem[_36441 + 64]
                                    mem[u + 64] = (32 * _36561) + 128
                                    _40273 = mem[_40272]
                                    mem[u + (32 * _36561) + 128] = mem[_40272]
                                    w = u + (32 * _36561) + 160
                                    idx = 0
                                    x = _40272 + 32
                                    while idx < _40273:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36561) + (32 * _40273) + 160
                                    v = v + 32
                                    continue 
                                mem[_33267 + 128] = mem[_29684 + 32]
                                mem[_33267 + 160] = bool(mem[_29684 + 64])
                                mem[_33267 + 192] = bool(mem[_29684 + 96])
                                mem[_33267 + 64] = u + -_33267 - 32
                                _36699 = mem[_30022]
                                mem[u] = mem[_30022]
                                s = 0
                                while s < _36699:
                                    mem[s + u + 32] = mem[_30022 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36699) <= _36699:
                                    _40340 = mem[64]
                                    mem[mem[64]] = ceil32(_36699) + u - mem[64]
                                    mem[64] = ceil32(_36699) + u + 32
                                    mem[ceil32(_36699) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36699) + u + 36] = 0
                                    mem[ceil32(_36699) + u + 68] = _30332
                                    mem[ceil32(_36699) + u + 100] = this.address
                                    mem[ceil32(_36699) + u + 132] = 128
                                    _40463 = mem[_40340]
                                    mem[ceil32(_36699) + u + 164] = mem[_40340]
                                    s = 0
                                    while s < _40463:
                                        mem[s + ceil32(_36699) + u + 196] = mem[_40340 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40463) <= _40463:
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30332, address(this.address), 128, mem[ceil32(_36699) + u + 164 len ceil32(_40463) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36699) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36699) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36699) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46930 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46930] = return_data.size
                                            mem[_46930 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36699) + u + _40463 + 196] = 0
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30332, address(this.address), 128, mem[ceil32(_36699) + u + 164 len ceil32(_40463) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36699) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36699) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36699) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46931 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46931] = return_data.size
                                            mem[_46931 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36699 + 32] = 0
                                    _40419 = mem[64]
                                    mem[mem[64]] = ceil32(_36699) + u - mem[64]
                                    mem[64] = ceil32(_36699) + u + 32
                                    mem[ceil32(_36699) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36699) + u + 36] = 0
                                    mem[ceil32(_36699) + u + 68] = _30332
                                    mem[ceil32(_36699) + u + 100] = this.address
                                    mem[ceil32(_36699) + u + 132] = 128
                                    _40495 = mem[_40419]
                                    mem[ceil32(_36699) + u + 164] = mem[_40419]
                                    s = 0
                                    while s < _40495:
                                        mem[s + ceil32(_36699) + u + 196] = mem[_40419 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40495) <= _40495:
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30332, address(this.address), 128, mem[ceil32(_36699) + u + 164 len ceil32(_40495) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36699) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36699) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36699) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46932 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46932] = return_data.size
                                            mem[_46932 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36699) + u + _40495 + 196] = 0
                                        require ext_code.size(address(_31448))
                                        call address(_31448).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30332, address(this.address), 128, mem[ceil32(_36699) + u + 164 len ceil32(_40495) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36699) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36699) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36699) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36699) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36699) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46933 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46933] = return_data.size
                                            mem[_46933 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22156 + ceil32(return_data.size) + 128 len 32 * _22355] = call.data[calldata.size len 32 * _22355]
                            require mem[_22156 + ceil32(return_data.size) + 96] - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22156 + ceil32(return_data.size) + 96] - 1) + _22156 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22156] - 1
                            while s:
                                require s - 1 < mem[_22156]
                                _29502 = mem[(32 * s - 1) + _22156 + 32]
                                require s < mem[_22156]
                                _29575 = mem[(32 * s) + _22156 + 32]
                                if mem[(32 * s - 1) + _22156 + 44 len 20] == mem[(32 * s) + _22156 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22156 + 44 len 20] < mem[(32 * s) + _22156 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29575)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29502) == address(_29502):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29575)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29575) == address(_29502):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22156 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22156 + ceil32(return_data.size) + 96]
                            if mem[_22156 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22201:
                            _29685 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29685] = _7368
                            mem[_29685 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29685 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29685 + 96] = 1
                            _30023 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30023] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30281 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30339 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30466 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30631 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30807 = mem[_30631]
                            require mem[_30631] == mem[_30631 + 12 len 20]
                            mem[mem[64] + 4] = address(_30281)
                            mem[mem[64] + 36] = address(_30466)
                            require ext_code.size(address(_30807))
                            staticcall address(_30807).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30281), address(_30466)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31353 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31465 = mem[_31353]
                            require mem[_31353] == mem[_31353 + 12 len 20]
                            require ext_code.size(mem[_31353 + 12 len 20])
                            staticcall mem[_31353 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32507 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32507] == mem[_32507 + 12 len 20]
                            if address(_30281) == mem[_32507 + 12 len 20]:
                                _33268 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33364 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33364) + 256
                                v = mem[64] + 256
                                while s < _33364:
                                    mem[v] = u + -_33268 - 256
                                    _36444 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36446 = mem[_36444 + 32]
                                    mem[u + 32] = 96
                                    _36565 = mem[_36446]
                                    mem[u + 96] = mem[_36446]
                                    idx = 0
                                    w = _36446 + 32
                                    x = u + 128
                                    while idx < _36565:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40274 = mem[_36444 + 64]
                                    mem[u + 64] = (32 * _36565) + 128
                                    _40275 = mem[_40274]
                                    mem[u + (32 * _36565) + 128] = mem[_40274]
                                    w = u + (32 * _36565) + 160
                                    idx = 0
                                    x = _40274 + 32
                                    while idx < _40275:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36565) + (32 * _40275) + 160
                                    v = v + 32
                                    continue 
                                mem[_33268 + 128] = mem[_29685 + 32]
                                mem[_33268 + 160] = bool(mem[_29685 + 64])
                                mem[_33268 + 192] = bool(mem[_29685 + 96])
                                mem[_33268 + 64] = u + -_33268 - 32
                                _36700 = mem[_30023]
                                mem[u] = mem[_30023]
                                s = 0
                                while s < _36700:
                                    mem[s + u + 32] = mem[_30023 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36700) <= _36700:
                                    _40342 = mem[64]
                                    mem[mem[64]] = ceil32(_36700) + u - mem[64]
                                    mem[64] = ceil32(_36700) + u + 32
                                    mem[ceil32(_36700) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36700) + u + 36] = _30339
                                    mem[ceil32(_36700) + u + 68] = 0
                                    mem[ceil32(_36700) + u + 100] = this.address
                                    mem[ceil32(_36700) + u + 132] = 128
                                    _40464 = mem[_40342]
                                    mem[ceil32(_36700) + u + 164] = mem[_40342]
                                    s = 0
                                    while s < _40464:
                                        mem[s + ceil32(_36700) + u + 196] = mem[_40342 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40464) > _40464:
                                        mem[ceil32(_36700) + u + _40464 + 196] = 0
                                    require ext_code.size(address(_31465))
                                    call address(_31465).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30339, 0, address(this.address), 128, mem[ceil32(_36700) + u + 164 len ceil32(_40464) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36700) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36700) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36700 + 32] = 0
                                    _40420 = mem[64]
                                    mem[mem[64]] = ceil32(_36700) + u - mem[64]
                                    mem[64] = ceil32(_36700) + u + 32
                                    mem[ceil32(_36700) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36700) + u + 36] = _30339
                                    mem[ceil32(_36700) + u + 68] = 0
                                    mem[ceil32(_36700) + u + 100] = this.address
                                    mem[ceil32(_36700) + u + 132] = 128
                                    _40496 = mem[_40420]
                                    mem[ceil32(_36700) + u + 164] = mem[_40420]
                                    s = 0
                                    while s < _40496:
                                        mem[s + ceil32(_36700) + u + 196] = mem[_40420 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40496) > _40496:
                                        mem[ceil32(_36700) + u + _40496 + 196] = 0
                                    require ext_code.size(address(_31465))
                                    call address(_31465).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30339, 0, address(this.address), 128, mem[ceil32(_36700) + u + 164 len ceil32(_40496) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36700) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36700) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36700) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36700) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36700) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36700) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36700) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33269 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33365 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33365) + 256
                                v = mem[64] + 256
                                while s < _33365:
                                    mem[v] = u + -_33269 - 256
                                    _36447 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36449 = mem[_36447 + 32]
                                    mem[u + 32] = 96
                                    _36569 = mem[_36449]
                                    mem[u + 96] = mem[_36449]
                                    idx = 0
                                    w = _36449 + 32
                                    x = u + 128
                                    while idx < _36569:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40276 = mem[_36447 + 64]
                                    mem[u + 64] = (32 * _36569) + 128
                                    _40277 = mem[_40276]
                                    mem[u + (32 * _36569) + 128] = mem[_40276]
                                    w = u + (32 * _36569) + 160
                                    idx = 0
                                    x = _40276 + 32
                                    while idx < _40277:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36569) + (32 * _40277) + 160
                                    v = v + 32
                                    continue 
                                mem[_33269 + 128] = mem[_29685 + 32]
                                mem[_33269 + 160] = bool(mem[_29685 + 64])
                                mem[_33269 + 192] = bool(mem[_29685 + 96])
                                mem[_33269 + 64] = u + -_33269 - 32
                                _36701 = mem[_30023]
                                mem[u] = mem[_30023]
                                s = 0
                                while s < _36701:
                                    mem[s + u + 32] = mem[_30023 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36701) <= _36701:
                                    _40344 = mem[64]
                                    mem[mem[64]] = ceil32(_36701) + u - mem[64]
                                    mem[64] = ceil32(_36701) + u + 32
                                    mem[ceil32(_36701) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36701) + u + 36] = 0
                                    mem[ceil32(_36701) + u + 68] = _30339
                                    mem[ceil32(_36701) + u + 100] = this.address
                                    mem[ceil32(_36701) + u + 132] = 128
                                    _40465 = mem[_40344]
                                    mem[ceil32(_36701) + u + 164] = mem[_40344]
                                    s = 0
                                    while s < _40465:
                                        mem[s + ceil32(_36701) + u + 196] = mem[_40344 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40465) > _40465:
                                        mem[ceil32(_36701) + u + _40465 + 196] = 0
                                    require ext_code.size(address(_31465))
                                    call address(_31465).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30339, address(this.address), 128, mem[ceil32(_36701) + u + 164 len ceil32(_40465) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36701) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36701) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36701 + 32] = 0
                                    _40421 = mem[64]
                                    mem[mem[64]] = ceil32(_36701) + u - mem[64]
                                    mem[64] = ceil32(_36701) + u + 32
                                    mem[ceil32(_36701) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36701) + u + 36] = 0
                                    mem[ceil32(_36701) + u + 68] = _30339
                                    mem[ceil32(_36701) + u + 100] = this.address
                                    mem[ceil32(_36701) + u + 132] = 128
                                    _40497 = mem[_40421]
                                    mem[ceil32(_36701) + u + 164] = mem[_40421]
                                    s = 0
                                    while s < _40497:
                                        mem[s + ceil32(_36701) + u + 196] = mem[_40421 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40497) > _40497:
                                        mem[ceil32(_36701) + u + _40497 + 196] = 0
                                    require ext_code.size(address(_31465))
                                    call address(_31465).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30339, address(this.address), 128, mem[ceil32(_36701) + u + 164 len ceil32(_40497) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36701) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36701) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36701) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36701) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36701) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36701) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36701) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                    else:
                        require 0 < mem[_7368]
                        require 0 < mem[mem[mem[_7368 + 32] + 64]]
                        _22203 = mem[mem[mem[_7368 + 32] + 64] + 32]
                        mem[_22156 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22156 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22156 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22156]
                        mem[_22156 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        require 1 < mem[_22156]
                        mem[_22156 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        if mem[_22156] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22156 + ceil32(return_data.size) + 198 len 30]
                        _22358 = mem[_22156]
                        require mem[_22156] <= test266151307()
                        mem[_22156 + ceil32(return_data.size) + 96] = mem[_22156]
                        mem[64] = _22156 + ceil32(return_data.size) + (32 * mem[_22156]) + 128
                        if not _22358:
                            require 0 < mem[_22156 + ceil32(return_data.size) + 96]
                            mem[_22156 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29438 = mem[_22156]
                            s = 0
                            while s < _29438 - 1:
                                require s < mem[_22156]
                                _29505 = mem[(32 * s) + _22156 + 32]
                                require s + 1 < mem[_22156]
                                _29577 = mem[(32 * s + 1) + _22156 + 32]
                                if mem[(32 * s) + _22156 + 44 len 20] == mem[(32 * s + 1) + _22156 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22156 + 44 len 20] < mem[(32 * s + 1) + _22156 + 44 len 20]:
                                    if not mem[(32 * s) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29577)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29505) == address(_29505):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29577)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29577) == address(_29505):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22156 + ceil32(return_data.size) + 96]
                            if _22203 + cd[((160 * idx) + cd[4] + 68)] > mem[_22156 + ceil32(return_data.size) + 160]:
                            _29686 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29686] = _7368
                            mem[_29686 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29686 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29686 + 96] = 1
                            _30024 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30024] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30284 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30346 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30474 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30640 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30816 = mem[_30640]
                            require mem[_30640] == mem[_30640 + 12 len 20]
                            mem[mem[64] + 4] = address(_30284)
                            mem[mem[64] + 36] = address(_30474)
                            require ext_code.size(address(_30816))
                            staticcall address(_30816).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30284), address(_30474)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31354 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31482 = mem[_31354]
                            require mem[_31354] == mem[_31354 + 12 len 20]
                            require ext_code.size(mem[_31354 + 12 len 20])
                            staticcall mem[_31354 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32516 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32516] == mem[_32516 + 12 len 20]
                            if address(_30284) == mem[_32516 + 12 len 20]:
                                _33270 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33366 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33366) + 256
                                v = mem[64] + 256
                                while s < _33366:
                                    mem[v] = u + -_33270 - 256
                                    _36450 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36452 = mem[_36450 + 32]
                                    mem[u + 32] = 96
                                    _36573 = mem[_36452]
                                    mem[u + 96] = mem[_36452]
                                    idx = 0
                                    w = _36452 + 32
                                    x = u + 128
                                    while idx < _36573:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40278 = mem[_36450 + 64]
                                    mem[u + 64] = (32 * _36573) + 128
                                    _40279 = mem[_40278]
                                    mem[u + (32 * _36573) + 128] = mem[_40278]
                                    w = u + (32 * _36573) + 160
                                    idx = 0
                                    x = _40278 + 32
                                    while idx < _40279:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36573) + (32 * _40279) + 160
                                    v = v + 32
                                    continue 
                                mem[_33270 + 128] = mem[_29686 + 32]
                                mem[_33270 + 160] = bool(mem[_29686 + 64])
                                mem[_33270 + 192] = bool(mem[_29686 + 96])
                                mem[_33270 + 64] = u + -_33270 - 32
                                _36702 = mem[_30024]
                                mem[u] = mem[_30024]
                                s = 0
                                while s < _36702:
                                    mem[s + u + 32] = mem[_30024 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36702) <= _36702:
                                    _40346 = mem[64]
                                    mem[mem[64]] = ceil32(_36702) + u - mem[64]
                                    mem[64] = ceil32(_36702) + u + 32
                                    mem[ceil32(_36702) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36702) + u + 36] = _30346
                                    mem[ceil32(_36702) + u + 68] = 0
                                    mem[ceil32(_36702) + u + 100] = this.address
                                    mem[ceil32(_36702) + u + 132] = 128
                                    _40466 = mem[_40346]
                                    mem[ceil32(_36702) + u + 164] = mem[_40346]
                                    s = 0
                                    while s < _40466:
                                        mem[s + ceil32(_36702) + u + 196] = mem[_40346 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40466) <= _40466:
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30346, 0, address(this.address), 128, mem[ceil32(_36702) + u + 164 len ceil32(_40466) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36702) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36702) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36702) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46942 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46942] = return_data.size
                                            mem[_46942 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36702) + u + _40466 + 196] = 0
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30346, 0, address(this.address), 128, mem[ceil32(_36702) + u + 164 len ceil32(_40466) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36702) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36702) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36702) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46943 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46943] = return_data.size
                                            mem[_46943 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36702 + 32] = 0
                                    _40422 = mem[64]
                                    mem[mem[64]] = ceil32(_36702) + u - mem[64]
                                    mem[64] = ceil32(_36702) + u + 32
                                    mem[ceil32(_36702) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36702) + u + 36] = _30346
                                    mem[ceil32(_36702) + u + 68] = 0
                                    mem[ceil32(_36702) + u + 100] = this.address
                                    mem[ceil32(_36702) + u + 132] = 128
                                    _40498 = mem[_40422]
                                    mem[ceil32(_36702) + u + 164] = mem[_40422]
                                    s = 0
                                    while s < _40498:
                                        mem[s + ceil32(_36702) + u + 196] = mem[_40422 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40498) <= _40498:
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30346, 0, address(this.address), 128, mem[ceil32(_36702) + u + 164 len ceil32(_40498) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36702) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36702) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36702) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46944 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46944] = return_data.size
                                            mem[_46944 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36702) + u + _40498 + 196] = 0
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30346, 0, address(this.address), 128, mem[ceil32(_36702) + u + 164 len ceil32(_40498) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36702) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36702) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36702) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36702) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36702) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46945 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46945] = return_data.size
                                            mem[_46945 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33271 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33367 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33367) + 256
                                v = mem[64] + 256
                                while s < _33367:
                                    mem[v] = u + -_33271 - 256
                                    _36453 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36455 = mem[_36453 + 32]
                                    mem[u + 32] = 96
                                    _36577 = mem[_36455]
                                    mem[u + 96] = mem[_36455]
                                    idx = 0
                                    w = _36455 + 32
                                    x = u + 128
                                    while idx < _36577:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40280 = mem[_36453 + 64]
                                    mem[u + 64] = (32 * _36577) + 128
                                    _40281 = mem[_40280]
                                    mem[u + (32 * _36577) + 128] = mem[_40280]
                                    w = u + (32 * _36577) + 160
                                    idx = 0
                                    x = _40280 + 32
                                    while idx < _40281:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36577) + (32 * _40281) + 160
                                    v = v + 32
                                    continue 
                                mem[_33271 + 128] = mem[_29686 + 32]
                                mem[_33271 + 160] = bool(mem[_29686 + 64])
                                mem[_33271 + 192] = bool(mem[_29686 + 96])
                                mem[_33271 + 64] = u + -_33271 - 32
                                _36703 = mem[_30024]
                                mem[u] = mem[_30024]
                                s = 0
                                while s < _36703:
                                    mem[s + u + 32] = mem[_30024 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36703) <= _36703:
                                    _40348 = mem[64]
                                    mem[mem[64]] = ceil32(_36703) + u - mem[64]
                                    mem[64] = ceil32(_36703) + u + 32
                                    mem[ceil32(_36703) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36703) + u + 36] = 0
                                    mem[ceil32(_36703) + u + 68] = _30346
                                    mem[ceil32(_36703) + u + 100] = this.address
                                    mem[ceil32(_36703) + u + 132] = 128
                                    _40467 = mem[_40348]
                                    mem[ceil32(_36703) + u + 164] = mem[_40348]
                                    s = 0
                                    while s < _40467:
                                        mem[s + ceil32(_36703) + u + 196] = mem[_40348 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40467) <= _40467:
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30346, address(this.address), 128, mem[ceil32(_36703) + u + 164 len ceil32(_40467) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36703) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36703) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36703) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46946 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46946] = return_data.size
                                            mem[_46946 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36703) + u + _40467 + 196] = 0
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30346, address(this.address), 128, mem[ceil32(_36703) + u + 164 len ceil32(_40467) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36703) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36703) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36703) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46947 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46947] = return_data.size
                                            mem[_46947 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36703 + 32] = 0
                                    _40423 = mem[64]
                                    mem[mem[64]] = ceil32(_36703) + u - mem[64]
                                    mem[64] = ceil32(_36703) + u + 32
                                    mem[ceil32(_36703) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36703) + u + 36] = 0
                                    mem[ceil32(_36703) + u + 68] = _30346
                                    mem[ceil32(_36703) + u + 100] = this.address
                                    mem[ceil32(_36703) + u + 132] = 128
                                    _40499 = mem[_40423]
                                    mem[ceil32(_36703) + u + 164] = mem[_40423]
                                    s = 0
                                    while s < _40499:
                                        mem[s + ceil32(_36703) + u + 196] = mem[_40423 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40499) <= _40499:
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30346, address(this.address), 128, mem[ceil32(_36703) + u + 164 len ceil32(_40499) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36703) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36703) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36703) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46948 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46948] = return_data.size
                                            mem[_46948 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36703) + u + _40499 + 196] = 0
                                        require ext_code.size(address(_31482))
                                        call address(_31482).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30346, address(this.address), 128, mem[ceil32(_36703) + u + 164 len ceil32(_40499) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36703) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36703) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36703) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36703) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36703) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46949 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46949] = return_data.size
                                            mem[_46949 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        else:
                            mem[_22156 + ceil32(return_data.size) + 128 len 32 * _22358] = call.data[calldata.size len 32 * _22358]
                            require 0 < mem[_22156 + ceil32(return_data.size) + 96]
                            mem[_22156 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29439 = mem[_22156]
                            s = 0
                            while s < _29439 - 1:
                                require s < mem[_22156]
                                _29508 = mem[(32 * s) + _22156 + 32]
                                require s + 1 < mem[_22156]
                                _29579 = mem[(32 * s + 1) + _22156 + 32]
                                if mem[(32 * s) + _22156 + 44 len 20] == mem[(32 * s + 1) + _22156 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22156 + 44 len 20] < mem[(32 * s + 1) + _22156 + 44 len 20]:
                                    if not mem[(32 * s) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29579)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29508) == address(_29508):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22156 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22156 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29579)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22156 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29579) == address(_29508):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22156 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22156 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22156 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22156 + ceil32(return_data.size) + 96]
                            if _22203 + cd[((160 * idx) + cd[4] + 68)] > mem[_22156 + ceil32(return_data.size) + 160]:
                            _29687 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29687] = _7368
                            mem[_29687 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29687 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29687 + 96] = 1
                            _30025 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30025] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30287 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30353 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30482 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30649 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30825 = mem[_30649]
                            require mem[_30649] == mem[_30649 + 12 len 20]
                            mem[mem[64] + 4] = address(_30287)
                            mem[mem[64] + 36] = address(_30482)
                            require ext_code.size(address(_30825))
                            staticcall address(_30825).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30287), address(_30482)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31355 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31491 = mem[_31355]
                            require mem[_31355] == mem[_31355 + 12 len 20]
                            require ext_code.size(mem[_31355 + 12 len 20])
                            staticcall mem[_31355 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32517 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32517] == mem[_32517 + 12 len 20]
                            if address(_30287) == mem[_32517 + 12 len 20]:
                                _33272 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33368 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33368) + 256
                                v = mem[64] + 256
                                while s < _33368:
                                    mem[v] = u + -_33272 - 256
                                    _36456 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36458 = mem[_36456 + 32]
                                    mem[u + 32] = 96
                                    _36581 = mem[_36458]
                                    mem[u + 96] = mem[_36458]
                                    idx = 0
                                    w = _36458 + 32
                                    x = u + 128
                                    while idx < _36581:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40282 = mem[_36456 + 64]
                                    mem[u + 64] = (32 * _36581) + 128
                                    _40283 = mem[_40282]
                                    mem[u + (32 * _36581) + 128] = mem[_40282]
                                    w = u + (32 * _36581) + 160
                                    idx = 0
                                    x = _40282 + 32
                                    while idx < _40283:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36581) + (32 * _40283) + 160
                                    v = v + 32
                                    continue 
                                mem[_33272 + 128] = mem[_29687 + 32]
                                mem[_33272 + 160] = bool(mem[_29687 + 64])
                                mem[_33272 + 192] = bool(mem[_29687 + 96])
                                mem[_33272 + 64] = u + -_33272 - 32
                                _36704 = mem[_30025]
                                mem[u] = mem[_30025]
                                s = 0
                                while s < _36704:
                                    mem[s + u + 32] = mem[_30025 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36704) <= _36704:
                                    _40350 = mem[64]
                                    mem[mem[64]] = ceil32(_36704) + u - mem[64]
                                    mem[64] = ceil32(_36704) + u + 32
                                    mem[ceil32(_36704) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36704) + u + 36] = _30353
                                    mem[ceil32(_36704) + u + 68] = 0
                                    mem[ceil32(_36704) + u + 100] = this.address
                                    mem[ceil32(_36704) + u + 132] = 128
                                    _40468 = mem[_40350]
                                    mem[ceil32(_36704) + u + 164] = mem[_40350]
                                    s = 0
                                    while s < _40468:
                                        mem[s + ceil32(_36704) + u + 196] = mem[_40350 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40468) <= _40468:
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30353, 0, address(this.address), 128, mem[ceil32(_36704) + u + 164 len ceil32(_40468) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36704) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36704) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36704) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46950 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46950] = return_data.size
                                            mem[_46950 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36704) + u + _40468 + 196] = 0
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30353, 0, address(this.address), 128, mem[ceil32(_36704) + u + 164 len ceil32(_40468) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36704) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36704) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36704) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46951] = return_data.size
                                            mem[_46951 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36704 + 32] = 0
                                    _40424 = mem[64]
                                    mem[mem[64]] = ceil32(_36704) + u - mem[64]
                                    mem[64] = ceil32(_36704) + u + 32
                                    mem[ceil32(_36704) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36704) + u + 36] = _30353
                                    mem[ceil32(_36704) + u + 68] = 0
                                    mem[ceil32(_36704) + u + 100] = this.address
                                    mem[ceil32(_36704) + u + 132] = 128
                                    _40500 = mem[_40424]
                                    mem[ceil32(_36704) + u + 164] = mem[_40424]
                                    s = 0
                                    while s < _40500:
                                        mem[s + ceil32(_36704) + u + 196] = mem[_40424 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40500) <= _40500:
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30353, 0, address(this.address), 128, mem[ceil32(_36704) + u + 164 len ceil32(_40500) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36704) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36704) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36704) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46952 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46952] = return_data.size
                                            mem[_46952 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36704) + u + _40500 + 196] = 0
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30353, 0, address(this.address), 128, mem[ceil32(_36704) + u + 164 len ceil32(_40500) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36704) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36704) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36704) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36704) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36704) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46953 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46953] = return_data.size
                                            mem[_46953 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33273 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33369 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33369) + 256
                                v = mem[64] + 256
                                while s < _33369:
                                    mem[v] = u + -_33273 - 256
                                    _36459 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36461 = mem[_36459 + 32]
                                    mem[u + 32] = 96
                                    _36585 = mem[_36461]
                                    mem[u + 96] = mem[_36461]
                                    idx = 0
                                    w = _36461 + 32
                                    x = u + 128
                                    while idx < _36585:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40284 = mem[_36459 + 64]
                                    mem[u + 64] = (32 * _36585) + 128
                                    _40285 = mem[_40284]
                                    mem[u + (32 * _36585) + 128] = mem[_40284]
                                    w = u + (32 * _36585) + 160
                                    idx = 0
                                    x = _40284 + 32
                                    while idx < _40285:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36585) + (32 * _40285) + 160
                                    v = v + 32
                                    continue 
                                mem[_33273 + 128] = mem[_29687 + 32]
                                mem[_33273 + 160] = bool(mem[_29687 + 64])
                                mem[_33273 + 192] = bool(mem[_29687 + 96])
                                mem[_33273 + 64] = u + -_33273 - 32
                                _36705 = mem[_30025]
                                mem[u] = mem[_30025]
                                s = 0
                                while s < _36705:
                                    mem[s + u + 32] = mem[_30025 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36705) <= _36705:
                                    _40352 = mem[64]
                                    mem[mem[64]] = ceil32(_36705) + u - mem[64]
                                    mem[64] = ceil32(_36705) + u + 32
                                    mem[ceil32(_36705) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36705) + u + 36] = 0
                                    mem[ceil32(_36705) + u + 68] = _30353
                                    mem[ceil32(_36705) + u + 100] = this.address
                                    mem[ceil32(_36705) + u + 132] = 128
                                    _40469 = mem[_40352]
                                    mem[ceil32(_36705) + u + 164] = mem[_40352]
                                    s = 0
                                    while s < _40469:
                                        mem[s + ceil32(_36705) + u + 196] = mem[_40352 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40469) <= _40469:
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30353, address(this.address), 128, mem[ceil32(_36705) + u + 164 len ceil32(_40469) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36705) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36705) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36705) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46954 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46954] = return_data.size
                                            mem[_46954 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36705) + u + _40469 + 196] = 0
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30353, address(this.address), 128, mem[ceil32(_36705) + u + 164 len ceil32(_40469) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36705) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36705) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36705) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46955 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46955] = return_data.size
                                            mem[_46955 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36705 + 32] = 0
                                    _40425 = mem[64]
                                    mem[mem[64]] = ceil32(_36705) + u - mem[64]
                                    mem[64] = ceil32(_36705) + u + 32
                                    mem[ceil32(_36705) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36705) + u + 36] = 0
                                    mem[ceil32(_36705) + u + 68] = _30353
                                    mem[ceil32(_36705) + u + 100] = this.address
                                    mem[ceil32(_36705) + u + 132] = 128
                                    _40501 = mem[_40425]
                                    mem[ceil32(_36705) + u + 164] = mem[_40425]
                                    s = 0
                                    while s < _40501:
                                        mem[s + ceil32(_36705) + u + 196] = mem[_40425 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40501) <= _40501:
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30353, address(this.address), 128, mem[ceil32(_36705) + u + 164 len ceil32(_40501) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36705) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36705) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36705) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46956 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46956] = return_data.size
                                            mem[_46956 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36705) + u + _40501 + 196] = 0
                                        require ext_code.size(address(_31491))
                                        call address(_31491).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30353, address(this.address), 128, mem[ceil32(_36705) + u + 164 len ceil32(_40501) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36705) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36705) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36705) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36705) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36705) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46957 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46957] = return_data.size
                                            mem[_46957 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
            else:
                _22100 = mem[_7368]
                s = 0
                t = cd[((160 * idx) + cd[4] + 36)]
                while s < _22100:
                    require s < mem[_7368]
                    _22110 = mem[(32 * s) + _7368 + 32]
                    _22111 = mem[mem[(32 * s) + _7368 + 32]]
                    _22112 = mem[mem[(32 * s) + _7368 + 32] + 32]
                    _22113 = mem[64]
                    mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = t
                    mem[mem[64] + 36] = 64
                    _22123 = mem[_22112]
                    mem[mem[64] + 68] = mem[_22112]
                    idx = 0
                    t = _22112 + 32
                    u = mem[64] + 100
                    while idx < _22123:
                        mem[u] = mem[t + 12 len 20]
                        idx = idx + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    require ext_code.size(address(_22111))
                    staticcall address(_22111).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _22113 + (32 * _22123) + -mem[64] + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _29635 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _29695 = mem[_29635]
                    require mem[_29635] <= test266151307()
                    require _29635 + return_data.size > _29635 + mem[_29635] + 31
                    _29755 = mem[_29635 + mem[_29635]]
                    if mem[_29635 + mem[_29635]] <= test266151307():
                        if (32 * mem[_29635 + mem[_29635]]) + 32 >= 0 and _29635 + ceil32(return_data.size) + (32 * mem[_29635 + mem[_29635]]) + 32 <= test266151307():
                            mem[64] = _29635 + ceil32(return_data.size) + (32 * mem[_29635 + mem[_29635]]) + 32
                            mem[_29635 + ceil32(return_data.size)] = _29755
                            require return_data.size >= _29695 + (32 * _29755) + 32
                            t = _29635 + _29695 + 32
                            u = _29635 + ceil32(return_data.size) + 32
                            idx = 0
                            while idx < _29755:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx + 1
                                continue 
                            mem[_22110 + 64] = _29635 + ceil32(return_data.size)
                            if _29755 - 1 < _29755:
                                t = _29635 + _29695 + (32 * _29755) + 33
                                t = mem[(32 * _29755 - 1) + _29635 + ceil32(return_data.size) + 32]
                                continue 
                    revert
                require cd[((160 * idx) + cd[4] + 132)] == bool(cd[((160 * idx) + cd[4] + 132)])
                if not cd[((160 * idx) + cd[4] + 132)]:
                    _22144 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_22144] = _7368
                    mem[_22144 + 32] = cd[((160 * idx) + cd[4] + 36)]
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22144 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22144 + 96] = 1
                    _22163 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_22163] = 0
                    require mem[_7368] - 1 < mem[_7368]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22265 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                    _22289 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22301 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                    staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22319 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22334 = mem[_22319]
                    require mem[_22319] == mem[_22319 + 12 len 20]
                    mem[mem[64] + 4] = address(_22265)
                    mem[mem[64] + 36] = address(_22301)
                    require ext_code.size(address(_22334))
                    staticcall address(_22334).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args address(_22265), address(_22301)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22492 = mem[_22447]
                    require mem[_22447] == mem[_22447 + 12 len 20]
                    require ext_code.size(mem[_22447 + 12 len 20])
                    staticcall mem[_22447 + 12 len 20].token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22657 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_22657] == mem[_22657 + 12 len 20]
                    if address(_22265) == mem[_22657 + 12 len 20]:
                        _23158 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23326 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23326) + 256
                        v = mem[64] + 256
                        while s < _23326:
                            mem[v] = u + -_23158 - 256
                            _29457 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29459 = mem[_29457 + 32]
                            mem[u + 32] = 96
                            _29513 = mem[_29459]
                            mem[u + 96] = mem[_29459]
                            idx = 0
                            w = _29459 + 32
                            x = u + 128
                            while idx < _29513:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36587 = mem[_29457 + 64]
                            mem[u + 64] = (32 * _29513) + 128
                            _36588 = mem[_36587]
                            mem[u + (32 * _29513) + 128] = mem[_36587]
                            w = u + (32 * _29513) + 160
                            idx = 0
                            x = _36587 + 32
                            while idx < _36588:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29513) + (32 * _36588) + 160
                            v = v + 32
                            continue 
                        mem[_23158 + 128] = mem[_22144 + 32]
                        mem[_23158 + 160] = bool(mem[_22144 + 64])
                        mem[_23158 + 192] = bool(mem[_22144 + 96])
                        mem[_23158 + 64] = u + -_23158 - 32
                        _29581 = mem[_22163]
                        mem[u] = mem[_22163]
                        s = 0
                        while s < _29581:
                            mem[s + u + 32] = mem[_22163 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29581) <= _29581:
                            _36746 = mem[64]
                            mem[mem[64]] = ceil32(_29581) + u - mem[64]
                            mem[64] = ceil32(_29581) + u + 32
                            mem[ceil32(_29581) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29581) + u + 36] = _22289
                            mem[ceil32(_29581) + u + 68] = 0
                            mem[ceil32(_29581) + u + 100] = this.address
                            mem[ceil32(_29581) + u + 132] = 128
                            _36888 = mem[_36746]
                            mem[ceil32(_29581) + u + 164] = mem[_36746]
                            s = 0
                            while s < _36888:
                                mem[s + ceil32(_29581) + u + 196] = mem[_36746 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36888) <= _36888:
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22289, 0, address(this.address), 128, mem[ceil32(_29581) + u + 164 len ceil32(_36888) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29581) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29581) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29581) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29581) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29581) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29581) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43830 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43830] = return_data.size
                                    mem[_43830 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29581) + u + _36888 + 196] = 0
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22289, 0, address(this.address), 128, mem[ceil32(_29581) + u + 164 len ceil32(_36888) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29581) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29581) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29581) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29581) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29581) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29581) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43831 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43831] = return_data.size
                                    mem[_43831 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[u + _29581 + 32] = 0
                            _36808 = mem[64]
                            mem[mem[64]] = ceil32(_29581) + u - mem[64]
                            mem[64] = ceil32(_29581) + u + 32
                            mem[ceil32(_29581) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29581) + u + 36] = _22289
                            mem[ceil32(_29581) + u + 68] = 0
                            mem[ceil32(_29581) + u + 100] = this.address
                            mem[ceil32(_29581) + u + 132] = 128
                            _36904 = mem[_36808]
                            mem[ceil32(_29581) + u + 164] = mem[_36808]
                            s = 0
                            while s < _36904:
                                mem[s + ceil32(_29581) + u + 196] = mem[_36808 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36904) > _36904:
                                mem[ceil32(_29581) + u + _36904 + 196] = 0
                            require ext_code.size(address(_22492))
                            call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args _22289, 0, address(this.address), 128, mem[ceil32(_29581) + u + 164 len ceil32(_36904) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(_29581) + u + 36] = this.address
                            require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                            call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                 gas gas_remaining wei
                                args this.address
                            mem[ceil32(_29581) + u + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(_29581) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                            require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                            call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                 gas gas_remaining wei
                                args 0, ext_call.return_data[4 len 28]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] = 0
                            mem[64] = ceil32(_29581) + u + ceil32(return_data.size) + 64
                            t = ceil32(_29581) + u + ceil32(return_data.size) + 64
                            v = ceil32(_29581) + u + ceil32(return_data.size) + 64
                            s = mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]
                            while s >= 32:
                                mem[v] = mem[t]
                                t = t + 32
                                v = v + 32
                                s = s - 32
                                continue 
                            mem[ceil32(_29581) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_29581) + u + ceil32(return_data.size) + -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_29581) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29581) + u + ceil32(return_data.size) + 32]) + 64])
                            call owner with:
                               value 0, ext_call.return_data[4 len 28] wei
                                 gas gas_remaining wei
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 
                                                32,
                                                36,
                                                0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 168 len 28]
                            else:
                                mem[64] = ceil32(_29581) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 64] = return_data.size
                                mem[ceil32(_29581) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 
                                                32,
                                                36,
                                                0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                mem[ceil32(_29581) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                    else:
                        _23159 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23327 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23327) + 256
                        v = mem[64] + 256
                        while s < _23327:
                            mem[v] = u + -_23159 - 256
                            _29460 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29462 = mem[_29460 + 32]
                            mem[u + 32] = 96
                            _29517 = mem[_29462]
                            mem[u + 96] = mem[_29462]
                            idx = 0
                            w = _29462 + 32
                            x = u + 128
                            while idx < _29517:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36589 = mem[_29460 + 64]
                            mem[u + 64] = (32 * _29517) + 128
                            _36590 = mem[_36589]
                            mem[u + (32 * _29517) + 128] = mem[_36589]
                            w = u + (32 * _29517) + 160
                            idx = 0
                            x = _36589 + 32
                            while idx < _36590:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29517) + (32 * _36590) + 160
                            v = v + 32
                            continue 
                        mem[_23159 + 128] = mem[_22144 + 32]
                        mem[_23159 + 160] = bool(mem[_22144 + 64])
                        mem[_23159 + 192] = bool(mem[_22144 + 96])
                        mem[_23159 + 64] = u + -_23159 - 32
                        _29582 = mem[_22163]
                        mem[u] = mem[_22163]
                        s = 0
                        while s < _29582:
                            mem[s + u + 32] = mem[_22163 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29582) <= _29582:
                            _36748 = mem[64]
                            mem[mem[64]] = ceil32(_29582) + u - mem[64]
                            mem[64] = ceil32(_29582) + u + 32
                            mem[ceil32(_29582) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29582) + u + 36] = 0
                            mem[ceil32(_29582) + u + 68] = _22289
                            mem[ceil32(_29582) + u + 100] = this.address
                            mem[ceil32(_29582) + u + 132] = 128
                            _36889 = mem[_36748]
                            mem[ceil32(_29582) + u + 164] = mem[_36748]
                            s = 0
                            while s < _36889:
                                mem[s + ceil32(_29582) + u + 196] = mem[_36748 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36889) <= _36889:
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22289, address(this.address), 128, mem[ceil32(_29582) + u + 164 len ceil32(_36889) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29582) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                v = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                s = mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_29582) + u + ceil32(return_data.size) + -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_29582) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + 64])
                                call owner with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29582) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_29582) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_29582) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_29582) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29582) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                mem[ceil32(_29582) + u + _36889 + 196] = 0
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22289, address(this.address), 128, mem[ceil32(_29582) + u + 164 len ceil32(_36889) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29582) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29582) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29582) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43835 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43835] = return_data.size
                                    mem[_43835 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[u + _29582 + 32] = 0
                            _36809 = mem[64]
                            mem[mem[64]] = ceil32(_29582) + u - mem[64]
                            mem[64] = ceil32(_29582) + u + 32
                            mem[ceil32(_29582) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29582) + u + 36] = 0
                            mem[ceil32(_29582) + u + 68] = _22289
                            mem[ceil32(_29582) + u + 100] = this.address
                            mem[ceil32(_29582) + u + 132] = 128
                            _36905 = mem[_36809]
                            mem[ceil32(_29582) + u + 164] = mem[_36809]
                            s = 0
                            while s < _36905:
                                mem[s + ceil32(_29582) + u + 196] = mem[_36809 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36905) <= _36905:
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22289, address(this.address), 128, mem[ceil32(_29582) + u + 164 len ceil32(_36905) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29582) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29582) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29582) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43836 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43836] = return_data.size
                                    mem[_43836 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29582) + u + _36905 + 196] = 0
                                require ext_code.size(address(_22492))
                                call address(_22492).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22289, address(this.address), 128, mem[ceil32(_29582) + u + 164 len ceil32(_36905) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29582) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29582) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29582) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29582) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29582) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43837 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43837] = return_data.size
                                    mem[_43837 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                else:
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    _22183 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_22183 + 32 len 64] = call.data[calldata.size len 64]
                    if not cd[((160 * idx) + cd[4] + 100)]:
                        require mem[_7368] - 1 < mem[_7368]
                        require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                        _22268 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                        mem[_22183 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22183 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22183 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22183]
                        mem[_22183 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        require 1 < mem[_22183]
                        mem[_22183 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        if mem[_22183] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22183 + ceil32(return_data.size) + 198 len 30]
                        _22381 = mem[_22183]
                        require mem[_22183] <= test266151307()
                        mem[_22183 + ceil32(return_data.size) + 96] = mem[_22183]
                        mem[64] = _22183 + ceil32(return_data.size) + (32 * mem[_22183]) + 128
                        if not _22381:
                            require mem[_22183 + ceil32(return_data.size) + 96] - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22183 + ceil32(return_data.size) + 96] - 1) + _22183 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22183] - 1
                            while s:
                                require s - 1 < mem[_22183]
                                _29519 = mem[(32 * s - 1) + _22183 + 32]
                                require s < mem[_22183]
                                _29584 = mem[(32 * s) + _22183 + 32]
                                if mem[(32 * s - 1) + _22183 + 44 len 20] == mem[(32 * s) + _22183 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22183 + 44 len 20] < mem[(32 * s) + _22183 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29584)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29519) == address(_29519):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29584)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29584) == address(_29519):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22183 + ceil32(return_data.size) + 96]
                            if mem[_22183 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22268:
                            _29691 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29691] = _7368
                            mem[_29691 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29691 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29691 + 96] = 1
                            _30026 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30026] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30291 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30363 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30495 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30662 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30838 = mem[_30662]
                            require mem[_30662] == mem[_30662 + 12 len 20]
                            mem[mem[64] + 4] = address(_30291)
                            mem[mem[64] + 36] = address(_30495)
                            require ext_code.size(address(_30838))
                            staticcall address(_30838).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30291), address(_30495)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31362 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31514 = mem[_31362]
                            require mem[_31362] == mem[_31362 + 12 len 20]
                            require ext_code.size(mem[_31362 + 12 len 20])
                            staticcall mem[_31362 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32518 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32518] == mem[_32518 + 12 len 20]
                            if address(_30291) == mem[_32518 + 12 len 20]:
                                _33274 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33370 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33370) + 256
                                v = mem[64] + 256
                                while s < _33370:
                                    mem[v] = u + -_33274 - 256
                                    _36467 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36469 = mem[_36467 + 32]
                                    mem[u + 32] = 96
                                    _36594 = mem[_36469]
                                    mem[u + 96] = mem[_36469]
                                    idx = 0
                                    w = _36469 + 32
                                    x = u + 128
                                    while idx < _36594:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40286 = mem[_36467 + 64]
                                    mem[u + 64] = (32 * _36594) + 128
                                    _40287 = mem[_40286]
                                    mem[u + (32 * _36594) + 128] = mem[_40286]
                                    w = u + (32 * _36594) + 160
                                    idx = 0
                                    x = _40286 + 32
                                    while idx < _40287:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36594) + (32 * _40287) + 160
                                    v = v + 32
                                    continue 
                                mem[_33274 + 128] = mem[_29691 + 32]
                                mem[_33274 + 160] = bool(mem[_29691 + 64])
                                mem[_33274 + 192] = bool(mem[_29691 + 96])
                                mem[_33274 + 64] = u + -_33274 - 32
                                _36707 = mem[_30026]
                                mem[u] = mem[_30026]
                                s = 0
                                while s < _36707:
                                    mem[s + u + 32] = mem[_30026 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36707) <= _36707:
                                    _40358 = mem[64]
                                    mem[mem[64]] = ceil32(_36707) + u - mem[64]
                                    mem[64] = ceil32(_36707) + u + 32
                                    mem[ceil32(_36707) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36707) + u + 36] = _30363
                                    mem[ceil32(_36707) + u + 68] = 0
                                    mem[ceil32(_36707) + u + 100] = this.address
                                    mem[ceil32(_36707) + u + 132] = 128
                                    _40470 = mem[_40358]
                                    mem[ceil32(_36707) + u + 164] = mem[_40358]
                                    s = 0
                                    while s < _40470:
                                        mem[s + ceil32(_36707) + u + 196] = mem[_40358 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40470) <= _40470:
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30363, 0, address(this.address), 128, mem[ceil32(_36707) + u + 164 len ceil32(_40470) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36707) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36707) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36707) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46958 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46958] = return_data.size
                                            mem[_46958 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36707) + u + _40470 + 196] = 0
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30363, 0, address(this.address), 128, mem[ceil32(_36707) + u + 164 len ceil32(_40470) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36707) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36707) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36707) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46959 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46959] = return_data.size
                                            mem[_46959 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36707 + 32] = 0
                                    _40430 = mem[64]
                                    mem[mem[64]] = ceil32(_36707) + u - mem[64]
                                    mem[64] = ceil32(_36707) + u + 32
                                    mem[ceil32(_36707) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36707) + u + 36] = _30363
                                    mem[ceil32(_36707) + u + 68] = 0
                                    mem[ceil32(_36707) + u + 100] = this.address
                                    mem[ceil32(_36707) + u + 132] = 128
                                    _40502 = mem[_40430]
                                    mem[ceil32(_36707) + u + 164] = mem[_40430]
                                    s = 0
                                    while s < _40502:
                                        mem[s + ceil32(_36707) + u + 196] = mem[_40430 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40502) <= _40502:
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30363, 0, address(this.address), 128, mem[ceil32(_36707) + u + 164 len ceil32(_40502) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36707) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36707) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36707) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46960 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46960] = return_data.size
                                            mem[_46960 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36707) + u + _40502 + 196] = 0
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30363, 0, address(this.address), 128, mem[ceil32(_36707) + u + 164 len ceil32(_40502) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36707) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36707) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36707) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36707) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36707) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46961 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46961] = return_data.size
                                            mem[_46961 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33275 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33371 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33371) + 256
                                v = mem[64] + 256
                                while s < _33371:
                                    mem[v] = u + -_33275 - 256
                                    _36470 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36472 = mem[_36470 + 32]
                                    mem[u + 32] = 96
                                    _36598 = mem[_36472]
                                    mem[u + 96] = mem[_36472]
                                    idx = 0
                                    w = _36472 + 32
                                    x = u + 128
                                    while idx < _36598:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40288 = mem[_36470 + 64]
                                    mem[u + 64] = (32 * _36598) + 128
                                    _40289 = mem[_40288]
                                    mem[u + (32 * _36598) + 128] = mem[_40288]
                                    w = u + (32 * _36598) + 160
                                    idx = 0
                                    x = _40288 + 32
                                    while idx < _40289:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36598) + (32 * _40289) + 160
                                    v = v + 32
                                    continue 
                                mem[_33275 + 128] = mem[_29691 + 32]
                                mem[_33275 + 160] = bool(mem[_29691 + 64])
                                mem[_33275 + 192] = bool(mem[_29691 + 96])
                                mem[_33275 + 64] = u + -_33275 - 32
                                _36708 = mem[_30026]
                                mem[u] = mem[_30026]
                                s = 0
                                while s < _36708:
                                    mem[s + u + 32] = mem[_30026 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36708) <= _36708:
                                    _40360 = mem[64]
                                    mem[mem[64]] = ceil32(_36708) + u - mem[64]
                                    mem[64] = ceil32(_36708) + u + 32
                                    mem[ceil32(_36708) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36708) + u + 36] = 0
                                    mem[ceil32(_36708) + u + 68] = _30363
                                    mem[ceil32(_36708) + u + 100] = this.address
                                    mem[ceil32(_36708) + u + 132] = 128
                                    _40471 = mem[_40360]
                                    mem[ceil32(_36708) + u + 164] = mem[_40360]
                                    s = 0
                                    while s < _40471:
                                        mem[s + ceil32(_36708) + u + 196] = mem[_40360 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40471) <= _40471:
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30363, address(this.address), 128, mem[ceil32(_36708) + u + 164 len ceil32(_40471) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36708) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36708) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36708) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46962 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46962] = return_data.size
                                            mem[_46962 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36708) + u + _40471 + 196] = 0
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30363, address(this.address), 128, mem[ceil32(_36708) + u + 164 len ceil32(_40471) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36708) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36708) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36708) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46963 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46963] = return_data.size
                                            mem[_46963 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36708 + 32] = 0
                                    _40431 = mem[64]
                                    mem[mem[64]] = ceil32(_36708) + u - mem[64]
                                    mem[64] = ceil32(_36708) + u + 32
                                    mem[ceil32(_36708) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36708) + u + 36] = 0
                                    mem[ceil32(_36708) + u + 68] = _30363
                                    mem[ceil32(_36708) + u + 100] = this.address
                                    mem[ceil32(_36708) + u + 132] = 128
                                    _40503 = mem[_40431]
                                    mem[ceil32(_36708) + u + 164] = mem[_40431]
                                    s = 0
                                    while s < _40503:
                                        mem[s + ceil32(_36708) + u + 196] = mem[_40431 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40503) <= _40503:
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30363, address(this.address), 128, mem[ceil32(_36708) + u + 164 len ceil32(_40503) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36708) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36708) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36708) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46964 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46964] = return_data.size
                                            mem[_46964 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36708) + u + _40503 + 196] = 0
                                        require ext_code.size(address(_31514))
                                        call address(_31514).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30363, address(this.address), 128, mem[ceil32(_36708) + u + 164 len ceil32(_40503) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36708) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36708) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36708) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36708) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36708) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46965 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46965] = return_data.size
                                            mem[_46965 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        else:
                            mem[_22183 + ceil32(return_data.size) + 128 len 32 * _22381] = call.data[calldata.size len 32 * _22381]
                            require mem[_22183 + ceil32(return_data.size) + 96] - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22183 + ceil32(return_data.size) + 96] - 1) + _22183 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22183] - 1
                            while s:
                                require s - 1 < mem[_22183]
                                _29522 = mem[(32 * s - 1) + _22183 + 32]
                                require s < mem[_22183]
                                _29586 = mem[(32 * s) + _22183 + 32]
                                if mem[(32 * s - 1) + _22183 + 44 len 20] == mem[(32 * s) + _22183 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22183 + 44 len 20] < mem[(32 * s) + _22183 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29586)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29522) == address(_29522):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29586)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29586) == address(_29522):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22183 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22183 + ceil32(return_data.size) + 96]
                            if mem[_22183 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22268:
                            _29692 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29692] = _7368
                            mem[_29692 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29692 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29692 + 96] = 1
                            _30027 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30027] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30294 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30370 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30503 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30671 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30847 = mem[_30671]
                            require mem[_30671] == mem[_30671 + 12 len 20]
                            mem[mem[64] + 4] = address(_30294)
                            mem[mem[64] + 36] = address(_30503)
                            require ext_code.size(address(_30847))
                            staticcall address(_30847).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30294), address(_30503)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31363 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31531 = mem[_31363]
                            require mem[_31363] == mem[_31363 + 12 len 20]
                            require ext_code.size(mem[_31363 + 12 len 20])
                            staticcall mem[_31363 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32527 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32527] == mem[_32527 + 12 len 20]
                            if address(_30294) == mem[_32527 + 12 len 20]:
                                _33276 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33372 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33372) + 256
                                v = mem[64] + 256
                                while s < _33372:
                                    mem[v] = u + -_33276 - 256
                                    _36473 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36475 = mem[_36473 + 32]
                                    mem[u + 32] = 96
                                    _36602 = mem[_36475]
                                    mem[u + 96] = mem[_36475]
                                    idx = 0
                                    w = _36475 + 32
                                    x = u + 128
                                    while idx < _36602:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40290 = mem[_36473 + 64]
                                    mem[u + 64] = (32 * _36602) + 128
                                    _40291 = mem[_40290]
                                    mem[u + (32 * _36602) + 128] = mem[_40290]
                                    w = u + (32 * _36602) + 160
                                    idx = 0
                                    x = _40290 + 32
                                    while idx < _40291:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36602) + (32 * _40291) + 160
                                    v = v + 32
                                    continue 
                                mem[_33276 + 128] = mem[_29692 + 32]
                                mem[_33276 + 160] = bool(mem[_29692 + 64])
                                mem[_33276 + 192] = bool(mem[_29692 + 96])
                                mem[_33276 + 64] = u + -_33276 - 32
                                _36709 = mem[_30027]
                                mem[u] = mem[_30027]
                                s = 0
                                while s < _36709:
                                    mem[s + u + 32] = mem[_30027 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36709) <= _36709:
                                    _40362 = mem[64]
                                    mem[mem[64]] = ceil32(_36709) + u - mem[64]
                                    mem[64] = ceil32(_36709) + u + 32
                                    mem[ceil32(_36709) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36709) + u + 36] = _30370
                                    mem[ceil32(_36709) + u + 68] = 0
                                    mem[ceil32(_36709) + u + 100] = this.address
                                    mem[ceil32(_36709) + u + 132] = 128
                                    _40472 = mem[_40362]
                                    mem[ceil32(_36709) + u + 164] = mem[_40362]
                                    s = 0
                                    while s < _40472:
                                        mem[s + ceil32(_36709) + u + 196] = mem[_40362 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40472) <= _40472:
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30370, 0, address(this.address), 128, mem[ceil32(_36709) + u + 164 len ceil32(_40472) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36709) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36709) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36709) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46966 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46966] = return_data.size
                                            mem[_46966 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36709) + u + _40472 + 196] = 0
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30370, 0, address(this.address), 128, mem[ceil32(_36709) + u + 164 len ceil32(_40472) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36709) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36709) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36709) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46967 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46967] = return_data.size
                                            mem[_46967 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36709 + 32] = 0
                                    _40432 = mem[64]
                                    mem[mem[64]] = ceil32(_36709) + u - mem[64]
                                    mem[64] = ceil32(_36709) + u + 32
                                    mem[ceil32(_36709) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36709) + u + 36] = _30370
                                    mem[ceil32(_36709) + u + 68] = 0
                                    mem[ceil32(_36709) + u + 100] = this.address
                                    mem[ceil32(_36709) + u + 132] = 128
                                    _40504 = mem[_40432]
                                    mem[ceil32(_36709) + u + 164] = mem[_40432]
                                    s = 0
                                    while s < _40504:
                                        mem[s + ceil32(_36709) + u + 196] = mem[_40432 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40504) <= _40504:
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30370, 0, address(this.address), 128, mem[ceil32(_36709) + u + 164 len ceil32(_40504) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36709) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36709) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36709) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46968 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46968] = return_data.size
                                            mem[_46968 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36709) + u + _40504 + 196] = 0
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30370, 0, address(this.address), 128, mem[ceil32(_36709) + u + 164 len ceil32(_40504) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36709) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36709) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36709) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36709) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36709) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46969 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46969] = return_data.size
                                            mem[_46969 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33277 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33373 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33373) + 256
                                v = mem[64] + 256
                                while s < _33373:
                                    mem[v] = u + -_33277 - 256
                                    _36476 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36478 = mem[_36476 + 32]
                                    mem[u + 32] = 96
                                    _36606 = mem[_36478]
                                    mem[u + 96] = mem[_36478]
                                    idx = 0
                                    w = _36478 + 32
                                    x = u + 128
                                    while idx < _36606:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40292 = mem[_36476 + 64]
                                    mem[u + 64] = (32 * _36606) + 128
                                    _40293 = mem[_40292]
                                    mem[u + (32 * _36606) + 128] = mem[_40292]
                                    w = u + (32 * _36606) + 160
                                    idx = 0
                                    x = _40292 + 32
                                    while idx < _40293:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36606) + (32 * _40293) + 160
                                    v = v + 32
                                    continue 
                                mem[_33277 + 128] = mem[_29692 + 32]
                                mem[_33277 + 160] = bool(mem[_29692 + 64])
                                mem[_33277 + 192] = bool(mem[_29692 + 96])
                                mem[_33277 + 64] = u + -_33277 - 32
                                _36710 = mem[_30027]
                                mem[u] = mem[_30027]
                                s = 0
                                while s < _36710:
                                    mem[s + u + 32] = mem[_30027 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36710) <= _36710:
                                    _40364 = mem[64]
                                    mem[mem[64]] = ceil32(_36710) + u - mem[64]
                                    mem[64] = ceil32(_36710) + u + 32
                                    mem[ceil32(_36710) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36710) + u + 36] = 0
                                    mem[ceil32(_36710) + u + 68] = _30370
                                    mem[ceil32(_36710) + u + 100] = this.address
                                    mem[ceil32(_36710) + u + 132] = 128
                                    _40473 = mem[_40364]
                                    mem[ceil32(_36710) + u + 164] = mem[_40364]
                                    s = 0
                                    while s < _40473:
                                        mem[s + ceil32(_36710) + u + 196] = mem[_40364 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40473) <= _40473:
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30370, address(this.address), 128, mem[ceil32(_36710) + u + 164 len ceil32(_40473) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36710) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36710) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36710) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46970 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46970] = return_data.size
                                            mem[_46970 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36710) + u + _40473 + 196] = 0
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30370, address(this.address), 128, mem[ceil32(_36710) + u + 164 len ceil32(_40473) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36710) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36710) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36710) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46971 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46971] = return_data.size
                                            mem[_46971 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36710 + 32] = 0
                                    _40433 = mem[64]
                                    mem[mem[64]] = ceil32(_36710) + u - mem[64]
                                    mem[64] = ceil32(_36710) + u + 32
                                    mem[ceil32(_36710) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36710) + u + 36] = 0
                                    mem[ceil32(_36710) + u + 68] = _30370
                                    mem[ceil32(_36710) + u + 100] = this.address
                                    mem[ceil32(_36710) + u + 132] = 128
                                    _40505 = mem[_40433]
                                    mem[ceil32(_36710) + u + 164] = mem[_40433]
                                    s = 0
                                    while s < _40505:
                                        mem[s + ceil32(_36710) + u + 196] = mem[_40433 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40505) <= _40505:
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30370, address(this.address), 128, mem[ceil32(_36710) + u + 164 len ceil32(_40505) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36710) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36710) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36710) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46972 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46972] = return_data.size
                                            mem[_46972 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36710) + u + _40505 + 196] = 0
                                        require ext_code.size(address(_31531))
                                        call address(_31531).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30370, address(this.address), 128, mem[ceil32(_36710) + u + 164 len ceil32(_40505) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36710) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36710) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36710) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36710) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36710) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46973 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46973] = return_data.size
                                            mem[_46973 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                    else:
                        require 0 < mem[_7368]
                        require 0 < mem[mem[mem[_7368 + 32] + 64]]
                        _22270 = mem[mem[mem[_7368 + 32] + 64] + 32]
                        mem[_22183 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22183 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22183 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22183]
                        mem[_22183 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        require 1 < mem[_22183]
                        mem[_22183 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        if mem[_22183] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22183 + ceil32(return_data.size) + 198 len 30]
                        _22384 = mem[_22183]
                        require mem[_22183] <= test266151307()
                        mem[_22183 + ceil32(return_data.size) + 96] = mem[_22183]
                        mem[64] = _22183 + ceil32(return_data.size) + (32 * mem[_22183]) + 128
                        if not _22384:
                            require 0 < mem[_22183 + ceil32(return_data.size) + 96]
                            mem[_22183 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29440 = mem[_22183]
                            s = 0
                            while s < _29440 - 1:
                                require s < mem[_22183]
                                _29525 = mem[(32 * s) + _22183 + 32]
                                require s + 1 < mem[_22183]
                                _29588 = mem[(32 * s + 1) + _22183 + 32]
                                if mem[(32 * s) + _22183 + 44 len 20] == mem[(32 * s + 1) + _22183 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22183 + 44 len 20] < mem[(32 * s + 1) + _22183 + 44 len 20]:
                                    if not mem[(32 * s) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29588)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29525) == address(_29525):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29588)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29588) == address(_29525):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22183 + ceil32(return_data.size) + 96]
                            if _22270 + cd[((160 * idx) + cd[4] + 68)] > mem[_22183 + ceil32(return_data.size) + 160]:
                            _29693 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29693] = _7368
                            mem[_29693 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29693 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29693 + 96] = 1
                            _30028 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30028] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30297 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30377 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30511 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30680 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30856 = mem[_30680]
                            require mem[_30680] == mem[_30680 + 12 len 20]
                            mem[mem[64] + 4] = address(_30297)
                            mem[mem[64] + 36] = address(_30511)
                            require ext_code.size(address(_30856))
                            staticcall address(_30856).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30297), address(_30511)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31364 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31548 = mem[_31364]
                            require mem[_31364] == mem[_31364 + 12 len 20]
                            require ext_code.size(mem[_31364 + 12 len 20])
                            staticcall mem[_31364 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32536 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32536] == mem[_32536 + 12 len 20]
                            if address(_30297) == mem[_32536 + 12 len 20]:
                                _33278 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33374 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33374) + 256
                                v = mem[64] + 256
                                while s < _33374:
                                    mem[v] = u + -_33278 - 256
                                    _36479 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36481 = mem[_36479 + 32]
                                    mem[u + 32] = 96
                                    _36610 = mem[_36481]
                                    mem[u + 96] = mem[_36481]
                                    idx = 0
                                    w = _36481 + 32
                                    x = u + 128
                                    while idx < _36610:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40294 = mem[_36479 + 64]
                                    mem[u + 64] = (32 * _36610) + 128
                                    _40295 = mem[_40294]
                                    mem[u + (32 * _36610) + 128] = mem[_40294]
                                    w = u + (32 * _36610) + 160
                                    idx = 0
                                    x = _40294 + 32
                                    while idx < _40295:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36610) + (32 * _40295) + 160
                                    v = v + 32
                                    continue 
                                mem[_33278 + 128] = mem[_29693 + 32]
                                mem[_33278 + 160] = bool(mem[_29693 + 64])
                                mem[_33278 + 192] = bool(mem[_29693 + 96])
                                mem[_33278 + 64] = u + -_33278 - 32
                                _36711 = mem[_30028]
                                mem[u] = mem[_30028]
                                s = 0
                                while s < _36711:
                                    mem[s + u + 32] = mem[_30028 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36711) <= _36711:
                                    _40366 = mem[64]
                                    mem[mem[64]] = ceil32(_36711) + u - mem[64]
                                    mem[64] = ceil32(_36711) + u + 32
                                    mem[ceil32(_36711) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36711) + u + 36] = _30377
                                    mem[ceil32(_36711) + u + 68] = 0
                                    mem[ceil32(_36711) + u + 100] = this.address
                                    mem[ceil32(_36711) + u + 132] = 128
                                    _40474 = mem[_40366]
                                    mem[ceil32(_36711) + u + 164] = mem[_40366]
                                    s = 0
                                    while s < _40474:
                                        mem[s + ceil32(_36711) + u + 196] = mem[_40366 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40474) <= _40474:
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30377, 0, address(this.address), 128, mem[ceil32(_36711) + u + 164 len ceil32(_40474) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36711) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36711) + u + ceil32(return_data.size) + -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                    else:
                                        mem[ceil32(_36711) + u + _40474 + 196] = 0
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30377, 0, address(this.address), 128, mem[ceil32(_36711) + u + 164 len ceil32(_40474) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36711) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36711) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46975 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46975] = return_data.size
                                            mem[_46975 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                else:
                                    mem[u + _36711 + 32] = 0
                                    _40434 = mem[64]
                                    mem[mem[64]] = ceil32(_36711) + u - mem[64]
                                    mem[64] = ceil32(_36711) + u + 32
                                    mem[ceil32(_36711) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36711) + u + 36] = _30377
                                    mem[ceil32(_36711) + u + 68] = 0
                                    mem[ceil32(_36711) + u + 100] = this.address
                                    mem[ceil32(_36711) + u + 132] = 128
                                    _40506 = mem[_40434]
                                    mem[ceil32(_36711) + u + 164] = mem[_40434]
                                    s = 0
                                    while s < _40506:
                                        mem[s + ceil32(_36711) + u + 196] = mem[_40434 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40506) <= _40506:
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30377, 0, address(this.address), 128, mem[ceil32(_36711) + u + 164 len ceil32(_40506) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36711) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36711) + u + ceil32(return_data.size) + -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36711) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                    else:
                                        mem[ceil32(_36711) + u + _40506 + 196] = 0
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30377, 0, address(this.address), 128, mem[ceil32(_36711) + u + 164 len ceil32(_40506) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36711) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36711) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36711) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36711) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36711) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46977 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46977] = return_data.size
                                            mem[_46977 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                _33279 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33375 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33375) + 256
                                v = mem[64] + 256
                                while s < _33375:
                                    mem[v] = u + -_33279 - 256
                                    _36482 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36484 = mem[_36482 + 32]
                                    mem[u + 32] = 96
                                    _36614 = mem[_36484]
                                    mem[u + 96] = mem[_36484]
                                    idx = 0
                                    w = _36484 + 32
                                    x = u + 128
                                    while idx < _36614:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40296 = mem[_36482 + 64]
                                    mem[u + 64] = (32 * _36614) + 128
                                    _40297 = mem[_40296]
                                    mem[u + (32 * _36614) + 128] = mem[_40296]
                                    w = u + (32 * _36614) + 160
                                    idx = 0
                                    x = _40296 + 32
                                    while idx < _40297:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36614) + (32 * _40297) + 160
                                    v = v + 32
                                    continue 
                                mem[_33279 + 128] = mem[_29693 + 32]
                                mem[_33279 + 160] = bool(mem[_29693 + 64])
                                mem[_33279 + 192] = bool(mem[_29693 + 96])
                                mem[_33279 + 64] = u + -_33279 - 32
                                _36712 = mem[_30028]
                                mem[u] = mem[_30028]
                                s = 0
                                while s < _36712:
                                    mem[s + u + 32] = mem[_30028 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36712) <= _36712:
                                    _40368 = mem[64]
                                    mem[mem[64]] = ceil32(_36712) + u - mem[64]
                                    mem[64] = ceil32(_36712) + u + 32
                                    mem[ceil32(_36712) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36712) + u + 36] = 0
                                    mem[ceil32(_36712) + u + 68] = _30377
                                    mem[ceil32(_36712) + u + 100] = this.address
                                    mem[ceil32(_36712) + u + 132] = 128
                                    _40475 = mem[_40368]
                                    mem[ceil32(_36712) + u + 164] = mem[_40368]
                                    s = 0
                                    while s < _40475:
                                        mem[s + ceil32(_36712) + u + 196] = mem[_40368 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40475) <= _40475:
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30377, address(this.address), 128, mem[ceil32(_36712) + u + 164 len ceil32(_40475) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36712) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36712) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36712) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46978 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46978] = return_data.size
                                            mem[_46978 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36712) + u + _40475 + 196] = 0
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30377, address(this.address), 128, mem[ceil32(_36712) + u + 164 len ceil32(_40475) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36712) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36712) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36712) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46979 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46979] = return_data.size
                                            mem[_46979 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                else:
                                    mem[u + _36712 + 32] = 0
                                    _40435 = mem[64]
                                    mem[mem[64]] = ceil32(_36712) + u - mem[64]
                                    mem[64] = ceil32(_36712) + u + 32
                                    mem[ceil32(_36712) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36712) + u + 36] = 0
                                    mem[ceil32(_36712) + u + 68] = _30377
                                    mem[ceil32(_36712) + u + 100] = this.address
                                    mem[ceil32(_36712) + u + 132] = 128
                                    _40507 = mem[_40435]
                                    mem[ceil32(_36712) + u + 164] = mem[_40435]
                                    s = 0
                                    while s < _40507:
                                        mem[s + ceil32(_36712) + u + 196] = mem[_40435 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40507) <= _40507:
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30377, address(this.address), 128, mem[ceil32(_36712) + u + 164 len ceil32(_40507) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36712) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36712) + u + ceil32(return_data.size) + -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36712) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36712) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36712) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36712) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36712) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36712) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                    else:
                                        mem[ceil32(_36712) + u + _40507 + 196] = 0
                                        require ext_code.size(address(_31548))
                                        call address(_31548).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30377, address(this.address), 128, mem[ceil32(_36712) + u + 164 len ceil32(_40507) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36712) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36712) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36712) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36712) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36712) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46981 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46981] = return_data.size
                                            mem[_46981 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22183 + ceil32(return_data.size) + 128 len 32 * _22384] = call.data[calldata.size len 32 * _22384]
                            require 0 < mem[_22183 + ceil32(return_data.size) + 96]
                            mem[_22183 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29441 = mem[_22183]
                            s = 0
                            while s < _29441 - 1:
                                require s < mem[_22183]
                                _29528 = mem[(32 * s) + _22183 + 32]
                                require s + 1 < mem[_22183]
                                _29590 = mem[(32 * s + 1) + _22183 + 32]
                                if mem[(32 * s) + _22183 + 44 len 20] == mem[(32 * s + 1) + _22183 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22183 + 44 len 20] < mem[(32 * s + 1) + _22183 + 44 len 20]:
                                    if not mem[(32 * s) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29590)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29528) == address(_29528):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22183 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22183 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29590)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22183 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29590) == address(_29528):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22183 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22183 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22183 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22183 + ceil32(return_data.size) + 96]
                            if _22270 + cd[((160 * idx) + cd[4] + 68)] > mem[_22183 + ceil32(return_data.size) + 160]:
                            _29694 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29694] = _7368
                            mem[_29694 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29694 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29694 + 96] = 1
                            _30029 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30029] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30300 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30384 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30519 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30689 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30865 = mem[_30689]
                            require mem[_30689] == mem[_30689 + 12 len 20]
                            mem[mem[64] + 4] = address(_30300)
                            mem[mem[64] + 36] = address(_30519)
                            require ext_code.size(address(_30865))
                            staticcall address(_30865).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30300), address(_30519)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31365 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31557 = mem[_31365]
                            require mem[_31365] == mem[_31365 + 12 len 20]
                            require ext_code.size(mem[_31365 + 12 len 20])
                            staticcall mem[_31365 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32537 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32537] == mem[_32537 + 12 len 20]
                            if address(_30300) != mem[_32537 + 12 len 20]:
                                _33281 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33377 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33377) + 256
                                v = mem[64] + 256
                                while s < _33377:
                                    mem[v] = u + -_33281 - 256
                                    _36488 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36490 = mem[_36488 + 32]
                                    mem[u + 32] = 96
                                    _36622 = mem[_36490]
                                    mem[u + 96] = mem[_36490]
                                    idx = 0
                                    w = _36490 + 32
                                    x = u + 128
                                    while idx < _36622:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40300 = mem[_36488 + 64]
                                    mem[u + 64] = (32 * _36622) + 128
                                    _40301 = mem[_40300]
                                    mem[u + (32 * _36622) + 128] = mem[_40300]
                                    w = u + (32 * _36622) + 160
                                    idx = 0
                                    x = _40300 + 32
                                    while idx < _40301:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36622) + (32 * _40301) + 160
                                    v = v + 32
                                    continue 
                                mem[_33281 + 128] = mem[_29694 + 32]
                                mem[_33281 + 160] = bool(mem[_29694 + 64])
                                mem[_33281 + 192] = bool(mem[_29694 + 96])
                                mem[_33281 + 64] = u + -_33281 - 32
                                _36714 = mem[_30029]
                                mem[u] = mem[_30029]
                                s = 0
                                while s < _36714:
                                    mem[s + u + 32] = mem[_30029 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36714) <= _36714:
                                    _40372 = mem[64]
                                    mem[mem[64]] = ceil32(_36714) + u - mem[64]
                                    mem[64] = ceil32(_36714) + u + 32
                                    mem[ceil32(_36714) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36714) + u + 36] = 0
                                    mem[ceil32(_36714) + u + 68] = _30384
                                    mem[ceil32(_36714) + u + 100] = this.address
                                    mem[ceil32(_36714) + u + 132] = 128
                                    _40477 = mem[_40372]
                                    mem[ceil32(_36714) + u + 164] = mem[_40372]
                                    s = 0
                                    while s < _40477:
                                        mem[s + ceil32(_36714) + u + 196] = mem[_40372 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40477) > _40477:
                                        mem[ceil32(_36714) + u + _40477 + 196] = 0
                                    require ext_code.size(address(_31557))
                                    call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30384, address(this.address), 128, mem[ceil32(_36714) + u + 164 len ceil32(_40477) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36714) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36714) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36714 + 32] = 0
                                    _40437 = mem[64]
                                    mem[mem[64]] = ceil32(_36714) + u - mem[64]
                                    mem[64] = ceil32(_36714) + u + 32
                                    mem[ceil32(_36714) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36714) + u + 36] = 0
                                    mem[ceil32(_36714) + u + 68] = _30384
                                    mem[ceil32(_36714) + u + 100] = this.address
                                    mem[ceil32(_36714) + u + 132] = 128
                                    _40509 = mem[_40437]
                                    mem[ceil32(_36714) + u + 164] = mem[_40437]
                                    s = 0
                                    while s < _40509:
                                        mem[s + ceil32(_36714) + u + 196] = mem[_40437 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40509) > _40509:
                                        mem[ceil32(_36714) + u + _40509 + 196] = 0
                                    require ext_code.size(address(_31557))
                                    call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30384, address(this.address), 128, mem[ceil32(_36714) + u + 164 len ceil32(_40509) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36714) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36714) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36714) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36714) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36714) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36714) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36714) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33280 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33376 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33376) + 256
                                v = mem[64] + 256
                                while s < _33376:
                                    mem[v] = u + -_33280 - 256
                                    _36485 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36487 = mem[_36485 + 32]
                                    mem[u + 32] = 96
                                    _36618 = mem[_36487]
                                    mem[u + 96] = mem[_36487]
                                    idx = 0
                                    w = _36487 + 32
                                    x = u + 128
                                    while idx < _36618:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40298 = mem[_36485 + 64]
                                    mem[u + 64] = (32 * _36618) + 128
                                    _40299 = mem[_40298]
                                    mem[u + (32 * _36618) + 128] = mem[_40298]
                                    w = u + (32 * _36618) + 160
                                    idx = 0
                                    x = _40298 + 32
                                    while idx < _40299:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36618) + (32 * _40299) + 160
                                    v = v + 32
                                    continue 
                                mem[_33280 + 128] = mem[_29694 + 32]
                                mem[_33280 + 160] = bool(mem[_29694 + 64])
                                mem[_33280 + 192] = bool(mem[_29694 + 96])
                                mem[_33280 + 64] = u + -_33280 - 32
                                _36713 = mem[_30029]
                                mem[u] = mem[_30029]
                                s = 0
                                while s < _36713:
                                    mem[s + u + 32] = mem[_30029 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36713) <= _36713:
                                    _40370 = mem[64]
                                    mem[mem[64]] = ceil32(_36713) + u - mem[64]
                                    mem[64] = ceil32(_36713) + u + 32
                                    mem[ceil32(_36713) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36713) + u + 36] = _30384
                                    mem[ceil32(_36713) + u + 68] = 0
                                    mem[ceil32(_36713) + u + 100] = this.address
                                    mem[ceil32(_36713) + u + 132] = 128
                                    _40476 = mem[_40370]
                                    mem[ceil32(_36713) + u + 164] = mem[_40370]
                                    s = 0
                                    while s < _40476:
                                        mem[s + ceil32(_36713) + u + 196] = mem[_40370 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40476) <= _40476:
                                        require ext_code.size(address(_31557))
                                        call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30384, 0, address(this.address), 128, mem[ceil32(_36713) + u + 164 len ceil32(_40476) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36713) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36713) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36713) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46982 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46982] = return_data.size
                                            mem[_46982 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36713) + u + _40476 + 196] = 0
                                        require ext_code.size(address(_31557))
                                        call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30384, 0, address(this.address), 128, mem[ceil32(_36713) + u + 164 len ceil32(_40476) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36713) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36713) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36713) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46983 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46983] = return_data.size
                                            mem[_46983 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36713 + 32] = 0
                                    _40436 = mem[64]
                                    mem[mem[64]] = ceil32(_36713) + u - mem[64]
                                    mem[64] = ceil32(_36713) + u + 32
                                    mem[ceil32(_36713) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36713) + u + 36] = _30384
                                    mem[ceil32(_36713) + u + 68] = 0
                                    mem[ceil32(_36713) + u + 100] = this.address
                                    mem[ceil32(_36713) + u + 132] = 128
                                    _40508 = mem[_40436]
                                    mem[ceil32(_36713) + u + 164] = mem[_40436]
                                    s = 0
                                    while s < _40508:
                                        mem[s + ceil32(_36713) + u + 196] = mem[_40436 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40508) <= _40508:
                                        require ext_code.size(address(_31557))
                                        call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30384, 0, address(this.address), 128, mem[ceil32(_36713) + u + 164 len ceil32(_40508) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36713) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36713) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36713) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46984 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46984] = return_data.size
                                            mem[_46984 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36713) + u + _40508 + 196] = 0
                                        require ext_code.size(address(_31557))
                                        call address(_31557).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30384, 0, address(this.address), 128, mem[ceil32(_36713) + u + 164 len ceil32(_40508) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36713) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36713) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36713) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36713) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36713) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46985 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46985] = return_data.size
                                            mem[_46985 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
        else:
            _14738 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            require 0 < mem[_14738]
            mem[_14738 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
            require 1 < mem[_14738]
            mem[_14738 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
            mem[_14738 + 96] = 0x1b02da8cb0d097eb8d57a175b88c7d8b47997506
            mem[_14738 + 128] = _14738
            mem[_14738 + 192] = 0
            mem[64] = _14738 + 224
            mem[_14738 + 160] = _14738 + 192
            require mem[_7368]
            mem[_7368 + 32] = _14738 + 96
            mem[_14738 + 224] = 2
            mem[_14738 + 256] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
            mem[_14738 + 288] = 0xb54f16fb19478766a268f172c9480f8da1a7c9c3
            mem[_14738 + 320] = address(cd[((160 * idx) + cd[4] + 164)])
            mem[_14738 + 352] = _14738 + 224
            mem[_14738 + 416] = 0
            mem[64] = _14738 + 448
            mem[_14738 + 384] = _14738 + 416
            require 1 < mem[_7368]
            mem[_7368 + 64] = _14738 + 320
            if cd[((160 * idx) + cd[4] + 100)]:
                s = mem[_7368]
                t = cd[((160 * idx) + cd[4] + 36)]
                while s:
                    require s - 1 < mem[_7368]
                    _22114 = mem[(32 * s - 1) + _7368 + 32]
                    _22115 = mem[mem[(32 * s - 1) + _7368 + 32]]
                    _22116 = mem[mem[(32 * s - 1) + _7368 + 32] + 32]
                    _22117 = mem[64]
                    mem[mem[64]] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = t
                    mem[mem[64] + 36] = 64
                    _22124 = mem[_22116]
                    mem[mem[64] + 68] = mem[_22116]
                    idx = 0
                    t = _22116 + 32
                    u = mem[64] + 100
                    while idx < _22124:
                        mem[u] = mem[t + 12 len 20]
                        idx = idx + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    require ext_code.size(address(_22115))
                    staticcall address(_22115).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _22117 + (32 * _22124) + -mem[64] + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _29642 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _29702 = mem[_29642]
                    require mem[_29642] <= test266151307()
                    require _29642 + return_data.size > _29642 + mem[_29642] + 31
                    _29774 = mem[_29642 + mem[_29642]]
                    if mem[_29642 + mem[_29642]] <= test266151307():
                        if (32 * mem[_29642 + mem[_29642]]) + 32 >= 0 and _29642 + ceil32(return_data.size) + (32 * mem[_29642 + mem[_29642]]) + 32 <= test266151307():
                            mem[64] = _29642 + ceil32(return_data.size) + (32 * mem[_29642 + mem[_29642]]) + 32
                            mem[_29642 + ceil32(return_data.size)] = _29774
                            require return_data.size >= _29702 + (32 * _29774) + 32
                            t = _29642 + _29702 + 32
                            u = _29642 + ceil32(return_data.size) + 32
                            idx = 0
                            while idx < _29774:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx + 1
                                continue 
                            mem[_22114 + 64] = _29642 + ceil32(return_data.size)
                            if _29774:
                                t = _29642 + _29702 + (32 * _29774) + 31
                                t = mem[_29642 + ceil32(return_data.size) + 32]
                                continue 
                    revert
                require cd[((160 * idx) + cd[4] + 132)] == bool(cd[((160 * idx) + cd[4] + 132)])
                if not cd[((160 * idx) + cd[4] + 132)]:
                    _22139 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_22139] = _7368
                    mem[_22139 + 32] = cd[((160 * idx) + cd[4] + 36)]
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22139 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22139 + 96] = 1
                    _22153 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_22153] = 0
                    require mem[_7368] - 1 < mem[_7368]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22210 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                    _22240 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22273 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                    staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22322 = mem[_22307]
                    require mem[_22307] == mem[_22307 + 12 len 20]
                    mem[mem[64] + 4] = address(_22210)
                    mem[mem[64] + 36] = address(_22273)
                    require ext_code.size(address(_22322))
                    staticcall address(_22322).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args address(_22210), address(_22273)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22417 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22450 = mem[_22417]
                    require mem[_22417] == mem[_22417 + 12 len 20]
                    require ext_code.size(mem[_22417 + 12 len 20])
                    staticcall mem[_22417 + 12 len 20].token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22595 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_22595] == mem[_22595 + 12 len 20]
                    if address(_22210) != mem[_22595 + 12 len 20]:
                        _23005 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23177 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23177) + 256
                        v = mem[64] + 256
                        while s < _23177:
                            mem[v] = u + -_23005 - 256
                            _29471 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29473 = mem[_29471 + 32]
                            mem[u + 32] = 96
                            _29537 = mem[_29473]
                            mem[u + 96] = mem[_29473]
                            idx = 0
                            w = _29473 + 32
                            x = u + 128
                            while idx < _29537:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36626 = mem[_29471 + 64]
                            mem[u + 64] = (32 * _29537) + 128
                            _36627 = mem[_36626]
                            mem[u + (32 * _29537) + 128] = mem[_36626]
                            w = u + (32 * _29537) + 160
                            idx = 0
                            x = _36626 + 32
                            while idx < _36627:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29537) + (32 * _36627) + 160
                            v = v + 32
                            continue 
                        mem[_23005 + 128] = mem[_22139 + 32]
                        mem[_23005 + 160] = bool(mem[_22139 + 64])
                        mem[_23005 + 192] = bool(mem[_22139 + 96])
                        mem[_23005 + 64] = u + -_23005 - 32
                        _29593 = mem[_22153]
                        mem[u] = mem[_22153]
                        s = 0
                        while s < _29593:
                            mem[s + u + 32] = mem[_22153 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29593) <= _29593:
                            _36760 = mem[64]
                            mem[mem[64]] = ceil32(_29593) + u - mem[64]
                            mem[64] = ceil32(_29593) + u + 32
                            mem[ceil32(_29593) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29593) + u + 36] = 0
                            mem[ceil32(_29593) + u + 68] = _22240
                            mem[ceil32(_29593) + u + 100] = this.address
                            mem[ceil32(_29593) + u + 132] = 128
                            _36891 = mem[_36760]
                            mem[ceil32(_29593) + u + 164] = mem[_36760]
                            s = 0
                            while s < _36891:
                                mem[s + ceil32(_29593) + u + 196] = mem[_36760 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36891) <= _36891:
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22240, address(this.address), 128, mem[ceil32(_29593) + u + 164 len ceil32(_36891) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29593) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29593) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29593) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43842 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43842] = return_data.size
                                    mem[_43842 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29593) + u + _36891 + 196] = 0
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22240, address(this.address), 128, mem[ceil32(_29593) + u + 164 len ceil32(_36891) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29593) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29593) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29593) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43843 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43843] = return_data.size
                                    mem[_43843 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[u + _29593 + 32] = 0
                            _36835 = mem[64]
                            mem[mem[64]] = ceil32(_29593) + u - mem[64]
                            mem[64] = ceil32(_29593) + u + 32
                            mem[ceil32(_29593) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29593) + u + 36] = 0
                            mem[ceil32(_29593) + u + 68] = _22240
                            mem[ceil32(_29593) + u + 100] = this.address
                            mem[ceil32(_29593) + u + 132] = 128
                            _36915 = mem[_36835]
                            mem[ceil32(_29593) + u + 164] = mem[_36835]
                            s = 0
                            while s < _36915:
                                mem[s + ceil32(_29593) + u + 196] = mem[_36835 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36915) <= _36915:
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22240, address(this.address), 128, mem[ceil32(_29593) + u + 164 len ceil32(_36915) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29593) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29593) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29593) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43844 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43844] = return_data.size
                                    mem[_43844 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                mem[ceil32(_29593) + u + _36915 + 196] = 0
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22240, address(this.address), 128, mem[ceil32(_29593) + u + 164 len ceil32(_36915) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29593) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                v = ceil32(_29593) + u + ceil32(return_data.size) + 64
                                s = mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[ceil32(_29593) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_29593) + u + ceil32(return_data.size) + -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_29593) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29593) + u + ceil32(return_data.size) + 32]) + 64])
                                call owner with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29593) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_29593) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_29593) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_29593) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29593) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                    else:
                        _23004 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23176 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23176) + 256
                        v = mem[64] + 256
                        while s < _23176:
                            mem[v] = u + -_23004 - 256
                            _29468 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29470 = mem[_29468 + 32]
                            mem[u + 32] = 96
                            _29533 = mem[_29470]
                            mem[u + 96] = mem[_29470]
                            idx = 0
                            w = _29470 + 32
                            x = u + 128
                            while idx < _29533:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36624 = mem[_29468 + 64]
                            mem[u + 64] = (32 * _29533) + 128
                            _36625 = mem[_36624]
                            mem[u + (32 * _29533) + 128] = mem[_36624]
                            w = u + (32 * _29533) + 160
                            idx = 0
                            x = _36624 + 32
                            while idx < _36625:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29533) + (32 * _36625) + 160
                            v = v + 32
                            continue 
                        mem[_23004 + 128] = mem[_22139 + 32]
                        mem[_23004 + 160] = bool(mem[_22139 + 64])
                        mem[_23004 + 192] = bool(mem[_22139 + 96])
                        mem[_23004 + 64] = u + -_23004 - 32
                        _29592 = mem[_22153]
                        mem[u] = mem[_22153]
                        s = 0
                        while s < _29592:
                            mem[s + u + 32] = mem[_22153 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29592) <= _29592:
                            _36758 = mem[64]
                            mem[mem[64]] = ceil32(_29592) + u - mem[64]
                            mem[64] = ceil32(_29592) + u + 32
                            mem[ceil32(_29592) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29592) + u + 36] = _22240
                            mem[ceil32(_29592) + u + 68] = 0
                            mem[ceil32(_29592) + u + 100] = this.address
                            mem[ceil32(_29592) + u + 132] = 128
                            _36890 = mem[_36758]
                            mem[ceil32(_29592) + u + 164] = mem[_36758]
                            s = 0
                            while s < _36890:
                                mem[s + ceil32(_29592) + u + 196] = mem[_36758 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36890) <= _36890:
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22240, 0, address(this.address), 128, mem[ceil32(_29592) + u + 164 len ceil32(_36890) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29592) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29592) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29592) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43838 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43838] = return_data.size
                                    mem[_43838 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29592) + u + _36890 + 196] = 0
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22240, 0, address(this.address), 128, mem[ceil32(_29592) + u + 164 len ceil32(_36890) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29592) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29592) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29592) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43839 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43839] = return_data.size
                                    mem[_43839 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        else:
                            mem[u + _29592 + 32] = 0
                            _36834 = mem[64]
                            mem[mem[64]] = ceil32(_29592) + u - mem[64]
                            mem[64] = ceil32(_29592) + u + 32
                            mem[ceil32(_29592) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29592) + u + 36] = _22240
                            mem[ceil32(_29592) + u + 68] = 0
                            mem[ceil32(_29592) + u + 100] = this.address
                            mem[ceil32(_29592) + u + 132] = 128
                            _36914 = mem[_36834]
                            mem[ceil32(_29592) + u + 164] = mem[_36834]
                            s = 0
                            while s < _36914:
                                mem[s + ceil32(_29592) + u + 196] = mem[_36834 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36914) <= _36914:
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22240, 0, address(this.address), 128, mem[ceil32(_29592) + u + 164 len ceil32(_36914) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29592) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29592) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29592) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43840 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43840] = return_data.size
                                    mem[_43840 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29592) + u + _36914 + 196] = 0
                                require ext_code.size(address(_22450))
                                call address(_22450).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22240, 0, address(this.address), 128, mem[ceil32(_29592) + u + 164 len ceil32(_36914) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29592) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29592) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29592) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29592) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29592) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43841 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43841] = return_data.size
                                    mem[_43841 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                else:
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    _22157 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_22157 + 32 len 64] = call.data[calldata.size len 64]
                    if not cd[((160 * idx) + cd[4] + 100)]:
                        require mem[_7368] - 1 < mem[_7368]
                        require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                        _22213 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                        mem[_22157 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22157 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22157 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22157]
                        mem[_22157 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        require 1 < mem[_22157]
                        mem[_22157 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        if mem[_22157] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22157 + ceil32(return_data.size) + 198 len 30]
                        _22362 = mem[_22157]
                        require mem[_22157] <= test266151307()
                        mem[_22157 + ceil32(return_data.size) + 96] = mem[_22157]
                        mem[64] = _22157 + ceil32(return_data.size) + (32 * mem[_22157]) + 128
                        if not _22362:
                            require mem[_22157 + ceil32(return_data.size) + 96] - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22157 + ceil32(return_data.size) + 96] - 1) + _22157 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22157] - 1
                            while s:
                                require s - 1 < mem[_22157]
                                _29539 = mem[(32 * s - 1) + _22157 + 32]
                                require s < mem[_22157]
                                _29595 = mem[(32 * s) + _22157 + 32]
                                if mem[(32 * s - 1) + _22157 + 44 len 20] == mem[(32 * s) + _22157 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22157 + 44 len 20] < mem[(32 * s) + _22157 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29595)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29539) == address(_29539):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29595)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29595) == address(_29539):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22157 + ceil32(return_data.size) + 96]
                            if mem[_22157 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22213:
                            _29698 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29698] = _7368
                            mem[_29698 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29698 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29698 + 96] = 1
                            _30030 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30030] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30304 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30394 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30532 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30702 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30878 = mem[_30702]
                            require mem[_30702] == mem[_30702 + 12 len 20]
                            mem[mem[64] + 4] = address(_30304)
                            mem[mem[64] + 36] = address(_30532)
                            require ext_code.size(address(_30878))
                            staticcall address(_30878).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30304), address(_30532)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31372 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31580 = mem[_31372]
                            require mem[_31372] == mem[_31372 + 12 len 20]
                            require ext_code.size(mem[_31372 + 12 len 20])
                            staticcall mem[_31372 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32538 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32538] == mem[_32538 + 12 len 20]
                            if address(_30304) != mem[_32538 + 12 len 20]:
                                _33283 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33379 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33379) + 256
                                v = mem[64] + 256
                                while s < _33379:
                                    mem[v] = u + -_33283 - 256
                                    _36499 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36501 = mem[_36499 + 32]
                                    mem[u + 32] = 96
                                    _36635 = mem[_36501]
                                    mem[u + 96] = mem[_36501]
                                    idx = 0
                                    w = _36501 + 32
                                    x = u + 128
                                    while idx < _36635:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40304 = mem[_36499 + 64]
                                    mem[u + 64] = (32 * _36635) + 128
                                    _40305 = mem[_40304]
                                    mem[u + (32 * _36635) + 128] = mem[_40304]
                                    w = u + (32 * _36635) + 160
                                    idx = 0
                                    x = _40304 + 32
                                    while idx < _40305:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36635) + (32 * _40305) + 160
                                    v = v + 32
                                    continue 
                                mem[_33283 + 128] = mem[_29698 + 32]
                                mem[_33283 + 160] = bool(mem[_29698 + 64])
                                mem[_33283 + 192] = bool(mem[_29698 + 96])
                                mem[_33283 + 64] = u + -_33283 - 32
                                _36717 = mem[_30030]
                                mem[u] = mem[_30030]
                                s = 0
                                while s < _36717:
                                    mem[s + u + 32] = mem[_30030 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36717) <= _36717:
                                    _40380 = mem[64]
                                    mem[mem[64]] = ceil32(_36717) + u - mem[64]
                                    mem[64] = ceil32(_36717) + u + 32
                                    mem[ceil32(_36717) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36717) + u + 36] = 0
                                    mem[ceil32(_36717) + u + 68] = _30394
                                    mem[ceil32(_36717) + u + 100] = this.address
                                    mem[ceil32(_36717) + u + 132] = 128
                                    _40479 = mem[_40380]
                                    mem[ceil32(_36717) + u + 164] = mem[_40380]
                                    s = 0
                                    while s < _40479:
                                        mem[s + ceil32(_36717) + u + 196] = mem[_40380 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40479) > _40479:
                                        mem[ceil32(_36717) + u + _40479 + 196] = 0
                                    require ext_code.size(address(_31580))
                                    call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30394, address(this.address), 128, mem[ceil32(_36717) + u + 164 len ceil32(_40479) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36717) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36717) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36717 + 32] = 0
                                    _40443 = mem[64]
                                    mem[mem[64]] = ceil32(_36717) + u - mem[64]
                                    mem[64] = ceil32(_36717) + u + 32
                                    mem[ceil32(_36717) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36717) + u + 36] = 0
                                    mem[ceil32(_36717) + u + 68] = _30394
                                    mem[ceil32(_36717) + u + 100] = this.address
                                    mem[ceil32(_36717) + u + 132] = 128
                                    _40511 = mem[_40443]
                                    mem[ceil32(_36717) + u + 164] = mem[_40443]
                                    s = 0
                                    while s < _40511:
                                        mem[s + ceil32(_36717) + u + 196] = mem[_40443 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40511) > _40511:
                                        mem[ceil32(_36717) + u + _40511 + 196] = 0
                                    require ext_code.size(address(_31580))
                                    call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30394, address(this.address), 128, mem[ceil32(_36717) + u + 164 len ceil32(_40511) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36717) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36717) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36717) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36717) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36717) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36717) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36717) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33282 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33378 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33378) + 256
                                v = mem[64] + 256
                                while s < _33378:
                                    mem[v] = u + -_33282 - 256
                                    _36496 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36498 = mem[_36496 + 32]
                                    mem[u + 32] = 96
                                    _36631 = mem[_36498]
                                    mem[u + 96] = mem[_36498]
                                    idx = 0
                                    w = _36498 + 32
                                    x = u + 128
                                    while idx < _36631:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40302 = mem[_36496 + 64]
                                    mem[u + 64] = (32 * _36631) + 128
                                    _40303 = mem[_40302]
                                    mem[u + (32 * _36631) + 128] = mem[_40302]
                                    w = u + (32 * _36631) + 160
                                    idx = 0
                                    x = _40302 + 32
                                    while idx < _40303:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36631) + (32 * _40303) + 160
                                    v = v + 32
                                    continue 
                                mem[_33282 + 128] = mem[_29698 + 32]
                                mem[_33282 + 160] = bool(mem[_29698 + 64])
                                mem[_33282 + 192] = bool(mem[_29698 + 96])
                                mem[_33282 + 64] = u + -_33282 - 32
                                _36716 = mem[_30030]
                                mem[u] = mem[_30030]
                                s = 0
                                while s < _36716:
                                    mem[s + u + 32] = mem[_30030 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36716) <= _36716:
                                    _40378 = mem[64]
                                    mem[mem[64]] = ceil32(_36716) + u - mem[64]
                                    mem[64] = ceil32(_36716) + u + 32
                                    mem[ceil32(_36716) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36716) + u + 36] = _30394
                                    mem[ceil32(_36716) + u + 68] = 0
                                    mem[ceil32(_36716) + u + 100] = this.address
                                    mem[ceil32(_36716) + u + 132] = 128
                                    _40478 = mem[_40378]
                                    mem[ceil32(_36716) + u + 164] = mem[_40378]
                                    s = 0
                                    while s < _40478:
                                        mem[s + ceil32(_36716) + u + 196] = mem[_40378 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40478) <= _40478:
                                        require ext_code.size(address(_31580))
                                        call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30394, 0, address(this.address), 128, mem[ceil32(_36716) + u + 164 len ceil32(_40478) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36716) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36716) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36716) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46990 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46990] = return_data.size
                                            mem[_46990 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36716) + u + _40478 + 196] = 0
                                        require ext_code.size(address(_31580))
                                        call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30394, 0, address(this.address), 128, mem[ceil32(_36716) + u + 164 len ceil32(_40478) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36716) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36716) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36716) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46991 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46991] = return_data.size
                                            mem[_46991 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36716 + 32] = 0
                                    _40442 = mem[64]
                                    mem[mem[64]] = ceil32(_36716) + u - mem[64]
                                    mem[64] = ceil32(_36716) + u + 32
                                    mem[ceil32(_36716) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36716) + u + 36] = _30394
                                    mem[ceil32(_36716) + u + 68] = 0
                                    mem[ceil32(_36716) + u + 100] = this.address
                                    mem[ceil32(_36716) + u + 132] = 128
                                    _40510 = mem[_40442]
                                    mem[ceil32(_36716) + u + 164] = mem[_40442]
                                    s = 0
                                    while s < _40510:
                                        mem[s + ceil32(_36716) + u + 196] = mem[_40442 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40510) <= _40510:
                                        require ext_code.size(address(_31580))
                                        call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30394, 0, address(this.address), 128, mem[ceil32(_36716) + u + 164 len ceil32(_40510) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36716) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36716) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36716) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46992 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46992] = return_data.size
                                            mem[_46992 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36716) + u + _40510 + 196] = 0
                                        require ext_code.size(address(_31580))
                                        call address(_31580).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30394, 0, address(this.address), 128, mem[ceil32(_36716) + u + 164 len ceil32(_40510) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36716) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36716) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36716) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36716) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36716) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _46993 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_46993] = return_data.size
                                            mem[_46993 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22157 + ceil32(return_data.size) + 128 len 32 * _22362] = call.data[calldata.size len 32 * _22362]
                            require mem[_22157 + ceil32(return_data.size) + 96] - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22157 + ceil32(return_data.size) + 96] - 1) + _22157 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22157] - 1
                            while s:
                                require s - 1 < mem[_22157]
                                _29542 = mem[(32 * s - 1) + _22157 + 32]
                                require s < mem[_22157]
                                _29597 = mem[(32 * s) + _22157 + 32]
                                if mem[(32 * s - 1) + _22157 + 44 len 20] == mem[(32 * s) + _22157 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22157 + 44 len 20] < mem[(32 * s) + _22157 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29597)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29542) == address(_29542):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29597)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29597) == address(_29542):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22157 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22157 + ceil32(return_data.size) + 96]
                            if mem[_22157 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22213:
                            _29699 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29699] = _7368
                            mem[_29699 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29699 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29699 + 96] = 1
                            _30031 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30031] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30307 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30401 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30540 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30711 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30887 = mem[_30711]
                            require mem[_30711] == mem[_30711 + 12 len 20]
                            mem[mem[64] + 4] = address(_30307)
                            mem[mem[64] + 36] = address(_30540)
                            require ext_code.size(address(_30887))
                            staticcall address(_30887).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30307), address(_30540)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31373 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31597 = mem[_31373]
                            require mem[_31373] == mem[_31373 + 12 len 20]
                            require ext_code.size(mem[_31373 + 12 len 20])
                            staticcall mem[_31373 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32547 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32547] == mem[_32547 + 12 len 20]
                            if address(_30307) == mem[_32547 + 12 len 20]:
                                _33284 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33380 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33380) + 256
                                v = mem[64] + 256
                                while s < _33380:
                                    mem[v] = u + -_33284 - 256
                                    _36502 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36504 = mem[_36502 + 32]
                                    mem[u + 32] = 96
                                    _36639 = mem[_36504]
                                    mem[u + 96] = mem[_36504]
                                    idx = 0
                                    w = _36504 + 32
                                    x = u + 128
                                    while idx < _36639:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40306 = mem[_36502 + 64]
                                    mem[u + 64] = (32 * _36639) + 128
                                    _40307 = mem[_40306]
                                    mem[u + (32 * _36639) + 128] = mem[_40306]
                                    w = u + (32 * _36639) + 160
                                    idx = 0
                                    x = _40306 + 32
                                    while idx < _40307:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36639) + (32 * _40307) + 160
                                    v = v + 32
                                    continue 
                                mem[_33284 + 128] = mem[_29699 + 32]
                                mem[_33284 + 160] = bool(mem[_29699 + 64])
                                mem[_33284 + 192] = bool(mem[_29699 + 96])
                                mem[_33284 + 64] = u + -_33284 - 32
                                _36718 = mem[_30031]
                                mem[u] = mem[_30031]
                                s = 0
                                while s < _36718:
                                    mem[s + u + 32] = mem[_30031 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36718) <= _36718:
                                    _40382 = mem[64]
                                    mem[mem[64]] = ceil32(_36718) + u - mem[64]
                                    mem[64] = ceil32(_36718) + u + 32
                                    mem[ceil32(_36718) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36718) + u + 36] = _30401
                                    mem[ceil32(_36718) + u + 68] = 0
                                    mem[ceil32(_36718) + u + 100] = this.address
                                    mem[ceil32(_36718) + u + 132] = 128
                                    _40480 = mem[_40382]
                                    mem[ceil32(_36718) + u + 164] = mem[_40382]
                                    s = 0
                                    while s < _40480:
                                        mem[s + ceil32(_36718) + u + 196] = mem[_40382 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40480) > _40480:
                                        mem[ceil32(_36718) + u + _40480 + 196] = 0
                                    require ext_code.size(address(_31597))
                                    call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30401, 0, address(this.address), 128, mem[ceil32(_36718) + u + 164 len ceil32(_40480) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36718) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36718) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36718 + 32] = 0
                                    _40444 = mem[64]
                                    mem[mem[64]] = ceil32(_36718) + u - mem[64]
                                    mem[64] = ceil32(_36718) + u + 32
                                    mem[ceil32(_36718) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36718) + u + 36] = _30401
                                    mem[ceil32(_36718) + u + 68] = 0
                                    mem[ceil32(_36718) + u + 100] = this.address
                                    mem[ceil32(_36718) + u + 132] = 128
                                    _40512 = mem[_40444]
                                    mem[ceil32(_36718) + u + 164] = mem[_40444]
                                    s = 0
                                    while s < _40512:
                                        mem[s + ceil32(_36718) + u + 196] = mem[_40444 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40512) > _40512:
                                        mem[ceil32(_36718) + u + _40512 + 196] = 0
                                    require ext_code.size(address(_31597))
                                    call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30401, 0, address(this.address), 128, mem[ceil32(_36718) + u + 164 len ceil32(_40512) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36718) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36718) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36718) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36718) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36718) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36718) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36718) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33285 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33381 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33381) + 256
                                v = mem[64] + 256
                                while s < _33381:
                                    mem[v] = u + -_33285 - 256
                                    _36505 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36507 = mem[_36505 + 32]
                                    mem[u + 32] = 96
                                    _36643 = mem[_36507]
                                    mem[u + 96] = mem[_36507]
                                    idx = 0
                                    w = _36507 + 32
                                    x = u + 128
                                    while idx < _36643:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40308 = mem[_36505 + 64]
                                    mem[u + 64] = (32 * _36643) + 128
                                    _40309 = mem[_40308]
                                    mem[u + (32 * _36643) + 128] = mem[_40308]
                                    w = u + (32 * _36643) + 160
                                    idx = 0
                                    x = _40308 + 32
                                    while idx < _40309:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36643) + (32 * _40309) + 160
                                    v = v + 32
                                    continue 
                                mem[_33285 + 128] = mem[_29699 + 32]
                                mem[_33285 + 160] = bool(mem[_29699 + 64])
                                mem[_33285 + 192] = bool(mem[_29699 + 96])
                                mem[_33285 + 64] = u + -_33285 - 32
                                _36719 = mem[_30031]
                                mem[u] = mem[_30031]
                                s = 0
                                while s < _36719:
                                    mem[s + u + 32] = mem[_30031 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36719) <= _36719:
                                    _40384 = mem[64]
                                    mem[mem[64]] = ceil32(_36719) + u - mem[64]
                                    mem[64] = ceil32(_36719) + u + 32
                                    mem[ceil32(_36719) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36719) + u + 36] = 0
                                    mem[ceil32(_36719) + u + 68] = _30401
                                    mem[ceil32(_36719) + u + 100] = this.address
                                    mem[ceil32(_36719) + u + 132] = 128
                                    _40481 = mem[_40384]
                                    mem[ceil32(_36719) + u + 164] = mem[_40384]
                                    s = 0
                                    while s < _40481:
                                        mem[s + ceil32(_36719) + u + 196] = mem[_40384 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40481) <= _40481:
                                        require ext_code.size(address(_31597))
                                        call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30401, address(this.address), 128, mem[ceil32(_36719) + u + 164 len ceil32(_40481) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36719) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36719) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36719) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47002 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47002] = return_data.size
                                            mem[_47002 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36719) + u + _40481 + 196] = 0
                                        require ext_code.size(address(_31597))
                                        call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30401, address(this.address), 128, mem[ceil32(_36719) + u + 164 len ceil32(_40481) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36719) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36719) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36719) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47003 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47003] = return_data.size
                                            mem[_47003 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                else:
                                    mem[u + _36719 + 32] = 0
                                    _40445 = mem[64]
                                    mem[mem[64]] = ceil32(_36719) + u - mem[64]
                                    mem[64] = ceil32(_36719) + u + 32
                                    mem[ceil32(_36719) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36719) + u + 36] = 0
                                    mem[ceil32(_36719) + u + 68] = _30401
                                    mem[ceil32(_36719) + u + 100] = this.address
                                    mem[ceil32(_36719) + u + 132] = 128
                                    _40513 = mem[_40445]
                                    mem[ceil32(_36719) + u + 164] = mem[_40445]
                                    s = 0
                                    while s < _40513:
                                        mem[s + ceil32(_36719) + u + 196] = mem[_40445 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40513) <= _40513:
                                        require ext_code.size(address(_31597))
                                        call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30401, address(this.address), 128, mem[ceil32(_36719) + u + 164 len ceil32(_40513) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36719) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36719) + u + ceil32(return_data.size) + -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36719) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36719) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36719) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36719) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36719) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36719) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                    else:
                                        mem[ceil32(_36719) + u + _40513 + 196] = 0
                                        require ext_code.size(address(_31597))
                                        call address(_31597).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30401, address(this.address), 128, mem[ceil32(_36719) + u + 164 len ceil32(_40513) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36719) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36719) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36719) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36719) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36719) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47005 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47005] = return_data.size
                                            mem[_47005 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                    else:
                        require 0 < mem[_7368]
                        require 0 < mem[mem[mem[_7368 + 32] + 64]]
                        _22215 = mem[mem[mem[_7368 + 32] + 64] + 32]
                        mem[_22157 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22157 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22157 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22157]
                        mem[_22157 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        require 1 < mem[_22157]
                        mem[_22157 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        if mem[_22157] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22157 + ceil32(return_data.size) + 198 len 30]
                        _22365 = mem[_22157]
                        require mem[_22157] <= test266151307()
                        mem[_22157 + ceil32(return_data.size) + 96] = mem[_22157]
                        mem[64] = _22157 + ceil32(return_data.size) + (32 * mem[_22157]) + 128
                        if not _22365:
                            require 0 < mem[_22157 + ceil32(return_data.size) + 96]
                            mem[_22157 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29442 = mem[_22157]
                            s = 0
                            while s < _29442 - 1:
                                require s < mem[_22157]
                                _29545 = mem[(32 * s) + _22157 + 32]
                                require s + 1 < mem[_22157]
                                _29599 = mem[(32 * s + 1) + _22157 + 32]
                                if mem[(32 * s) + _22157 + 44 len 20] == mem[(32 * s + 1) + _22157 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22157 + 44 len 20] < mem[(32 * s + 1) + _22157 + 44 len 20]:
                                    if not mem[(32 * s) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29599)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29545) == address(_29545):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29599)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29599) == address(_29545):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22157 + ceil32(return_data.size) + 96]
                            if _22215 + cd[((160 * idx) + cd[4] + 68)] > mem[_22157 + ceil32(return_data.size) + 160]:
                            _29700 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29700] = _7368
                            mem[_29700 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29700 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29700 + 96] = 1
                            _30032 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30032] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30310 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30408 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30548 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30896 = mem[_30720]
                            require mem[_30720] == mem[_30720 + 12 len 20]
                            mem[mem[64] + 4] = address(_30310)
                            mem[mem[64] + 36] = address(_30548)
                            require ext_code.size(address(_30896))
                            staticcall address(_30896).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30310), address(_30548)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31374 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31614 = mem[_31374]
                            require mem[_31374] == mem[_31374 + 12 len 20]
                            require ext_code.size(mem[_31374 + 12 len 20])
                            staticcall mem[_31374 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32556 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32556] == mem[_32556 + 12 len 20]
                            if address(_30310) != mem[_32556 + 12 len 20]:
                                _33287 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33383 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33383) + 256
                                v = mem[64] + 256
                                while s < _33383:
                                    mem[v] = u + -_33287 - 256
                                    _36511 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36513 = mem[_36511 + 32]
                                    mem[u + 32] = 96
                                    _36651 = mem[_36513]
                                    mem[u + 96] = mem[_36513]
                                    idx = 0
                                    w = _36513 + 32
                                    x = u + 128
                                    while idx < _36651:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40312 = mem[_36511 + 64]
                                    mem[u + 64] = (32 * _36651) + 128
                                    _40313 = mem[_40312]
                                    mem[u + (32 * _36651) + 128] = mem[_40312]
                                    w = u + (32 * _36651) + 160
                                    idx = 0
                                    x = _40312 + 32
                                    while idx < _40313:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36651) + (32 * _40313) + 160
                                    v = v + 32
                                    continue 
                                mem[_33287 + 128] = mem[_29700 + 32]
                                mem[_33287 + 160] = bool(mem[_29700 + 64])
                                mem[_33287 + 192] = bool(mem[_29700 + 96])
                                mem[_33287 + 64] = u + -_33287 - 32
                                _36721 = mem[_30032]
                                mem[u] = mem[_30032]
                                s = 0
                                while s < _36721:
                                    mem[s + u + 32] = mem[_30032 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36721) <= _36721:
                                    _40388 = mem[64]
                                    mem[mem[64]] = ceil32(_36721) + u - mem[64]
                                    mem[64] = ceil32(_36721) + u + 32
                                    mem[ceil32(_36721) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36721) + u + 36] = 0
                                    mem[ceil32(_36721) + u + 68] = _30408
                                    mem[ceil32(_36721) + u + 100] = this.address
                                    mem[ceil32(_36721) + u + 132] = 128
                                    _40483 = mem[_40388]
                                    mem[ceil32(_36721) + u + 164] = mem[_40388]
                                    s = 0
                                    while s < _40483:
                                        mem[s + ceil32(_36721) + u + 196] = mem[_40388 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40483) <= _40483:
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30408, address(this.address), 128, mem[ceil32(_36721) + u + 164 len ceil32(_40483) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36721) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36721) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36721) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47010 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47010] = return_data.size
                                            mem[_47010 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36721) + u + _40483 + 196] = 0
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30408, address(this.address), 128, mem[ceil32(_36721) + u + 164 len ceil32(_40483) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36721) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36721) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36721) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47011 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47011] = return_data.size
                                            mem[_47011 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                else:
                                    mem[u + _36721 + 32] = 0
                                    _40447 = mem[64]
                                    mem[mem[64]] = ceil32(_36721) + u - mem[64]
                                    mem[64] = ceil32(_36721) + u + 32
                                    mem[ceil32(_36721) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36721) + u + 36] = 0
                                    mem[ceil32(_36721) + u + 68] = _30408
                                    mem[ceil32(_36721) + u + 100] = this.address
                                    mem[ceil32(_36721) + u + 132] = 128
                                    _40515 = mem[_40447]
                                    mem[ceil32(_36721) + u + 164] = mem[_40447]
                                    s = 0
                                    while s < _40515:
                                        mem[s + ceil32(_36721) + u + 196] = mem[_40447 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40515) <= _40515:
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30408, address(this.address), 128, mem[ceil32(_36721) + u + 164 len ceil32(_40515) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36721) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36721) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36721) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47012 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47012] = return_data.size
                                            mem[_47012 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                    else:
                                        mem[ceil32(_36721) + u + _40515 + 196] = 0
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30408, address(this.address), 128, mem[ceil32(_36721) + u + 164 len ceil32(_40515) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36721) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36721) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36721) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36721) + u + ceil32(return_data.size) + -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36721) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36721) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36721) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36721) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36721) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36721) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36721) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33286 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33382 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33382) + 256
                                v = mem[64] + 256
                                while s < _33382:
                                    mem[v] = u + -_33286 - 256
                                    _36508 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36510 = mem[_36508 + 32]
                                    mem[u + 32] = 96
                                    _36647 = mem[_36510]
                                    mem[u + 96] = mem[_36510]
                                    idx = 0
                                    w = _36510 + 32
                                    x = u + 128
                                    while idx < _36647:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40310 = mem[_36508 + 64]
                                    mem[u + 64] = (32 * _36647) + 128
                                    _40311 = mem[_40310]
                                    mem[u + (32 * _36647) + 128] = mem[_40310]
                                    w = u + (32 * _36647) + 160
                                    idx = 0
                                    x = _40310 + 32
                                    while idx < _40311:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36647) + (32 * _40311) + 160
                                    v = v + 32
                                    continue 
                                mem[_33286 + 128] = mem[_29700 + 32]
                                mem[_33286 + 160] = bool(mem[_29700 + 64])
                                mem[_33286 + 192] = bool(mem[_29700 + 96])
                                mem[_33286 + 64] = u + -_33286 - 32
                                _36720 = mem[_30032]
                                mem[u] = mem[_30032]
                                s = 0
                                while s < _36720:
                                    mem[s + u + 32] = mem[_30032 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36720) <= _36720:
                                    _40386 = mem[64]
                                    mem[mem[64]] = ceil32(_36720) + u - mem[64]
                                    mem[64] = ceil32(_36720) + u + 32
                                    mem[ceil32(_36720) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36720) + u + 36] = _30408
                                    mem[ceil32(_36720) + u + 68] = 0
                                    mem[ceil32(_36720) + u + 100] = this.address
                                    mem[ceil32(_36720) + u + 132] = 128
                                    _40482 = mem[_40386]
                                    mem[ceil32(_36720) + u + 164] = mem[_40386]
                                    s = 0
                                    while s < _40482:
                                        mem[s + ceil32(_36720) + u + 196] = mem[_40386 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40482) <= _40482:
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30408, 0, address(this.address), 128, mem[ceil32(_36720) + u + 164 len ceil32(_40482) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36720) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36720) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36720) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47006 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47006] = return_data.size
                                            mem[_47006 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36720) + u + _40482 + 196] = 0
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30408, 0, address(this.address), 128, mem[ceil32(_36720) + u + 164 len ceil32(_40482) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36720) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36720) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36720) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47007 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47007] = return_data.size
                                            mem[_47007 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36720 + 32] = 0
                                    _40446 = mem[64]
                                    mem[mem[64]] = ceil32(_36720) + u - mem[64]
                                    mem[64] = ceil32(_36720) + u + 32
                                    mem[ceil32(_36720) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36720) + u + 36] = _30408
                                    mem[ceil32(_36720) + u + 68] = 0
                                    mem[ceil32(_36720) + u + 100] = this.address
                                    mem[ceil32(_36720) + u + 132] = 128
                                    _40514 = mem[_40446]
                                    mem[ceil32(_36720) + u + 164] = mem[_40446]
                                    s = 0
                                    while s < _40514:
                                        mem[s + ceil32(_36720) + u + 196] = mem[_40446 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40514) <= _40514:
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30408, 0, address(this.address), 128, mem[ceil32(_36720) + u + 164 len ceil32(_40514) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36720) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36720) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36720) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47008 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47008] = return_data.size
                                            mem[_47008 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36720) + u + _40514 + 196] = 0
                                        require ext_code.size(address(_31614))
                                        call address(_31614).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30408, 0, address(this.address), 128, mem[ceil32(_36720) + u + 164 len ceil32(_40514) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36720) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36720) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36720) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36720) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36720) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47009 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47009] = return_data.size
                                            mem[_47009 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22157 + ceil32(return_data.size) + 128 len 32 * _22365] = call.data[calldata.size len 32 * _22365]
                            require 0 < mem[_22157 + ceil32(return_data.size) + 96]
                            mem[_22157 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29443 = mem[_22157]
                            s = 0
                            while s < _29443 - 1:
                                require s < mem[_22157]
                                _29548 = mem[(32 * s) + _22157 + 32]
                                require s + 1 < mem[_22157]
                                _29601 = mem[(32 * s + 1) + _22157 + 32]
                                if mem[(32 * s) + _22157 + 44 len 20] == mem[(32 * s + 1) + _22157 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22157 + 44 len 20] < mem[(32 * s + 1) + _22157 + 44 len 20]:
                                    if not mem[(32 * s) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29601)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29548) == address(_29548):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22157 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22157 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29601)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22157 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29601) == address(_29548):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22157 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22157 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22157 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22157 + ceil32(return_data.size) + 96]
                            if _22215 + cd[((160 * idx) + cd[4] + 68)] > mem[_22157 + ceil32(return_data.size) + 160]:
                            _29701 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29701] = _7368
                            mem[_29701 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29701 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29701 + 96] = 1
                            _30033 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30033] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30313 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30415 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30556 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30729 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30905 = mem[_30729]
                            require mem[_30729] == mem[_30729 + 12 len 20]
                            mem[mem[64] + 4] = address(_30313)
                            mem[mem[64] + 36] = address(_30556)
                            require ext_code.size(address(_30905))
                            staticcall address(_30905).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30313), address(_30556)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31375 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31623 = mem[_31375]
                            require mem[_31375] == mem[_31375 + 12 len 20]
                            require ext_code.size(mem[_31375 + 12 len 20])
                            staticcall mem[_31375 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32557 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32557] == mem[_32557 + 12 len 20]
                            if address(_30313) == mem[_32557 + 12 len 20]:
                                _33288 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33384 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33384) + 256
                                v = mem[64] + 256
                                while s < _33384:
                                    mem[v] = u + -_33288 - 256
                                    _36514 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36516 = mem[_36514 + 32]
                                    mem[u + 32] = 96
                                    _36655 = mem[_36516]
                                    mem[u + 96] = mem[_36516]
                                    idx = 0
                                    w = _36516 + 32
                                    x = u + 128
                                    while idx < _36655:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40314 = mem[_36514 + 64]
                                    mem[u + 64] = (32 * _36655) + 128
                                    _40315 = mem[_40314]
                                    mem[u + (32 * _36655) + 128] = mem[_40314]
                                    w = u + (32 * _36655) + 160
                                    idx = 0
                                    x = _40314 + 32
                                    while idx < _40315:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36655) + (32 * _40315) + 160
                                    v = v + 32
                                    continue 
                                mem[_33288 + 128] = mem[_29701 + 32]
                                mem[_33288 + 160] = bool(mem[_29701 + 64])
                                mem[_33288 + 192] = bool(mem[_29701 + 96])
                                mem[_33288 + 64] = u + -_33288 - 32
                                _36722 = mem[_30033]
                                mem[u] = mem[_30033]
                                s = 0
                                while s < _36722:
                                    mem[s + u + 32] = mem[_30033 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36722) <= _36722:
                                    _40390 = mem[64]
                                    mem[mem[64]] = ceil32(_36722) + u - mem[64]
                                    mem[64] = ceil32(_36722) + u + 32
                                    mem[ceil32(_36722) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36722) + u + 36] = _30415
                                    mem[ceil32(_36722) + u + 68] = 0
                                    mem[ceil32(_36722) + u + 100] = this.address
                                    mem[ceil32(_36722) + u + 132] = 128
                                    _40484 = mem[_40390]
                                    mem[ceil32(_36722) + u + 164] = mem[_40390]
                                    s = 0
                                    while s < _40484:
                                        mem[s + ceil32(_36722) + u + 196] = mem[_40390 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40484) <= _40484:
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30415, 0, address(this.address), 128, mem[ceil32(_36722) + u + 164 len ceil32(_40484) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36722) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36722) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36722) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47014 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47014] = return_data.size
                                            mem[_47014 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36722) + u + _40484 + 196] = 0
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30415, 0, address(this.address), 128, mem[ceil32(_36722) + u + 164 len ceil32(_40484) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36722) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36722) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36722) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47015 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47015] = return_data.size
                                            mem[_47015 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                else:
                                    mem[u + _36722 + 32] = 0
                                    _40448 = mem[64]
                                    mem[mem[64]] = ceil32(_36722) + u - mem[64]
                                    mem[64] = ceil32(_36722) + u + 32
                                    mem[ceil32(_36722) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36722) + u + 36] = _30415
                                    mem[ceil32(_36722) + u + 68] = 0
                                    mem[ceil32(_36722) + u + 100] = this.address
                                    mem[ceil32(_36722) + u + 132] = 128
                                    _40516 = mem[_40448]
                                    mem[ceil32(_36722) + u + 164] = mem[_40448]
                                    s = 0
                                    while s < _40516:
                                        mem[s + ceil32(_36722) + u + 196] = mem[_40448 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40516) <= _40516:
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30415, 0, address(this.address), 128, mem[ceil32(_36722) + u + 164 len ceil32(_40516) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36722) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36722) + u + ceil32(return_data.size) + -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36722) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36722) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36722) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36722) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36722) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36722) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                    else:
                                        mem[ceil32(_36722) + u + _40516 + 196] = 0
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30415, 0, address(this.address), 128, mem[ceil32(_36722) + u + 164 len ceil32(_40516) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36722) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36722) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36722) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36722) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36722) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47017 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47017] = return_data.size
                                            mem[_47017 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                _33289 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33385 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33385) + 256
                                v = mem[64] + 256
                                while s < _33385:
                                    mem[v] = u + -_33289 - 256
                                    _36517 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36519 = mem[_36517 + 32]
                                    mem[u + 32] = 96
                                    _36659 = mem[_36519]
                                    mem[u + 96] = mem[_36519]
                                    idx = 0
                                    w = _36519 + 32
                                    x = u + 128
                                    while idx < _36659:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40316 = mem[_36517 + 64]
                                    mem[u + 64] = (32 * _36659) + 128
                                    _40317 = mem[_40316]
                                    mem[u + (32 * _36659) + 128] = mem[_40316]
                                    w = u + (32 * _36659) + 160
                                    idx = 0
                                    x = _40316 + 32
                                    while idx < _40317:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36659) + (32 * _40317) + 160
                                    v = v + 32
                                    continue 
                                mem[_33289 + 128] = mem[_29701 + 32]
                                mem[_33289 + 160] = bool(mem[_29701 + 64])
                                mem[_33289 + 192] = bool(mem[_29701 + 96])
                                mem[_33289 + 64] = u + -_33289 - 32
                                _36723 = mem[_30033]
                                mem[u] = mem[_30033]
                                s = 0
                                while s < _36723:
                                    mem[s + u + 32] = mem[_30033 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36723) <= _36723:
                                    _40392 = mem[64]
                                    mem[mem[64]] = ceil32(_36723) + u - mem[64]
                                    mem[64] = ceil32(_36723) + u + 32
                                    mem[ceil32(_36723) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36723) + u + 36] = 0
                                    mem[ceil32(_36723) + u + 68] = _30415
                                    mem[ceil32(_36723) + u + 100] = this.address
                                    mem[ceil32(_36723) + u + 132] = 128
                                    _40485 = mem[_40392]
                                    mem[ceil32(_36723) + u + 164] = mem[_40392]
                                    s = 0
                                    while s < _40485:
                                        mem[s + ceil32(_36723) + u + 196] = mem[_40392 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40485) <= _40485:
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30415, address(this.address), 128, mem[ceil32(_36723) + u + 164 len ceil32(_40485) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36723) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36723) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36723) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47018 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47018] = return_data.size
                                            mem[_47018 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36723) + u + _40485 + 196] = 0
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30415, address(this.address), 128, mem[ceil32(_36723) + u + 164 len ceil32(_40485) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36723) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36723) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36723) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47019 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47019] = return_data.size
                                            mem[_47019 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36723 + 32] = 0
                                    _40449 = mem[64]
                                    mem[mem[64]] = ceil32(_36723) + u - mem[64]
                                    mem[64] = ceil32(_36723) + u + 32
                                    mem[ceil32(_36723) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36723) + u + 36] = 0
                                    mem[ceil32(_36723) + u + 68] = _30415
                                    mem[ceil32(_36723) + u + 100] = this.address
                                    mem[ceil32(_36723) + u + 132] = 128
                                    _40517 = mem[_40449]
                                    mem[ceil32(_36723) + u + 164] = mem[_40449]
                                    s = 0
                                    while s < _40517:
                                        mem[s + ceil32(_36723) + u + 196] = mem[_40449 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40517) <= _40517:
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30415, address(this.address), 128, mem[ceil32(_36723) + u + 164 len ceil32(_40517) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36723) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36723) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36723) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47020 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47020] = return_data.size
                                            mem[_47020 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36723) + u + _40517 + 196] = 0
                                        require ext_code.size(address(_31623))
                                        call address(_31623).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30415, address(this.address), 128, mem[ceil32(_36723) + u + 164 len ceil32(_40517) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36723) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36723) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36723) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36723) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36723) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47021 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47021] = return_data.size
                                            mem[_47021 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
            else:
                _22101 = mem[_7368]
                s = 0
                t = cd[((160 * idx) + cd[4] + 36)]
                while s < _22101:
                    require s < mem[_7368]
                    _22118 = mem[(32 * s) + _7368 + 32]
                    _22119 = mem[mem[(32 * s) + _7368 + 32]]
                    _22120 = mem[mem[(32 * s) + _7368 + 32] + 32]
                    _22121 = mem[64]
                    mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = t
                    mem[mem[64] + 36] = 64
                    _22125 = mem[_22120]
                    mem[mem[64] + 68] = mem[_22120]
                    idx = 0
                    t = _22120 + 32
                    u = mem[64] + 100
                    while idx < _22125:
                        mem[u] = mem[t + 12 len 20]
                        idx = idx + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    require ext_code.size(address(_22119))
                    staticcall address(_22119).mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _22121 + (32 * _22125) + -mem[64] + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _29649 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _29709 = mem[_29649]
                    require mem[_29649] <= test266151307()
                    require _29649 + return_data.size > _29649 + mem[_29649] + 31
                    _29793 = mem[_29649 + mem[_29649]]
                    if mem[_29649 + mem[_29649]] <= test266151307():
                        if (32 * mem[_29649 + mem[_29649]]) + 32 >= 0 and _29649 + ceil32(return_data.size) + (32 * mem[_29649 + mem[_29649]]) + 32 <= test266151307():
                            mem[64] = _29649 + ceil32(return_data.size) + (32 * mem[_29649 + mem[_29649]]) + 32
                            mem[_29649 + ceil32(return_data.size)] = _29793
                            require return_data.size >= _29709 + (32 * _29793) + 32
                            t = _29649 + _29709 + 32
                            u = _29649 + ceil32(return_data.size) + 32
                            idx = 0
                            while idx < _29793:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                idx = idx + 1
                                continue 
                            mem[_22118 + 64] = _29649 + ceil32(return_data.size)
                            if _29793 - 1 < _29793:
                                t = _29649 + _29709 + (32 * _29793) + 33
                                t = mem[(32 * _29793 - 1) + _29649 + ceil32(return_data.size) + 32]
                                continue 
                    revert
                require cd[((160 * idx) + cd[4] + 132)] == bool(cd[((160 * idx) + cd[4] + 132)])
                if not cd[((160 * idx) + cd[4] + 132)]:
                    _22145 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_22145] = _7368
                    mem[_22145 + 32] = cd[((160 * idx) + cd[4] + 36)]
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22145 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                    mem[_22145 + 96] = 1
                    _22169 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_22169] = 0
                    require mem[_7368] - 1 < mem[_7368]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22280 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                    _22294 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                    require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                    _22310 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                    require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                    staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22325 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22339 = mem[_22325]
                    require mem[_22325] == mem[_22325 + 12 len 20]
                    mem[mem[64] + 4] = address(_22280)
                    mem[mem[64] + 36] = address(_22310)
                    require ext_code.size(address(_22339))
                    staticcall address(_22339).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args address(_22280), address(_22310)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22459 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _22505 = mem[_22459]
                    require mem[_22459] == mem[_22459 + 12 len 20]
                    require ext_code.size(mem[_22459 + 12 len 20])
                    staticcall mem[_22459 + 12 len 20].token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22675 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_22675] == mem[_22675 + 12 len 20]
                    if address(_22280) != mem[_22675 + 12 len 20]:
                        _23209 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23383 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23383) + 256
                        v = mem[64] + 256
                        while s < _23383:
                            mem[v] = u + -_23209 - 256
                            _29482 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29484 = mem[_29482 + 32]
                            mem[u + 32] = 96
                            _29557 = mem[_29484]
                            mem[u + 96] = mem[_29484]
                            idx = 0
                            w = _29484 + 32
                            x = u + 128
                            while idx < _29557:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36663 = mem[_29482 + 64]
                            mem[u + 64] = (32 * _29557) + 128
                            _36664 = mem[_36663]
                            mem[u + (32 * _29557) + 128] = mem[_36663]
                            w = u + (32 * _29557) + 160
                            idx = 0
                            x = _36663 + 32
                            while idx < _36664:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29557) + (32 * _36664) + 160
                            v = v + 32
                            continue 
                        mem[_23209 + 128] = mem[_22145 + 32]
                        mem[_23209 + 160] = bool(mem[_22145 + 64])
                        mem[_23209 + 192] = bool(mem[_22145 + 96])
                        mem[_23209 + 64] = u + -_23209 - 32
                        _29604 = mem[_22169]
                        mem[u] = mem[_22169]
                        s = 0
                        while s < _29604:
                            mem[s + u + 32] = mem[_22169 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29604) <= _29604:
                            _36772 = mem[64]
                            mem[mem[64]] = ceil32(_29604) + u - mem[64]
                            mem[64] = ceil32(_29604) + u + 32
                            mem[ceil32(_29604) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29604) + u + 36] = 0
                            mem[ceil32(_29604) + u + 68] = _22294
                            mem[ceil32(_29604) + u + 100] = this.address
                            mem[ceil32(_29604) + u + 132] = 128
                            _36893 = mem[_36772]
                            mem[ceil32(_29604) + u + 164] = mem[_36772]
                            s = 0
                            while s < _36893:
                                mem[s + ceil32(_29604) + u + 196] = mem[_36772 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36893) <= _36893:
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22294, address(this.address), 128, mem[ceil32(_29604) + u + 164 len ceil32(_36893) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29604) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29604) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29604) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43850 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43850] = return_data.size
                                    mem[_43850 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29604) + u + _36893 + 196] = 0
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22294, address(this.address), 128, mem[ceil32(_29604) + u + 164 len ceil32(_36893) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29604) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29604) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29604) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43851 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43851] = return_data.size
                                    mem[_43851 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[u + _29604 + 32] = 0
                            _36861 = mem[64]
                            mem[mem[64]] = ceil32(_29604) + u - mem[64]
                            mem[64] = ceil32(_29604) + u + 32
                            mem[ceil32(_29604) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29604) + u + 36] = 0
                            mem[ceil32(_29604) + u + 68] = _22294
                            mem[ceil32(_29604) + u + 100] = this.address
                            mem[ceil32(_29604) + u + 132] = 128
                            _36925 = mem[_36861]
                            mem[ceil32(_29604) + u + 164] = mem[_36861]
                            s = 0
                            while s < _36925:
                                mem[s + ceil32(_29604) + u + 196] = mem[_36861 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36925) <= _36925:
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22294, address(this.address), 128, mem[ceil32(_29604) + u + 164 len ceil32(_36925) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29604) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29604) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29604) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43852 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43852] = return_data.size
                                    mem[_43852 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                mem[ceil32(_29604) + u + _36925 + 196] = 0
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, _22294, address(this.address), 128, mem[ceil32(_29604) + u + 164 len ceil32(_36925) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29604) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                v = ceil32(_29604) + u + ceil32(return_data.size) + 64
                                s = mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[ceil32(_29604) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_29604) + u + ceil32(return_data.size) + -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_29604) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29604) + u + ceil32(return_data.size) + 32]) + 64])
                                call owner with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29604) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_29604) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_29604) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_29604) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29604) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                    else:
                        _23208 = mem[64]
                        mem[mem[64] + 32] = 64
                        mem[mem[64] + 96] = 128
                        _23382 = mem[_7368]
                        mem[mem[64] + 224] = mem[_7368]
                        s = 0
                        t = _7368 + 32
                        u = mem[64] + (32 * _23382) + 256
                        v = mem[64] + 256
                        while s < _23382:
                            mem[v] = u + -_23208 - 256
                            _29479 = mem[t]
                            mem[u] = mem[mem[t] + 12 len 20]
                            _29481 = mem[_29479 + 32]
                            mem[u + 32] = 96
                            _29553 = mem[_29481]
                            mem[u + 96] = mem[_29481]
                            idx = 0
                            w = _29481 + 32
                            x = u + 128
                            while idx < _29553:
                                mem[x] = mem[w + 12 len 20]
                                idx = idx + 1
                                w = w + 32
                                x = x + 32
                                continue 
                            _36661 = mem[_29479 + 64]
                            mem[u + 64] = (32 * _29553) + 128
                            _36662 = mem[_36661]
                            mem[u + (32 * _29553) + 128] = mem[_36661]
                            w = u + (32 * _29553) + 160
                            idx = 0
                            x = _36661 + 32
                            while idx < _36662:
                                mem[w] = mem[x]
                                w = w + 32
                                idx = idx + 1
                                x = x + 32
                                continue 
                            s = s + 1
                            t = t + 32
                            u = u + (32 * _29553) + (32 * _36662) + 160
                            v = v + 32
                            continue 
                        mem[_23208 + 128] = mem[_22145 + 32]
                        mem[_23208 + 160] = bool(mem[_22145 + 64])
                        mem[_23208 + 192] = bool(mem[_22145 + 96])
                        mem[_23208 + 64] = u + -_23208 - 32
                        _29603 = mem[_22169]
                        mem[u] = mem[_22169]
                        s = 0
                        while s < _29603:
                            mem[s + u + 32] = mem[_22169 + s + 32]
                            s = s + 32
                            continue 
                        if ceil32(_29603) <= _29603:
                            _36770 = mem[64]
                            mem[mem[64]] = ceil32(_29603) + u - mem[64]
                            mem[64] = ceil32(_29603) + u + 32
                            mem[ceil32(_29603) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29603) + u + 36] = _22294
                            mem[ceil32(_29603) + u + 68] = 0
                            mem[ceil32(_29603) + u + 100] = this.address
                            mem[ceil32(_29603) + u + 132] = 128
                            _36892 = mem[_36770]
                            mem[ceil32(_29603) + u + 164] = mem[_36770]
                            s = 0
                            while s < _36892:
                                mem[s + ceil32(_29603) + u + 196] = mem[_36770 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36892) <= _36892:
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22294, 0, address(this.address), 128, mem[ceil32(_29603) + u + 164 len ceil32(_36892) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29603) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29603) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29603) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43846 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43846] = return_data.size
                                    mem[_43846 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                mem[ceil32(_29603) + u + _36892 + 196] = 0
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22294, 0, address(this.address), 128, mem[ceil32(_29603) + u + 164 len ceil32(_36892) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29603) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                v = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                s = mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_29603) + u + ceil32(return_data.size) + -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_29603) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + 64])
                                call owner with:
                                   value ext_call.return_data[0] wei
                                     gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29603) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_29603) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_29603) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_29603) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_29603) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                        else:
                            mem[u + _29603 + 32] = 0
                            _36860 = mem[64]
                            mem[mem[64]] = ceil32(_29603) + u - mem[64]
                            mem[64] = ceil32(_29603) + u + 32
                            mem[ceil32(_29603) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(_29603) + u + 36] = _22294
                            mem[ceil32(_29603) + u + 68] = 0
                            mem[ceil32(_29603) + u + 100] = this.address
                            mem[ceil32(_29603) + u + 132] = 128
                            _36924 = mem[_36860]
                            mem[ceil32(_29603) + u + 164] = mem[_36860]
                            s = 0
                            while s < _36924:
                                mem[s + ceil32(_29603) + u + 196] = mem[_36860 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(_36924) <= _36924:
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22294, 0, address(this.address), 128, mem[ceil32(_29603) + u + 164 len ceil32(_36924) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29603) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29603) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29603) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43848 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43848] = return_data.size
                                    mem[_43848 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(_29603) + u + _36924 + 196] = 0
                                require ext_code.size(address(_22505))
                                call address(_22505).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args _22294, 0, address(this.address), 128, mem[ceil32(_29603) + u + 164 len ceil32(_36924) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + 36] = this.address
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                     gas gas_remaining wei
                                    args this.address
                                mem[ceil32(_29603) + u + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args 0, ext_call.return_data[4 len 28]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] = 0
                                mem[64] = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                t = ceil32(_29603) + u + ceil32(return_data.size) + 64
                                v = mem[64]
                                s = mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]
                                while s >= 32:
                                    mem[v] = mem[t]
                                    t = t + 32
                                    v = v + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_29603) + u + ceil32(return_data.size) + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_29603) + u + ceil32(return_data.size) + 32])])
                                call owner.mem[mem[64] len 4] with:
                                   value 0, ext_call.return_data[4 len 28] wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(_29603) + u + ceil32(return_data.size) + -mem[64] + 60]
                                if return_data.size:
                                    _43849 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                                    mem[_43849] = return_data.size
                                    mem[_43849 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                else:
                    require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                    _22197 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    mem[_22197 + 32 len 64] = call.data[calldata.size len 64]
                    if not cd[((160 * idx) + cd[4] + 100)]:
                        require mem[_7368] - 1 < mem[_7368]
                        require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                        _22283 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                        mem[_22197 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22197 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22197 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22197]
                        mem[_22197 + 32] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        require 1 < mem[_22197]
                        mem[_22197 + 64] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        if mem[_22197] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22197 + ceil32(return_data.size) + 198 len 30]
                        _22392 = mem[_22197]
                        require mem[_22197] <= test266151307()
                        mem[_22197 + ceil32(return_data.size) + 96] = mem[_22197]
                        mem[64] = _22197 + ceil32(return_data.size) + (32 * mem[_22197]) + 128
                        if not _22392:
                            require mem[_22197 + ceil32(return_data.size) + 96] - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22197 + ceil32(return_data.size) + 96] - 1) + _22197 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22197] - 1
                            while s:
                                require s - 1 < mem[_22197]
                                _29559 = mem[(32 * s - 1) + _22197 + 32]
                                require s < mem[_22197]
                                _29606 = mem[(32 * s) + _22197 + 32]
                                if mem[(32 * s - 1) + _22197 + 44 len 20] == mem[(32 * s) + _22197 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22197 + 44 len 20] < mem[(32 * s) + _22197 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29606)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29559) == address(_29559):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29606)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29606) == address(_29559):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22197 + ceil32(return_data.size) + 96]
                            if mem[_22197 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22283:
                            _29705 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29705] = _7368
                            mem[_29705 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29705 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29705 + 96] = 1
                            _30034 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30034] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30317 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30425 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30569 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30742 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30918 = mem[_30742]
                            require mem[_30742] == mem[_30742 + 12 len 20]
                            mem[mem[64] + 4] = address(_30317)
                            mem[mem[64] + 36] = address(_30569)
                            require ext_code.size(address(_30918))
                            staticcall address(_30918).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30317), address(_30569)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31382 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31646 = mem[_31382]
                            require mem[_31382] == mem[_31382 + 12 len 20]
                            require ext_code.size(mem[_31382 + 12 len 20])
                            staticcall mem[_31382 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32558 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32558] == mem[_32558 + 12 len 20]
                            if address(_30317) != mem[_32558 + 12 len 20]:
                                _33291 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33387 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33387) + 256
                                v = mem[64] + 256
                                while s < _33387:
                                    mem[v] = u + -_33291 - 256
                                    _36528 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36530 = mem[_36528 + 32]
                                    mem[u + 32] = 96
                                    _36672 = mem[_36530]
                                    mem[u + 96] = mem[_36530]
                                    idx = 0
                                    w = _36530 + 32
                                    x = u + 128
                                    while idx < _36672:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40320 = mem[_36528 + 64]
                                    mem[u + 64] = (32 * _36672) + 128
                                    _40321 = mem[_40320]
                                    mem[u + (32 * _36672) + 128] = mem[_40320]
                                    w = u + (32 * _36672) + 160
                                    idx = 0
                                    x = _40320 + 32
                                    while idx < _40321:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36672) + (32 * _40321) + 160
                                    v = v + 32
                                    continue 
                                mem[_33291 + 128] = mem[_29705 + 32]
                                mem[_33291 + 160] = bool(mem[_29705 + 64])
                                mem[_33291 + 192] = bool(mem[_29705 + 96])
                                mem[_33291 + 64] = u + -_33291 - 32
                                _36726 = mem[_30034]
                                mem[u] = mem[_30034]
                                s = 0
                                while s < _36726:
                                    mem[s + u + 32] = mem[_30034 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36726) <= _36726:
                                    _40400 = mem[64]
                                    mem[mem[64]] = ceil32(_36726) + u - mem[64]
                                    mem[64] = ceil32(_36726) + u + 32
                                    mem[ceil32(_36726) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36726) + u + 36] = 0
                                    mem[ceil32(_36726) + u + 68] = _30425
                                    mem[ceil32(_36726) + u + 100] = this.address
                                    mem[ceil32(_36726) + u + 132] = 128
                                    _40487 = mem[_40400]
                                    mem[ceil32(_36726) + u + 164] = mem[_40400]
                                    s = 0
                                    while s < _40487:
                                        mem[s + ceil32(_36726) + u + 196] = mem[_40400 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40487) > _40487:
                                        mem[ceil32(_36726) + u + _40487 + 196] = 0
                                    require ext_code.size(address(_31646))
                                    call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30425, address(this.address), 128, mem[ceil32(_36726) + u + 164 len ceil32(_40487) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36726) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36726) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36726 + 32] = 0
                                    _40455 = mem[64]
                                    mem[mem[64]] = ceil32(_36726) + u - mem[64]
                                    mem[64] = ceil32(_36726) + u + 32
                                    mem[ceil32(_36726) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36726) + u + 36] = 0
                                    mem[ceil32(_36726) + u + 68] = _30425
                                    mem[ceil32(_36726) + u + 100] = this.address
                                    mem[ceil32(_36726) + u + 132] = 128
                                    _40519 = mem[_40455]
                                    mem[ceil32(_36726) + u + 164] = mem[_40455]
                                    s = 0
                                    while s < _40519:
                                        mem[s + ceil32(_36726) + u + 196] = mem[_40455 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40519) > _40519:
                                        mem[ceil32(_36726) + u + _40519 + 196] = 0
                                    require ext_code.size(address(_31646))
                                    call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30425, address(this.address), 128, mem[ceil32(_36726) + u + 164 len ceil32(_40519) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36726) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36726) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36726) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36726) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36726) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36726) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36726) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33290 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33386 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33386) + 256
                                v = mem[64] + 256
                                while s < _33386:
                                    mem[v] = u + -_33290 - 256
                                    _36525 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36527 = mem[_36525 + 32]
                                    mem[u + 32] = 96
                                    _36668 = mem[_36527]
                                    mem[u + 96] = mem[_36527]
                                    idx = 0
                                    w = _36527 + 32
                                    x = u + 128
                                    while idx < _36668:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40318 = mem[_36525 + 64]
                                    mem[u + 64] = (32 * _36668) + 128
                                    _40319 = mem[_40318]
                                    mem[u + (32 * _36668) + 128] = mem[_40318]
                                    w = u + (32 * _36668) + 160
                                    idx = 0
                                    x = _40318 + 32
                                    while idx < _40319:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36668) + (32 * _40319) + 160
                                    v = v + 32
                                    continue 
                                mem[_33290 + 128] = mem[_29705 + 32]
                                mem[_33290 + 160] = bool(mem[_29705 + 64])
                                mem[_33290 + 192] = bool(mem[_29705 + 96])
                                mem[_33290 + 64] = u + -_33290 - 32
                                _36725 = mem[_30034]
                                mem[u] = mem[_30034]
                                s = 0
                                while s < _36725:
                                    mem[s + u + 32] = mem[_30034 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36725) <= _36725:
                                    _40398 = mem[64]
                                    mem[mem[64]] = ceil32(_36725) + u - mem[64]
                                    mem[64] = ceil32(_36725) + u + 32
                                    mem[ceil32(_36725) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36725) + u + 36] = _30425
                                    mem[ceil32(_36725) + u + 68] = 0
                                    mem[ceil32(_36725) + u + 100] = this.address
                                    mem[ceil32(_36725) + u + 132] = 128
                                    _40486 = mem[_40398]
                                    mem[ceil32(_36725) + u + 164] = mem[_40398]
                                    s = 0
                                    while s < _40486:
                                        mem[s + ceil32(_36725) + u + 196] = mem[_40398 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40486) <= _40486:
                                        require ext_code.size(address(_31646))
                                        call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30425, 0, address(this.address), 128, mem[ceil32(_36725) + u + 164 len ceil32(_40486) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36725) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36725) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36725) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47022 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47022] = return_data.size
                                            mem[_47022 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36725) + u + _40486 + 196] = 0
                                        require ext_code.size(address(_31646))
                                        call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30425, 0, address(this.address), 128, mem[ceil32(_36725) + u + 164 len ceil32(_40486) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36725) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36725) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36725) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47023 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47023] = return_data.size
                                            mem[_47023 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36725 + 32] = 0
                                    _40454 = mem[64]
                                    mem[mem[64]] = ceil32(_36725) + u - mem[64]
                                    mem[64] = ceil32(_36725) + u + 32
                                    mem[ceil32(_36725) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36725) + u + 36] = _30425
                                    mem[ceil32(_36725) + u + 68] = 0
                                    mem[ceil32(_36725) + u + 100] = this.address
                                    mem[ceil32(_36725) + u + 132] = 128
                                    _40518 = mem[_40454]
                                    mem[ceil32(_36725) + u + 164] = mem[_40454]
                                    s = 0
                                    while s < _40518:
                                        mem[s + ceil32(_36725) + u + 196] = mem[_40454 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40518) <= _40518:
                                        require ext_code.size(address(_31646))
                                        call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30425, 0, address(this.address), 128, mem[ceil32(_36725) + u + 164 len ceil32(_40518) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36725) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36725) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36725) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47024 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47024] = return_data.size
                                            mem[_47024 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36725) + u + _40518 + 196] = 0
                                        require ext_code.size(address(_31646))
                                        call address(_31646).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30425, 0, address(this.address), 128, mem[ceil32(_36725) + u + 164 len ceil32(_40518) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36725) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36725) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36725) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36725) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36725) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47025 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47025] = return_data.size
                                            mem[_47025 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22197 + ceil32(return_data.size) + 128 len 32 * _22392] = call.data[calldata.size len 32 * _22392]
                            require mem[_22197 + ceil32(return_data.size) + 96] - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                            mem[(32 * mem[_22197 + ceil32(return_data.size) + 96] - 1) + _22197 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            s = mem[_22197] - 1
                            while s:
                                require s - 1 < mem[_22197]
                                _29562 = mem[(32 * s - 1) + _22197 + 32]
                                require s < mem[_22197]
                                _29608 = mem[(32 * s) + _22197 + 32]
                                if mem[(32 * s - 1) + _22197 + 44 len 20] == mem[(32 * s) + _22197 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s - 1) + _22197 + 44 len 20] < mem[(32 * s) + _22197 + 44 len 20]:
                                    if not mem[(32 * s - 1) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29608)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29562) == address(_29562):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                else:
                                    if not mem[(32 * s) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s - 1) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29608)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    48,
                                                    0x54556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4f55545055545f414d4f554e,
                                                    mem[mem[64] + 116 len 16]
                                    if address(_29608) == address(_29562):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[0]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[32]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[0]) / (997 * Mask(112, 0, ext_call.return_data[32])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not Mask(112, 0, ext_call.return_data[32]):
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                            if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                            if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                        else:
                                            if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]):
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (0 / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                            else:
                                                if 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] > Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                if (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) / Mask(112, 0, ext_call.return_data[0]) - mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                require (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])
                                                if (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1 < 1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]):
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s - 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                mem[(32 * s - 1) + _22197 + ceil32(return_data.size) + 128] = (1000 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] * Mask(112, 0, ext_call.return_data[32]) / (997 * Mask(112, 0, ext_call.return_data[0])) - (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128])) + 1
                                s = s - 1
                                continue 
                            require 0 < mem[_22197 + ceil32(return_data.size) + 96]
                            if mem[_22197 + ceil32(return_data.size) + 128] + cd[((160 * idx) + cd[4] + 68)] > _22283:
                            _29706 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29706] = _7368
                            mem[_29706 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29706 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29706 + 96] = 1
                            _30035 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30035] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30320 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30432 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30577 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30751 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30927 = mem[_30751]
                            require mem[_30751] == mem[_30751 + 12 len 20]
                            mem[mem[64] + 4] = address(_30320)
                            mem[mem[64] + 36] = address(_30577)
                            require ext_code.size(address(_30927))
                            staticcall address(_30927).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30320), address(_30577)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31383 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31663 = mem[_31383]
                            require mem[_31383] == mem[_31383 + 12 len 20]
                            require ext_code.size(mem[_31383 + 12 len 20])
                            staticcall mem[_31383 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32567 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32567] == mem[_32567 + 12 len 20]
                            if address(_30320) == mem[_32567 + 12 len 20]:
                                _33292 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33388 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33388) + 256
                                v = mem[64] + 256
                                while s < _33388:
                                    mem[v] = u + -_33292 - 256
                                    _36531 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36533 = mem[_36531 + 32]
                                    mem[u + 32] = 96
                                    _36676 = mem[_36533]
                                    mem[u + 96] = mem[_36533]
                                    idx = 0
                                    w = _36533 + 32
                                    x = u + 128
                                    while idx < _36676:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40322 = mem[_36531 + 64]
                                    mem[u + 64] = (32 * _36676) + 128
                                    _40323 = mem[_40322]
                                    mem[u + (32 * _36676) + 128] = mem[_40322]
                                    w = u + (32 * _36676) + 160
                                    idx = 0
                                    x = _40322 + 32
                                    while idx < _40323:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36676) + (32 * _40323) + 160
                                    v = v + 32
                                    continue 
                                mem[_33292 + 128] = mem[_29706 + 32]
                                mem[_33292 + 160] = bool(mem[_29706 + 64])
                                mem[_33292 + 192] = bool(mem[_29706 + 96])
                                mem[_33292 + 64] = u + -_33292 - 32
                                _36727 = mem[_30035]
                                mem[u] = mem[_30035]
                                s = 0
                                while s < _36727:
                                    mem[s + u + 32] = mem[_30035 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36727) <= _36727:
                                    _40402 = mem[64]
                                    mem[mem[64]] = ceil32(_36727) + u - mem[64]
                                    mem[64] = ceil32(_36727) + u + 32
                                    mem[ceil32(_36727) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36727) + u + 36] = _30432
                                    mem[ceil32(_36727) + u + 68] = 0
                                    mem[ceil32(_36727) + u + 100] = this.address
                                    mem[ceil32(_36727) + u + 132] = 128
                                    _40488 = mem[_40402]
                                    mem[ceil32(_36727) + u + 164] = mem[_40402]
                                    s = 0
                                    while s < _40488:
                                        mem[s + ceil32(_36727) + u + 196] = mem[_40402 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40488) <= _40488:
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30432, 0, address(this.address), 128, mem[ceil32(_36727) + u + 164 len ceil32(_40488) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36727) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36727) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36727) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47030 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47030] = return_data.size
                                            mem[_47030 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36727) + u + _40488 + 196] = 0
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30432, 0, address(this.address), 128, mem[ceil32(_36727) + u + 164 len ceil32(_40488) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36727) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36727) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36727) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47031 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47031] = return_data.size
                                            mem[_47031 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36727 + 32] = 0
                                    _40456 = mem[64]
                                    mem[mem[64]] = ceil32(_36727) + u - mem[64]
                                    mem[64] = ceil32(_36727) + u + 32
                                    mem[ceil32(_36727) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36727) + u + 36] = _30432
                                    mem[ceil32(_36727) + u + 68] = 0
                                    mem[ceil32(_36727) + u + 100] = this.address
                                    mem[ceil32(_36727) + u + 132] = 128
                                    _40520 = mem[_40456]
                                    mem[ceil32(_36727) + u + 164] = mem[_40456]
                                    s = 0
                                    while s < _40520:
                                        mem[s + ceil32(_36727) + u + 196] = mem[_40456 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40520) <= _40520:
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30432, 0, address(this.address), 128, mem[ceil32(_36727) + u + 164 len ceil32(_40520) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36727) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36727) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36727) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47032 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47032] = return_data.size
                                            mem[_47032 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36727) + u + _40520 + 196] = 0
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30432, 0, address(this.address), 128, mem[ceil32(_36727) + u + 164 len ceil32(_40520) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36727) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36727) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36727) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36727) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36727) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47033] = return_data.size
                                            mem[_47033 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                            else:
                                _33293 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33389 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33389) + 256
                                v = mem[64] + 256
                                while s < _33389:
                                    mem[v] = u + -_33293 - 256
                                    _36534 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36536 = mem[_36534 + 32]
                                    mem[u + 32] = 96
                                    _36680 = mem[_36536]
                                    mem[u + 96] = mem[_36536]
                                    idx = 0
                                    w = _36536 + 32
                                    x = u + 128
                                    while idx < _36680:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40324 = mem[_36534 + 64]
                                    mem[u + 64] = (32 * _36680) + 128
                                    _40325 = mem[_40324]
                                    mem[u + (32 * _36680) + 128] = mem[_40324]
                                    w = u + (32 * _36680) + 160
                                    idx = 0
                                    x = _40324 + 32
                                    while idx < _40325:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36680) + (32 * _40325) + 160
                                    v = v + 32
                                    continue 
                                mem[_33293 + 128] = mem[_29706 + 32]
                                mem[_33293 + 160] = bool(mem[_29706 + 64])
                                mem[_33293 + 192] = bool(mem[_29706 + 96])
                                mem[_33293 + 64] = u + -_33293 - 32
                                _36728 = mem[_30035]
                                mem[u] = mem[_30035]
                                s = 0
                                while s < _36728:
                                    mem[s + u + 32] = mem[_30035 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36728) <= _36728:
                                    _40404 = mem[64]
                                    mem[mem[64]] = ceil32(_36728) + u - mem[64]
                                    mem[64] = ceil32(_36728) + u + 32
                                    mem[ceil32(_36728) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36728) + u + 36] = 0
                                    mem[ceil32(_36728) + u + 68] = _30432
                                    mem[ceil32(_36728) + u + 100] = this.address
                                    mem[ceil32(_36728) + u + 132] = 128
                                    _40489 = mem[_40404]
                                    mem[ceil32(_36728) + u + 164] = mem[_40404]
                                    s = 0
                                    while s < _40489:
                                        mem[s + ceil32(_36728) + u + 196] = mem[_40404 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40489) > _40489:
                                        mem[ceil32(_36728) + u + _40489 + 196] = 0
                                    require ext_code.size(address(_31663))
                                    call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, _30432, address(this.address), 128, mem[ceil32(_36728) + u + 164 len ceil32(_40489) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36728) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36728) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36728) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36728) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36728) + u + ceil32(return_data.size) + -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36728) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                    if not return_data.size:
                                        if not ext_call.success:
                                            revert with 0, 
                                                        32,
                                                        36,
                                                        0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 168 len 28]
                                    else:
                                        mem[64] = ceil32(_36728) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 64] = return_data.size
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 
                                                        32,
                                                        36,
                                                        0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                else:
                                    mem[u + _36728 + 32] = 0
                                    _40457 = mem[64]
                                    mem[mem[64]] = ceil32(_36728) + u - mem[64]
                                    mem[64] = ceil32(_36728) + u + 32
                                    mem[ceil32(_36728) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36728) + u + 36] = 0
                                    mem[ceil32(_36728) + u + 68] = _30432
                                    mem[ceil32(_36728) + u + 100] = this.address
                                    mem[ceil32(_36728) + u + 132] = 128
                                    _40521 = mem[_40457]
                                    mem[ceil32(_36728) + u + 164] = mem[_40457]
                                    s = 0
                                    while s < _40521:
                                        mem[s + ceil32(_36728) + u + 196] = mem[_40457 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40521) <= _40521:
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30432, address(this.address), 128, mem[ceil32(_36728) + u + 164 len ceil32(_40521) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36728) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36728) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36728) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36728) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47036 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47036] = return_data.size
                                            mem[_47036 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36728) + u + _40521 + 196] = 0
                                        require ext_code.size(address(_31663))
                                        call address(_31663).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30432, address(this.address), 128, mem[ceil32(_36728) + u + 164 len ceil32(_40521) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36728) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36728) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36728) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36728) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36728) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36728) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47037] = return_data.size
                                            mem[_47037 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                    else:
                        require 0 < mem[_7368]
                        require 0 < mem[mem[mem[_7368 + 32] + 64]]
                        _22285 = mem[mem[mem[_7368 + 32] + 64] + 32]
                        mem[_22197 + 100] = cd[((160 * idx) + cd[4] + 36)]
                        require ext_code.size(0xda67235dd5787d67955420c84ca1cecd4e5bb3b)
                        staticcall 0xda67235dd5787d67955420c84ca1cecd4e5bb3b.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[((160 * idx) + cd[4] + 36)]
                        mem[_22197 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _22197 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require 0 < mem[_22197]
                        mem[_22197 + 32] = 0xda67235dd5787d67955420c84ca1cecd4e5bb3b
                        require 1 < mem[_22197]
                        mem[_22197 + 64] = 0x130966628846bfd36ff31a822705796e8cb8c18d
                        if mem[_22197] < 2:
                            revert with 0, 
                                        32,
                                        34,
                                        0x77556e697377617056324c696b654c6962726172793a20494e56414c49445f504154,
                                        mem[_22197 + ceil32(return_data.size) + 198 len 30]
                        _22395 = mem[_22197]
                        require mem[_22197] <= test266151307()
                        mem[_22197 + ceil32(return_data.size) + 96] = mem[_22197]
                        mem[64] = _22197 + ceil32(return_data.size) + (32 * mem[_22197]) + 128
                        if not _22395:
                            require 0 < mem[_22197 + ceil32(return_data.size) + 96]
                            mem[_22197 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29444 = mem[_22197]
                            s = 0
                            while s < _29444 - 1:
                                require s < mem[_22197]
                                _29565 = mem[(32 * s) + _22197 + 32]
                                require s + 1 < mem[_22197]
                                _29610 = mem[(32 * s + 1) + _22197 + 32]
                                if mem[(32 * s) + _22197 + 44 len 20] == mem[(32 * s + 1) + _22197 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22197 + 44 len 20] < mem[(32 * s + 1) + _22197 + 44 len 20]:
                                    if not mem[(32 * s) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29610)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29565) == address(_29565):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29610)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29610) == address(_29565):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22197 + ceil32(return_data.size) + 96]
                            if _22285 + cd[((160 * idx) + cd[4] + 68)] > mem[_22197 + ceil32(return_data.size) + 160]:
                            _29707 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29707] = _7368
                            mem[_29707 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29707 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29707 + 96] = 1
                            _30036 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30036] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30323 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30439 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30585 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30760 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30936 = mem[_30760]
                            require mem[_30760] == mem[_30760 + 12 len 20]
                            mem[mem[64] + 4] = address(_30323)
                            mem[mem[64] + 36] = address(_30585)
                            require ext_code.size(address(_30936))
                            staticcall address(_30936).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30323), address(_30585)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31384 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31680 = mem[_31384]
                            require mem[_31384] == mem[_31384 + 12 len 20]
                            require ext_code.size(mem[_31384 + 12 len 20])
                            staticcall mem[_31384 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32576 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32576] == mem[_32576 + 12 len 20]
                            if address(_30323) == mem[_32576 + 12 len 20]:
                                _33294 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33390 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33390) + 256
                                v = mem[64] + 256
                                while s < _33390:
                                    mem[v] = u + -_33294 - 256
                                    _36537 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36539 = mem[_36537 + 32]
                                    mem[u + 32] = 96
                                    _36684 = mem[_36539]
                                    mem[u + 96] = mem[_36539]
                                    idx = 0
                                    w = _36539 + 32
                                    x = u + 128
                                    while idx < _36684:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40326 = mem[_36537 + 64]
                                    mem[u + 64] = (32 * _36684) + 128
                                    _40327 = mem[_40326]
                                    mem[u + (32 * _36684) + 128] = mem[_40326]
                                    w = u + (32 * _36684) + 160
                                    idx = 0
                                    x = _40326 + 32
                                    while idx < _40327:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36684) + (32 * _40327) + 160
                                    v = v + 32
                                    continue 
                                mem[_33294 + 128] = mem[_29707 + 32]
                                mem[_33294 + 160] = bool(mem[_29707 + 64])
                                mem[_33294 + 192] = bool(mem[_29707 + 96])
                                mem[_33294 + 64] = u + -_33294 - 32
                                _36729 = mem[_30036]
                                mem[u] = mem[_30036]
                                s = 0
                                while s < _36729:
                                    mem[s + u + 32] = mem[_30036 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36729) <= _36729:
                                    _40406 = mem[64]
                                    mem[mem[64]] = ceil32(_36729) + u - mem[64]
                                    mem[64] = ceil32(_36729) + u + 32
                                    mem[ceil32(_36729) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36729) + u + 36] = _30439
                                    mem[ceil32(_36729) + u + 68] = 0
                                    mem[ceil32(_36729) + u + 100] = this.address
                                    mem[ceil32(_36729) + u + 132] = 128
                                    _40490 = mem[_40406]
                                    mem[ceil32(_36729) + u + 164] = mem[_40406]
                                    s = 0
                                    while s < _40490:
                                        mem[s + ceil32(_36729) + u + 196] = mem[_40406 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40490) > _40490:
                                        mem[ceil32(_36729) + u + _40490 + 196] = 0
                                    require ext_code.size(address(_31680))
                                    call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30439, 0, address(this.address), 128, mem[ceil32(_36729) + u + 164 len ceil32(_40490) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36729) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36729) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value ext_call.return_data[0] wei
                                         gas gas_remaining wei
                                else:
                                    mem[u + _36729 + 32] = 0
                                    _40458 = mem[64]
                                    mem[mem[64]] = ceil32(_36729) + u - mem[64]
                                    mem[64] = ceil32(_36729) + u + 32
                                    mem[ceil32(_36729) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36729) + u + 36] = _30439
                                    mem[ceil32(_36729) + u + 68] = 0
                                    mem[ceil32(_36729) + u + 100] = this.address
                                    mem[ceil32(_36729) + u + 132] = 128
                                    _40522 = mem[_40458]
                                    mem[ceil32(_36729) + u + 164] = mem[_40458]
                                    s = 0
                                    while s < _40522:
                                        mem[s + ceil32(_36729) + u + 196] = mem[_40458 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40522) > _40522:
                                        mem[ceil32(_36729) + u + _40522 + 196] = 0
                                    require ext_code.size(address(_31680))
                                    call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args _30439, 0, address(this.address), 128, mem[ceil32(_36729) + u + 164 len ceil32(_40522) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36729) + u + 36] = this.address
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                         gas gas_remaining wei
                                        args this.address
                                    mem[ceil32(_36729) + u + 32] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                    require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                    call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args 0, ext_call.return_data[4 len 28]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] = 0
                                    mem[64] = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    t = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    v = ceil32(_36729) + u + ceil32(return_data.size) + 64
                                    s = mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]
                                    while s >= 32:
                                        mem[v] = mem[t]
                                        t = t + 32
                                        v = v + 32
                                        s = s - 32
                                        continue 
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36729) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36729) + u + ceil32(return_data.size) + 32]) + 64])
                                    call owner with:
                                       value 0, ext_call.return_data[4 len 28] wei
                                         gas gas_remaining wei
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 168 len 28]
                                else:
                                    mem[64] = ceil32(_36729) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 64] = return_data.size
                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 
                                                    32,
                                                    36,
                                                    0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                    mem[ceil32(_36729) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                            else:
                                _33295 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33391 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33391) + 256
                                v = mem[64] + 256
                                while s < _33391:
                                    mem[v] = u + -_33295 - 256
                                    _36540 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36542 = mem[_36540 + 32]
                                    mem[u + 32] = 96
                                    _36688 = mem[_36542]
                                    mem[u + 96] = mem[_36542]
                                    idx = 0
                                    w = _36542 + 32
                                    x = u + 128
                                    while idx < _36688:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40328 = mem[_36540 + 64]
                                    mem[u + 64] = (32 * _36688) + 128
                                    _40329 = mem[_40328]
                                    mem[u + (32 * _36688) + 128] = mem[_40328]
                                    w = u + (32 * _36688) + 160
                                    idx = 0
                                    x = _40328 + 32
                                    while idx < _40329:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36688) + (32 * _40329) + 160
                                    v = v + 32
                                    continue 
                                mem[_33295 + 128] = mem[_29707 + 32]
                                mem[_33295 + 160] = bool(mem[_29707 + 64])
                                mem[_33295 + 192] = bool(mem[_29707 + 96])
                                mem[_33295 + 64] = u + -_33295 - 32
                                _36730 = mem[_30036]
                                mem[u] = mem[_30036]
                                s = 0
                                while s < _36730:
                                    mem[s + u + 32] = mem[_30036 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36730) <= _36730:
                                    _40408 = mem[64]
                                    mem[mem[64]] = ceil32(_36730) + u - mem[64]
                                    mem[64] = ceil32(_36730) + u + 32
                                    mem[ceil32(_36730) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36730) + u + 36] = 0
                                    mem[ceil32(_36730) + u + 68] = _30439
                                    mem[ceil32(_36730) + u + 100] = this.address
                                    mem[ceil32(_36730) + u + 132] = 128
                                    _40491 = mem[_40408]
                                    mem[ceil32(_36730) + u + 164] = mem[_40408]
                                    s = 0
                                    while s < _40491:
                                        mem[s + ceil32(_36730) + u + 196] = mem[_40408 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40491) <= _40491:
                                        require ext_code.size(address(_31680))
                                        call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30439, address(this.address), 128, mem[ceil32(_36730) + u + 164 len ceil32(_40491) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36730) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36730) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36730) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47042 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47042] = return_data.size
                                            mem[_47042 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                                    else:
                                        mem[ceil32(_36730) + u + _40491 + 196] = 0
                                        require ext_code.size(address(_31680))
                                        call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30439, address(this.address), 128, mem[ceil32(_36730) + u + 164 len ceil32(_40491) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36730) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        v = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        s = mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + 64] = mem[ceil32(_36730) + u + ceil32(return_data.size) + -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + 96 len mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[ceil32(_36730) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + 64])
                                        call owner with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                        if not return_data.size:
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36730) + u + ceil32(return_data.size) + 168 len 28]
                                        else:
                                            mem[64] = ceil32(_36730) + u + ceil32(return_data.size) + ceil32(return_data.size) + 65
                                            mem[ceil32(_36730) + u + ceil32(return_data.size) + 64] = return_data.size
                                            mem[ceil32(_36730) + u + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            if not ext_call.success:
                                                revert with 0, 
                                                            32,
                                                            36,
                                                            0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45,
                                                            mem[ceil32(_36730) + u + ceil32(return_data.size) + ceil32(return_data.size) + 169 len 28]
                                else:
                                    mem[u + _36730 + 32] = 0
                                    _40459 = mem[64]
                                    mem[mem[64]] = ceil32(_36730) + u - mem[64]
                                    mem[64] = ceil32(_36730) + u + 32
                                    mem[ceil32(_36730) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36730) + u + 36] = 0
                                    mem[ceil32(_36730) + u + 68] = _30439
                                    mem[ceil32(_36730) + u + 100] = this.address
                                    mem[ceil32(_36730) + u + 132] = 128
                                    _40523 = mem[_40459]
                                    mem[ceil32(_36730) + u + 164] = mem[_40459]
                                    s = 0
                                    while s < _40523:
                                        mem[s + ceil32(_36730) + u + 196] = mem[_40459 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40523) <= _40523:
                                        require ext_code.size(address(_31680))
                                        call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30439, address(this.address), 128, mem[ceil32(_36730) + u + 164 len ceil32(_40523) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36730) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36730) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36730) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47044 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47044] = return_data.size
                                            mem[_47044 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36730) + u + _40523 + 196] = 0
                                        require ext_code.size(address(_31680))
                                        call address(_31680).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30439, address(this.address), 128, mem[ceil32(_36730) + u + 164 len ceil32(_40523) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36730) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36730) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36730) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36730) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36730) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47045 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47045] = return_data.size
                                            mem[_47045 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
                        else:
                            mem[_22197 + ceil32(return_data.size) + 128 len 32 * _22395] = call.data[calldata.size len 32 * _22395]
                            require 0 < mem[_22197 + ceil32(return_data.size) + 96]
                            mem[_22197 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            _29445 = mem[_22197]
                            s = 0
                            while s < _29445 - 1:
                                require s < mem[_22197]
                                _29568 = mem[(32 * s) + _22197 + 32]
                                require s + 1 < mem[_22197]
                                _29612 = mem[(32 * s + 1) + _22197 + 32]
                                if mem[(32 * s) + _22197 + 44 len 20] == mem[(32 * s + 1) + _22197 + 44 len 20]:
                                    revert with 0, 
                                                32,
                                                41,
                                                0x48556e697377617056324c696b654c6962726172793a204944454e544943414c5f4144445245535345,
                                                mem[mem[64] + 109 len 23]
                                if mem[(32 * s) + _22197 + 44 len 20] < mem[(32 * s + 1) + _22197 + 44 len 20]:
                                    if not mem[(32 * s) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29612)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29568) == address(_29568):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                else:
                                    if not mem[(32 * s + 1) + _22197 + 44 len 20]:
                                        revert with 0, 32, 34, 0x73556e697377617056324c696b654c6962726172793a205a45524f5f414444524553, mem[mem[64] + 102 len 30]
                                    mem[mem[64] + 4] = mem[(32 * s) + _22197 + 44 len 20]
                                    require ext_code.size(0xc35dadb65012ec5796536bd9864ed8773abc74c4)
                                    staticcall 0xc35dadb65012ec5796536bd9864ed8773abc74c4.getPair(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4], address(_29612)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    staticcall address(ext_call.return_data[0]).getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    require s < mem[_22197 + ceil32(return_data.size) + 96]
                                    if mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] <= 0:
                                        revert with 0, 
                                                    32,
                                                    47,
                                                    0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                    mem[mem[64] + 115 len 17]
                                    if address(_29612) == address(_29568):
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[0])
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[0])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[0]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                    else:
                                        if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                            revert with 0, 
                                                        32,
                                                        44,
                                                        0x53556e697377617056324c696b654c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                        mem[mem[64] + 112 len 20]
                                        if not mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                            require Mask(112, 0, ext_call.return_data[32])
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 'SafeMath: addition overflow'
                                            require 1000 * Mask(112, 0, ext_call.return_data[32])
                                            require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                            mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                        else:
                                            if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != 997:
                                                revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]:
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 0 / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                            else:
                                                if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                    revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not Mask(112, 0, ext_call.return_data[32]):
                                                    if 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / 997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]
                                                else:
                                                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                        revert with 0, 32, 33, 0x44536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                    require s + 1 < mem[_22197 + ceil32(return_data.size) + 96]
                                                    mem[(32 * s + 1) + _22197 + ceil32(return_data.size) + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128] / (997 * mem[(32 * s) + _22197 + ceil32(return_data.size) + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                s = s + 1
                                continue 
                            require 1 < mem[_22197 + ceil32(return_data.size) + 96]
                            if _22285 + cd[((160 * idx) + cd[4] + 68)] > mem[_22197 + ceil32(return_data.size) + 160]:
                            _29708 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_29708] = _7368
                            mem[_29708 + 32] = cd[((160 * idx) + cd[4] + 36)]
                            require cd[((160 * idx) + cd[4] + 100)] == bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29708 + 64] = bool(cd[((160 * idx) + cd[4] + 100)])
                            mem[_29708 + 96] = 1
                            _30037 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_30037] = 0
                            require mem[_7368] - 1 < mem[_7368]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30326 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64]]
                            _30446 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 1) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 64] + 32]
                            require mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2 < mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]]
                            _30593 = mem[(32 * mem[mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32]] - 2) + mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 32] + 32]
                            require ext_code.size(mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20])
                            staticcall mem[mem[(32 * mem[_7368] - 1) + _7368 + 32] + 12 len 20].factory() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _30769 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _30945 = mem[_30769]
                            require mem[_30769] == mem[_30769 + 12 len 20]
                            mem[mem[64] + 4] = address(_30326)
                            mem[mem[64] + 36] = address(_30593)
                            require ext_code.size(address(_30945))
                            staticcall address(_30945).getPair(address arg1, address arg2) with:
                                    gas gas_remaining wei
                                   args address(_30326), address(_30593)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _31385 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _31689 = mem[_31385]
                            require mem[_31385] == mem[_31385 + 12 len 20]
                            require ext_code.size(mem[_31385 + 12 len 20])
                            staticcall mem[_31385 + 12 len 20].token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _32577 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_32577] == mem[_32577 + 12 len 20]
                            if address(_30326) == mem[_32577 + 12 len 20]:
                                _33296 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33392 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33392) + 256
                                v = mem[64] + 256
                                while s < _33392:
                                    mem[v] = u + -_33296 - 256
                                    _36543 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36545 = mem[_36543 + 32]
                                    mem[u + 32] = 96
                                    _36692 = mem[_36545]
                                    mem[u + 96] = mem[_36545]
                                    idx = 0
                                    w = _36545 + 32
                                    x = u + 128
                                    while idx < _36692:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40330 = mem[_36543 + 64]
                                    mem[u + 64] = (32 * _36692) + 128
                                    _40331 = mem[_40330]
                                    mem[u + (32 * _36692) + 128] = mem[_40330]
                                    w = u + (32 * _36692) + 160
                                    idx = 0
                                    x = _40330 + 32
                                    while idx < _40331:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36692) + (32 * _40331) + 160
                                    v = v + 32
                                    continue 
                                mem[_33296 + 128] = mem[_29708 + 32]
                                mem[_33296 + 160] = bool(mem[_29708 + 64])
                                mem[_33296 + 192] = bool(mem[_29708 + 96])
                                mem[_33296 + 64] = u + -_33296 - 32
                                _36731 = mem[_30037]
                                mem[u] = mem[_30037]
                                s = 0
                                while s < _36731:
                                    mem[s + u + 32] = mem[_30037 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36731) <= _36731:
                                    _40410 = mem[64]
                                    mem[mem[64]] = ceil32(_36731) + u - mem[64]
                                    mem[64] = ceil32(_36731) + u + 32
                                    mem[ceil32(_36731) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36731) + u + 36] = _30446
                                    mem[ceil32(_36731) + u + 68] = 0
                                    mem[ceil32(_36731) + u + 100] = this.address
                                    mem[ceil32(_36731) + u + 132] = 128
                                    _40492 = mem[_40410]
                                    mem[ceil32(_36731) + u + 164] = mem[_40410]
                                    s = 0
                                    while s < _40492:
                                        mem[s + ceil32(_36731) + u + 196] = mem[_40410 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40492) <= _40492:
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30446, 0, address(this.address), 128, mem[ceil32(_36731) + u + 164 len ceil32(_40492) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36731) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36731) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36731) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47046 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47046] = return_data.size
                                            mem[_47046 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36731) + u + _40492 + 196] = 0
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30446, 0, address(this.address), 128, mem[ceil32(_36731) + u + 164 len ceil32(_40492) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36731) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36731) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36731) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47047 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47047] = return_data.size
                                            mem[_47047 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36731 + 32] = 0
                                    _40460 = mem[64]
                                    mem[mem[64]] = ceil32(_36731) + u - mem[64]
                                    mem[64] = ceil32(_36731) + u + 32
                                    mem[ceil32(_36731) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36731) + u + 36] = _30446
                                    mem[ceil32(_36731) + u + 68] = 0
                                    mem[ceil32(_36731) + u + 100] = this.address
                                    mem[ceil32(_36731) + u + 132] = 128
                                    _40524 = mem[_40460]
                                    mem[ceil32(_36731) + u + 164] = mem[_40460]
                                    s = 0
                                    while s < _40524:
                                        mem[s + ceil32(_36731) + u + 196] = mem[_40460 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40524) <= _40524:
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30446, 0, address(this.address), 128, mem[ceil32(_36731) + u + 164 len ceil32(_40524) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36731) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36731) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36731) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47048 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47048] = return_data.size
                                            mem[_47048 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36731) + u + _40524 + 196] = 0
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args _30446, 0, address(this.address), 128, mem[ceil32(_36731) + u + 164 len ceil32(_40524) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36731) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36731) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36731) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36731) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36731) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47049 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47049] = return_data.size
                                            mem[_47049 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            else:
                                _33297 = mem[64]
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 96] = 128
                                _33393 = mem[_7368]
                                mem[mem[64] + 224] = mem[_7368]
                                s = 0
                                t = _7368 + 32
                                u = mem[64] + (32 * _33393) + 256
                                v = mem[64] + 256
                                while s < _33393:
                                    mem[v] = u + -_33297 - 256
                                    _36546 = mem[t]
                                    mem[u] = mem[mem[t] + 12 len 20]
                                    _36548 = mem[_36546 + 32]
                                    mem[u + 32] = 96
                                    _36696 = mem[_36548]
                                    mem[u + 96] = mem[_36548]
                                    idx = 0
                                    w = _36548 + 32
                                    x = u + 128
                                    while idx < _36696:
                                        mem[x] = mem[w + 12 len 20]
                                        idx = idx + 1
                                        w = w + 32
                                        x = x + 32
                                        continue 
                                    _40332 = mem[_36546 + 64]
                                    mem[u + 64] = (32 * _36696) + 128
                                    _40333 = mem[_40332]
                                    mem[u + (32 * _36696) + 128] = mem[_40332]
                                    w = u + (32 * _36696) + 160
                                    idx = 0
                                    x = _40332 + 32
                                    while idx < _40333:
                                        mem[w] = mem[x]
                                        w = w + 32
                                        idx = idx + 1
                                        x = x + 32
                                        continue 
                                    s = s + 1
                                    t = t + 32
                                    u = u + (32 * _36696) + (32 * _40333) + 160
                                    v = v + 32
                                    continue 
                                mem[_33297 + 128] = mem[_29708 + 32]
                                mem[_33297 + 160] = bool(mem[_29708 + 64])
                                mem[_33297 + 192] = bool(mem[_29708 + 96])
                                mem[_33297 + 64] = u + -_33297 - 32
                                _36732 = mem[_30037]
                                mem[u] = mem[_30037]
                                s = 0
                                while s < _36732:
                                    mem[s + u + 32] = mem[_30037 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(_36732) <= _36732:
                                    _40412 = mem[64]
                                    mem[mem[64]] = ceil32(_36732) + u - mem[64]
                                    mem[64] = ceil32(_36732) + u + 32
                                    mem[ceil32(_36732) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36732) + u + 36] = 0
                                    mem[ceil32(_36732) + u + 68] = _30446
                                    mem[ceil32(_36732) + u + 100] = this.address
                                    mem[ceil32(_36732) + u + 132] = 128
                                    _40493 = mem[_40412]
                                    mem[ceil32(_36732) + u + 164] = mem[_40412]
                                    s = 0
                                    while s < _40493:
                                        mem[s + ceil32(_36732) + u + 196] = mem[_40412 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40493) <= _40493:
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30446, address(this.address), 128, mem[ceil32(_36732) + u + 164 len ceil32(_40493) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36732) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36732) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36732) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47050 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47050] = return_data.size
                                            mem[_47050 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36732) + u + _40493 + 196] = 0
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30446, address(this.address), 128, mem[ceil32(_36732) + u + 164 len ceil32(_40493) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36732) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 36] = ext_call.return_data[0]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36732) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value ext_call.return_data[0] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36732) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47051 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47051] = return_data.size
                                            mem[_47051 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[u + _36732 + 32] = 0
                                    _40461 = mem[64]
                                    mem[mem[64]] = ceil32(_36732) + u - mem[64]
                                    mem[64] = ceil32(_36732) + u + 32
                                    mem[ceil32(_36732) + u + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(_36732) + u + 36] = 0
                                    mem[ceil32(_36732) + u + 68] = _30446
                                    mem[ceil32(_36732) + u + 100] = this.address
                                    mem[ceil32(_36732) + u + 132] = 128
                                    _40525 = mem[_40461]
                                    mem[ceil32(_36732) + u + 164] = mem[_40461]
                                    s = 0
                                    while s < _40525:
                                        mem[s + ceil32(_36732) + u + 196] = mem[_40461 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(_40525) <= _40525:
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30446, address(this.address), 128, mem[ceil32(_36732) + u + 164 len ceil32(_40525) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36732) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36732) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36732) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47052 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47052] = return_data.size
                                            mem[_47052 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    else:
                                        mem[ceil32(_36732) + u + _40525 + 196] = 0
                                        require ext_code.size(address(_31689))
                                        call address(_31689).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, _30446, address(this.address), 128, mem[ceil32(_36732) + u + 164 len ceil32(_40525) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + 36] = this.address
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.0x70a08231 with:
                                             gas gas_remaining wei
                                            args this.address
                                        mem[ceil32(_36732) + u + 32] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 36] = 0, ext_call.return_data[4 len 28]
                                        require ext_code.size(0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7)
                                        call 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7.withdraw(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args 0, ext_call.return_data[4 len 28]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] = 0
                                        mem[64] = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        t = ceil32(_36732) + u + ceil32(return_data.size) + 64
                                        v = mem[64]
                                        s = mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]
                                        while s >= 32:
                                            mem[v] = mem[t]
                                            t = t + 32
                                            v = v + 32
                                            s = s - 32
                                            continue 
                                        mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])] = mem[ceil32(_36732) + u + ceil32(return_data.size) + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32]) + -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 96 len mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32] or Mask(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32, -(8 * -(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[ceil32(_36732) + u + ceil32(return_data.size) + 32])])
                                        call owner.mem[mem[64] len 4] with:
                                           value 0, ext_call.return_data[4 len 28] wei
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(_36732) + u + ceil32(return_data.size) + -mem[64] + 60]
                                        if return_data.size:
                                            _47053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                                            mem[_47053] = return_data.size
                                            mem[_47053 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 32, 36, 0x595472616e7366657248656c7065723a20415641585f5452414e534645525f4641494c45, mem[mem[64] + 104 len 28]
        ('bool', 'ext_call.success')
        idx = idx + 1
        continue 
}



}

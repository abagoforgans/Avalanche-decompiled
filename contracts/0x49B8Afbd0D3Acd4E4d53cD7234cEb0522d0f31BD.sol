contract main {




// =====================  Runtime code  =====================


#
#  - uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#  - sub_cede3e65(?)
#
address owner;
address stor1;
address stor2;
address stor3;
address stor4;
uint256 stor5;
address stor6;
address stor7;
address stor8;
address stor9;
address stor10;
address stor11;
address stor12;
address stor13;
address stor14;

function owner() payable {
    return owner
}

function _fallback() payable {
    revert
}

function sub_ac73dc6b(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'only owner'
    mem[100] = stor8
    mem[132] = stor6
    require ext_code.size(stor1)
    staticcall stor1.getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args stor8, stor6
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 96] = 2
    mem[ceil32(return_data.size) + 128] = stor8
    mem[ceil32(return_data.size) + 160] = stor6
    mem[ceil32(return_data.size) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = arg1
    mem[ceil32(return_data.size) + 228] = 64
    mem[ceil32(return_data.size) + 260] = 2
    idx = 0
    s = ceil32(return_data.size) + 128
    t = ceil32(return_data.size) + 292
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor2)
    staticcall stor2.getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args arg1, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _134 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32
    require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
    _135 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192] > test266151307():
        revert with 'NH{q', 65
    if (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224 > test266151307() or (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 32 < 0:
        revert with 'NH{q', 65
    mem[64] = (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224
    mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    require _134 + (32 * _135) + 32 <= return_data.size
    idx = 0
    s = ceil32(return_data.size) + _134 + 224
    t = (2 * ceil32(return_data.size)) + 224
    while idx < _135:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 1 >= _135:
        revert with 'NH{q', 50
    _444 = mem[(2 * ceil32(return_data.size)) + 256]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token0() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _447 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _448 = mem[_447]
    require mem[_447] == mem[_447 + 12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _451 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _452 = mem[_451]
    require mem[_451] == mem[_451 + 12 len 20]
    _453 = mem[64]
    mem[64] = mem[64] + 64
    mem[_453] = 21
    mem[_453 + 32] = 'start to do flashswap'
    mem[mem[64] + 36] = 32
    mem[mem[64] + 68] = 21
    mem[mem[64] + 100] = 'start to do flashswap'
    mem[mem[64] + 121] = 0
    _751 = mem[64]
    mem[mem[64]] = 100
    mem[64] = mem[64] + 132
    staticcall 'console.log'.log(string arg1) with:
            gas gas_remaining wei
           args mem[_751 + 36 len mem[_751] - 4]
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args 0, 64, arg1, 25, 'amount need to return: %s', 0
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args 0, 64, _444, 19, 'amount borrowed: %s', 0
    require ext_code.size(address(ext_call.return_data[0]))
    if stor6 == address(_448):
        if stor6 == address(_452):
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _444, _444, address(this.address), 128, 128, arg1, stor8, stor6, 1
        else:
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _444, 0, address(this.address), 128, 128, arg1, stor8, stor6, 1
    else:
        if stor6 == address(_452):
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _444, address(this.address), 128, 128, arg1, stor8, stor6, 1
        else:
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, 0, address(this.address), 128, 128, arg1, stor8, stor6, 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_a1767965(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'only owner'
    mem[100] = stor8
    mem[132] = stor10
    require ext_code.size(stor3)
    staticcall stor3.getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args stor8, stor10
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 96] = 2
    mem[ceil32(return_data.size) + 128] = stor8
    mem[ceil32(return_data.size) + 160] = stor10
    mem[ceil32(return_data.size) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = arg1
    mem[ceil32(return_data.size) + 228] = 64
    mem[ceil32(return_data.size) + 260] = 2
    idx = 0
    s = ceil32(return_data.size) + 128
    t = ceil32(return_data.size) + 292
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor4)
    staticcall stor4.getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args arg1, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _134 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32
    require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
    _135 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192] > test266151307():
        revert with 'NH{q', 65
    if (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224 > test266151307() or (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 32 < 0:
        revert with 'NH{q', 65
    mem[64] = (2 * ceil32(return_data.size)) + (32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]) + 224
    mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg1) >> 32 + 192]
    require _134 + (32 * _135) + 32 <= return_data.size
    idx = 0
    s = ceil32(return_data.size) + _134 + 224
    t = (2 * ceil32(return_data.size)) + 224
    while idx < _135:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if 1 >= _135:
        revert with 'NH{q', 50
    _444 = mem[(2 * ceil32(return_data.size)) + 256]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token0() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _447 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _448 = mem[_447]
    require mem[_447] == mem[_447 + 12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _451 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _452 = mem[_451]
    require mem[_451] == mem[_451 + 12 len 20]
    _453 = mem[64]
    mem[64] = mem[64] + 64
    mem[_453] = 21
    mem[_453 + 32] = 'start to do flashswap'
    mem[mem[64] + 36] = 32
    mem[mem[64] + 68] = 21
    mem[mem[64] + 100] = 'start to do flashswap'
    mem[mem[64] + 121] = 0
    _751 = mem[64]
    mem[mem[64]] = 100
    mem[64] = mem[64] + 132
    staticcall 'console.log'.log(string arg1) with:
            gas gas_remaining wei
           args mem[_751 + 36 len mem[_751] - 4]
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args 0, 64, arg1, 25, 'amount need to return: %s', 0
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args 0, 64, _444, 19, 'amount borrowed: %s', 0
    require ext_code.size(address(ext_call.return_data[0]))
    if stor10 == address(_448):
        if stor10 == address(_452):
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _444, _444, address(this.address), 128, 128, arg1, stor8, stor10, 2
        else:
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _444, 0, address(this.address), 128, 128, arg1, stor8, stor10, 2
    else:
        if stor10 == address(_452):
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _444, address(this.address), 128, 128, arg1, stor8, stor10, 2
        else:
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, 0, address(this.address), 128, 128, arg1, stor8, stor10, 2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_bc9d5dc0(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(stor13)
    staticcall stor13.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if arg1 <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    if ext_call.return_data[18 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[50 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if arg1 and 997 > -1 / arg1:
        revert with 'NH{q', 17
    if 997 * arg1 / 997 != arg1:
        revert with 0, 'ds-math-mul-overflow'
    if not ext_call.return_data[50 len 14]:
        if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
            revert with 'NH{q', 18
        require ext_code.size(stor14)
        staticcall stor14.getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
        if ext_call.return_data[18 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if ext_call.return_data[50 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) and 997 > -1 / 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
            revert with 'NH{q', 17
        if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) / 997 != 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
            revert with 0, 'ds-math-mul-overflow'
        if not ext_call.return_data[50 len 14]:
            if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                revert with 'NH{q', 17
            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * ext_call.return_data[18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) - 1:
                revert with 'NH{q', 17
            if (1000 * ext_call.return_data[18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) < 1000 * ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * ext_call.return_data[18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)):
                revert with 'NH{q', 18
            require ext_code.size(stor6)
            staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                    gas gas_remaining wei
                   args (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)))
        else:
            if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) and ext_call.return_data[50 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
                revert with 'NH{q', 17
            if not ext_call.return_data[50 len 14]:
                revert with 'NH{q', 18
            if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
                revert with 0, 'ds-math-mul-overflow'
            if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                revert with 'NH{q', 17
            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * ext_call.return_data[18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) - 1:
                revert with 'NH{q', 17
            if (1000 * ext_call.return_data[18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) < 1000 * ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * ext_call.return_data[18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)):
                revert with 'NH{q', 18
            require ext_code.size(stor6)
            staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                    gas gas_remaining wei
                   args (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)))
    else:
        if 997 * arg1 and ext_call.return_data[50 len 14] > -1 / 997 * arg1:
            revert with 'NH{q', 17
        if not ext_call.return_data[50 len 14]:
            revert with 'NH{q', 18
        if 997 * arg1 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * arg1:
            revert with 0, 'ds-math-mul-overflow'
        if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[18 len 14] > (-997 * arg1) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[18 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[18 len 14]) + (997 * arg1):
            revert with 'NH{q', 18
        require ext_code.size(stor14)
        staticcall stor14.getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        if 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
        if ext_call.return_data[18 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if ext_call.return_data[50 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) and 997 > -1 / 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
            revert with 'NH{q', 17
        if 997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) / 997 != 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
            revert with 0, 'ds-math-mul-overflow'
        if not ext_call.return_data[50 len 14]:
            if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                revert with 'NH{q', 17
            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * ext_call.return_data[18 len 14] > (-997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) - 1:
                revert with 'NH{q', 17
            if (1000 * ext_call.return_data[18 len 14]) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) < 1000 * ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * ext_call.return_data[18 len 14]) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)):
                revert with 'NH{q', 18
            require ext_code.size(stor6)
            staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                    gas gas_remaining wei
                   args (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)))
        else:
            if 997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) and ext_call.return_data[50 len 14] > -1 / 997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
                revert with 'NH{q', 17
            if not ext_call.return_data[50 len 14]:
                revert with 'NH{q', 18
            if 997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1):
                revert with 0, 'ds-math-mul-overflow'
            if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
                revert with 'NH{q', 17
            if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * ext_call.return_data[18 len 14] > (-997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) - 1:
                revert with 'NH{q', 17
            if (1000 * ext_call.return_data[18 len 14]) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)) < 1000 * ext_call.return_data[18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * ext_call.return_data[18 len 14]) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)):
                revert with 'NH{q', 18
            require ext_code.size(stor6)
            staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                    gas gas_remaining wei
                   args (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1) * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * 997 * arg1 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (997 * arg1)))
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_code.size(stor12)
    staticcall stor12.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    if ext_call.return_data[18 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[50 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[0] and 997 > -1 / ext_call.return_data[0]:
        revert with 'NH{q', 17
    if 997 * ext_call.return_data[0] / 997 != ext_call.return_data[0]:
        revert with 0, 'ds-math-mul-overflow'
    if not ext_call.return_data[50 len 14]:
        if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[18 len 14] > (-997 * ext_call.return_data[0]) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]) < 1000 * ext_call.return_data[18 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]):
            revert with 'NH{q', 18
        return (0 / (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]))
    if 997 * ext_call.return_data[0] and ext_call.return_data[50 len 14] > -1 / 997 * ext_call.return_data[0]:
        revert with 'NH{q', 17
    if not ext_call.return_data[50 len 14]:
        revert with 'NH{q', 18
    if 997 * ext_call.return_data[0] * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 997 * ext_call.return_data[0]:
        revert with 0, 'ds-math-mul-overflow'
    if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
        revert with 'NH{q', 17
    if 1000 * ext_call.return_data[18 len 14] / 1000 != ext_call.return_data[18 len 14]:
        revert with 0, 'ds-math-mul-overflow'
    if 1000 * ext_call.return_data[18 len 14] > (-997 * ext_call.return_data[0]) - 1:
        revert with 'NH{q', 17
    if (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]) < 1000 * ext_call.return_data[18 len 14]:
        revert with 0, 'ds-math-add-overflow'
    if not (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]):
        revert with 'NH{q', 18
    return (997 * ext_call.return_data[0] * ext_call.return_data[50 len 14] / (1000 * ext_call.return_data[18 len 14]) + (997 * ext_call.return_data[0]))
}

function sub_2a454774(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(stor12)
    staticcall stor12.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if arg1 <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    if ext_call.return_data[50 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[18 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if arg1 and 997 > -1 / arg1:
        revert with 'NH{q', 17
    if 997 * arg1 / 997 != arg1:
        revert with 0, 'ds-math-mul-overflow'
    if not ext_call.return_data[18 len 14]:
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
            revert with 'NH{q', 18
        require ext_code.size(stor6)
        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                gas gas_remaining wei
               args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1))
    else:
        if 997 * arg1 and ext_call.return_data[18 len 14] > -1 / 997 * arg1:
            revert with 'NH{q', 17
        if not ext_call.return_data[18 len 14]:
            revert with 'NH{q', 18
        if 997 * arg1 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * arg1:
            revert with 0, 'ds-math-mul-overflow'
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[50 len 14] > (-997 * arg1) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[50 len 14]) + (997 * arg1) < 1000 * ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[50 len 14]) + (997 * arg1):
            revert with 'NH{q', 18
        require ext_code.size(stor6)
        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                gas gas_remaining wei
               args (997 * arg1 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * arg1))
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_code.size(stor14)
    staticcall stor14.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    if ext_call.return_data[50 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[18 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[0] and 997 > -1 / ext_call.return_data[0]:
        revert with 'NH{q', 17
    if 997 * ext_call.return_data[0] / 997 != ext_call.return_data[0]:
        revert with 0, 'ds-math-mul-overflow'
    if not ext_call.return_data[18 len 14]:
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[50 len 14] > (-997 * ext_call.return_data[0]) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[50 len 14]) + (997 * ext_call.return_data[0]) < 1000 * ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[50 len 14]) + (997 * ext_call.return_data[0]):
            revert with 'NH{q', 18
        require ext_code.size(stor13)
        staticcall stor13.getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
        if ext_call.return_data[50 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if ext_call.return_data[18 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) and 997 > -1 / 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
            revert with 'NH{q', 17
        if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) / 997 != 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
            revert with 0, 'ds-math-mul-overflow'
        if not ext_call.return_data[18 len 14]:
            if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
                revert with 'NH{q', 17
            if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * ext_call.return_data[50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) < 1000 * ext_call.return_data[50 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])):
                revert with 'NH{q', 18
            return (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])))
        if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) and ext_call.return_data[18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
            revert with 'NH{q', 17
        if not ext_call.return_data[18 len 14]:
            revert with 'NH{q', 18
        if 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
            revert with 0, 'ds-math-mul-overflow'
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) < 1000 * ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])):
            revert with 'NH{q', 18
        return (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])))
    if 997 * ext_call.return_data[0] and ext_call.return_data[18 len 14] > -1 / 997 * ext_call.return_data[0]:
        revert with 'NH{q', 17
    if not ext_call.return_data[18 len 14]:
        revert with 'NH{q', 18
    if 997 * ext_call.return_data[0] * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * ext_call.return_data[0]:
        revert with 0, 'ds-math-mul-overflow'
    if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
        revert with 'NH{q', 17
    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
        revert with 0, 'ds-math-mul-overflow'
    if 1000 * ext_call.return_data[50 len 14] > (-997 * ext_call.return_data[0]) - 1:
        revert with 'NH{q', 17
    if (1000 * ext_call.return_data[50 len 14]) + (997 * ext_call.return_data[0]) < 1000 * ext_call.return_data[50 len 14]:
        revert with 0, 'ds-math-add-overflow'
    if not (1000 * ext_call.return_data[50 len 14]) + (997 * ext_call.return_data[0]):
        revert with 'NH{q', 18
    require ext_code.size(stor13)
    staticcall stor13.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
    if ext_call.return_data[50 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if ext_call.return_data[18 len 14] <= 0:
        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
    if 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) and 997 > -1 / 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
        revert with 'NH{q', 17
    if 997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) / 997 != 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
        revert with 0, 'ds-math-mul-overflow'
    if not ext_call.return_data[18 len 14]:
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-mul-overflow'
        if 1000 * ext_call.return_data[50 len 14] > (-997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) < 1000 * ext_call.return_data[50 len 14]:
            revert with 0, 'ds-math-add-overflow'
        if not (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])):
            revert with 'NH{q', 18
        return (0 / (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])))
    if 997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) and ext_call.return_data[18 len 14] > -1 / 997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
        revert with 'NH{q', 17
    if not ext_call.return_data[18 len 14]:
        revert with 'NH{q', 18
    if 997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]):
        revert with 0, 'ds-math-mul-overflow'
    if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
        revert with 'NH{q', 17
    if 1000 * ext_call.return_data[50 len 14] / 1000 != ext_call.return_data[50 len 14]:
        revert with 0, 'ds-math-mul-overflow'
    if 1000 * ext_call.return_data[50 len 14] > (-997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) - 1:
        revert with 'NH{q', 17
    if (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])) < 1000 * ext_call.return_data[50 len 14]:
        revert with 0, 'ds-math-add-overflow'
    if not (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])):
        revert with 'NH{q', 18
    return (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0]) * ext_call.return_data[18 len 14] / (1000 * ext_call.return_data[50 len 14]) + (997 * 997 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (997 * ext_call.return_data[0])))
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require arg4.length >= 128
    require cd[(arg4 + 36)] == cd[(arg4 + 36)]
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 100)] == address(cd[(arg4 + 100)])
    require cd[(arg4 + 132)] == cd[(arg4 + 132)]
    if not arg2:
        if cd[(arg4 + 132)] == 1:
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, arg3, 14, 'before swap %s', 0
            require ext_code.size(address(cd[(arg4 + 100)]))
            staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
            mem[ceil32(return_data.size) + 556] = arg3
            require ext_code.size(stor6)
            call stor6.unwrap(uint256 arg1) with:
                 gas gas_remaining wei
                args arg3
            mem[ceil32(return_data.size) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 556] = this.address
            require ext_code.size(stor7)
            staticcall stor7.0x70a08231 with:
                    gas gas_remaining wei
                   args mem[(2 * ceil32(return_data.size)) + 556 len ceil32(return_data.size) + 32]
            mem[(2 * ceil32(return_data.size)) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 556] = stor11
            mem[(4 * ceil32(return_data.size)) + 588] = stor5
            require ext_code.size(stor7)
            call stor7.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[(4 * ceil32(return_data.size)) + 556 len (5 * ceil32(return_data.size)) + 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + 588] = 1
            require ext_code.size(stor11)
            call stor11.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, mem[(6 * ceil32(return_data.size)) + 620 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor9)
            staticcall stor9.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address), mem[(6 * ceil32(return_data.size)) + 588 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 14, 'time amount %s', 0
            mem[(7 * ceil32(return_data.size)) + 780] = 3
            mem[(7 * ceil32(return_data.size)) + 812] = stor9
            mem[(7 * ceil32(return_data.size)) + 844] = stor10
            mem[(7 * ceil32(return_data.size)) + 876] = stor8
            mem[(7 * ceil32(return_data.size)) + 912] = stor4
            mem[(7 * ceil32(return_data.size)) + 944] = stor5
            require ext_code.size(stor9)
            call stor9.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, stor5
            mem[(7 * ceil32(return_data.size)) + 908] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(8 * ceil32(return_data.size)) + 908] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
            mem[(8 * ceil32(return_data.size)) + 912] = ext_call.return_data[0]
            mem[(8 * ceil32(return_data.size)) + 944] = 0
            mem[(8 * ceil32(return_data.size)) + 976] = 160
            mem[(8 * ceil32(return_data.size)) + 1072] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 812
            t = (8 * ceil32(return_data.size)) + 1104
            while idx < mem[(7 * ceil32(return_data.size)) + 780]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor4)
            call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, mem[(8 * ceil32(return_data.size)) + 1072 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor8)
            staticcall stor8.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
            if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                revert with 0, 'not profitable'
            if ext_call.return_data[0] < cd[(arg4 + 36)]:
                revert with 'NH{q', 17
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
        else:
            if cd[(arg4 + 132)] == 2:
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, arg3, 14, 'before swap %s', 0
                require ext_code.size(address(cd[(arg4 + 100)]))
                staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
                mem[ceil32(return_data.size) + 552] = 2
                mem[ceil32(return_data.size) + 584] = stor10
                mem[ceil32(return_data.size) + 616] = stor9
                mem[ceil32(return_data.size) + 652] = stor4
                mem[ceil32(return_data.size) + 684] = stor5
                require ext_code.size(stor10)
                call stor10.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, stor5
                mem[ceil32(return_data.size) + 648] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(2 * ceil32(return_data.size)) + 648] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 652] = arg3
                mem[(2 * ceil32(return_data.size)) + 684] = 0
                mem[(2 * ceil32(return_data.size)) + 716] = 160
                mem[(2 * ceil32(return_data.size)) + 812] = 2
                idx = 0
                s = ceil32(return_data.size) + 584
                t = (2 * ceil32(return_data.size)) + 844
                while idx < mem[ceil32(return_data.size) + 552]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor4)
                call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg3, 0, 160, address(this.address), block.timestamp + 60, mem[(2 * ceil32(return_data.size)) + 812 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor9)
                staticcall stor9.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 14, 'time amount %s', 0
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.stake(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.claim(address arg1) with:
                     gas gas_remaining wei
                    args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor7)
                staticcall stor7.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 14, 'memo amount %s', 0
                mem[(8 * ceil32(return_data.size)) + 1140] = stor5
                require ext_code.size(stor7)
                call stor7.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor6)
                call stor6.wrap(uint256 arg1) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(11 * ceil32(return_data.size)) + 1140 len 9 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address), mem[(14 * ceil32(return_data.size)) + 1204 len 13 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(14 * ceil32(return_data.size)) + 1315] = 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wmemo amount %s', mem[(14 * ceil32(return_data.size)) + 1315 len (15 * ceil32(return_data.size)) + 17]
                mem[(14 * ceil32(return_data.size)) + 1364] = stor6
                mem[(14 * ceil32(return_data.size)) + 1396] = stor8
                require ext_code.size(stor6)
                call stor6.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor2, stor5
                mem[(14 * ceil32(return_data.size)) + 1428] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(15 * ceil32(return_data.size)) + 1428] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(15 * ceil32(return_data.size)) + 1432] = ext_call.return_data[0]
                idx = 0
                s = (14 * ceil32(return_data.size)) + 1364
                t = (15 * ceil32(return_data.size)) + 1624
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor2)
                call stor2.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, 2, mem[(15 * ceil32(return_data.size)) + 1624 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor8)
                staticcall stor8.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
                if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                    revert with 0, 'not profitable'
                if ext_call.return_data[0] < cd[(arg4 + 36)]:
                    revert with 'NH{q', 17
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
    else:
        if cd[(arg4 + 132)] == 1:
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, arg2, 14, 'before swap %s', 0
            require ext_code.size(address(cd[(arg4 + 100)]))
            staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
            mem[ceil32(return_data.size) + 556] = arg2
            require ext_code.size(stor6)
            call stor6.unwrap(uint256 arg1) with:
                 gas gas_remaining wei
                args arg2
            mem[ceil32(return_data.size) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 556] = this.address
            require ext_code.size(stor7)
            staticcall stor7.0x70a08231 with:
                    gas gas_remaining wei
                   args mem[(2 * ceil32(return_data.size)) + 556 len ceil32(return_data.size) + 32]
            mem[(2 * ceil32(return_data.size)) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 556] = stor11
            mem[(4 * ceil32(return_data.size)) + 588] = stor5
            require ext_code.size(stor7)
            call stor7.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[(4 * ceil32(return_data.size)) + 556 len (5 * ceil32(return_data.size)) + 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + 588] = 1
            require ext_code.size(stor11)
            call stor11.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, mem[(6 * ceil32(return_data.size)) + 620 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor9)
            staticcall stor9.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address), mem[(6 * ceil32(return_data.size)) + 588 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 14, 'time amount %s', 0
            mem[(7 * ceil32(return_data.size)) + 780] = 3
            mem[(7 * ceil32(return_data.size)) + 812] = stor9
            mem[(7 * ceil32(return_data.size)) + 844] = stor10
            mem[(7 * ceil32(return_data.size)) + 876] = stor8
            mem[(7 * ceil32(return_data.size)) + 912] = stor4
            mem[(7 * ceil32(return_data.size)) + 944] = stor5
            require ext_code.size(stor9)
            call stor9.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, stor5
            mem[(7 * ceil32(return_data.size)) + 908] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(8 * ceil32(return_data.size)) + 908] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
            mem[(8 * ceil32(return_data.size)) + 912] = ext_call.return_data[0]
            mem[(8 * ceil32(return_data.size)) + 944] = 0
            mem[(8 * ceil32(return_data.size)) + 976] = 160
            mem[(8 * ceil32(return_data.size)) + 1072] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 812
            t = (8 * ceil32(return_data.size)) + 1104
            while idx < mem[(7 * ceil32(return_data.size)) + 780]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor4)
            call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, mem[(8 * ceil32(return_data.size)) + 1072 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor8)
            staticcall stor8.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
            if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                revert with 0, 'not profitable'
            if ext_call.return_data[0] < cd[(arg4 + 36)]:
                revert with 'NH{q', 17
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
        else:
            if cd[(arg4 + 132)] == 2:
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, arg2, 14, 'before swap %s', 0
                require ext_code.size(address(cd[(arg4 + 100)]))
                staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
                mem[ceil32(return_data.size) + 552] = 2
                mem[ceil32(return_data.size) + 584] = stor10
                mem[ceil32(return_data.size) + 616] = stor9
                mem[ceil32(return_data.size) + 652] = stor4
                mem[ceil32(return_data.size) + 684] = stor5
                require ext_code.size(stor10)
                call stor10.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, stor5
                mem[ceil32(return_data.size) + 648] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(2 * ceil32(return_data.size)) + 648] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 652] = arg2
                mem[(2 * ceil32(return_data.size)) + 684] = 0
                mem[(2 * ceil32(return_data.size)) + 716] = 160
                mem[(2 * ceil32(return_data.size)) + 812] = 2
                idx = 0
                s = ceil32(return_data.size) + 584
                t = (2 * ceil32(return_data.size)) + 844
                while idx < mem[ceil32(return_data.size) + 552]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor4)
                call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, mem[(2 * ceil32(return_data.size)) + 812 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor9)
                staticcall stor9.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 14, 'time amount %s', 0
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.stake(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.claim(address arg1) with:
                     gas gas_remaining wei
                    args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor7)
                staticcall stor7.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 14, 'memo amount %s', 0
                mem[(8 * ceil32(return_data.size)) + 1140] = stor5
                require ext_code.size(stor7)
                call stor7.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor6)
                call stor6.wrap(uint256 arg1) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(11 * ceil32(return_data.size)) + 1140 len 9 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address), mem[(14 * ceil32(return_data.size)) + 1204 len 13 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(14 * ceil32(return_data.size)) + 1315] = 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wmemo amount %s', mem[(14 * ceil32(return_data.size)) + 1315 len (15 * ceil32(return_data.size)) + 17]
                mem[(14 * ceil32(return_data.size)) + 1364] = stor6
                mem[(14 * ceil32(return_data.size)) + 1396] = stor8
                require ext_code.size(stor6)
                call stor6.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor2, stor5
                mem[(14 * ceil32(return_data.size)) + 1428] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(15 * ceil32(return_data.size)) + 1428] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(15 * ceil32(return_data.size)) + 1432] = ext_call.return_data[0]
                mem[(15 * ceil32(return_data.size)) + 1592] = 2
                idx = 0
                s = (14 * ceil32(return_data.size)) + 1364
                t = (15 * ceil32(return_data.size)) + 1624
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(15 * ceil32(return_data.size)) + 1528] = this.address
                mem[(15 * ceil32(return_data.size)) + 1560] = block.timestamp + 60
                require ext_code.size(stor2)
                call stor2.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, 2, mem[(15 * ceil32(return_data.size)) + 1624 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor8)
                staticcall stor8.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(16 * ceil32(return_data.size)) + 1528] = 64
                mem[(16 * ceil32(return_data.size)) + 1592] = 18
                mem[(16 * ceil32(return_data.size)) + 1624] = 'amount Mim back %s'
                mem[(16 * ceil32(return_data.size)) + 1642] = 0
                mem[(16 * ceil32(return_data.size)) + 1560] = ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args mem[(16 * ceil32(return_data.size)) + 1528 len (9 * ceil32(return_data.size)) + 128]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
                if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                    revert with 0, 'not profitable'
                if ext_call.return_data[0] < cd[(arg4 + 36)]:
                    revert with 'NH{q', 17
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function pangolinCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require arg4.length >= 128
    require cd[(arg4 + 36)] == cd[(arg4 + 36)]
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 100)] == address(cd[(arg4 + 100)])
    require cd[(arg4 + 132)] == cd[(arg4 + 132)]
    if not arg2:
        if cd[(arg4 + 132)] == 1:
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, arg3, 14, 'before swap %s', 0
            require ext_code.size(address(cd[(arg4 + 100)]))
            staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
            mem[ceil32(return_data.size) + 556] = arg3
            require ext_code.size(stor6)
            call stor6.unwrap(uint256 arg1) with:
                 gas gas_remaining wei
                args arg3
            mem[ceil32(return_data.size) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 556] = this.address
            require ext_code.size(stor7)
            staticcall stor7.0x70a08231 with:
                    gas gas_remaining wei
                   args mem[(2 * ceil32(return_data.size)) + 556 len ceil32(return_data.size) + 32]
            mem[(2 * ceil32(return_data.size)) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 556] = stor11
            mem[(4 * ceil32(return_data.size)) + 588] = stor5
            require ext_code.size(stor7)
            call stor7.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[(4 * ceil32(return_data.size)) + 556 len (5 * ceil32(return_data.size)) + 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + 588] = 1
            require ext_code.size(stor11)
            call stor11.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, mem[(6 * ceil32(return_data.size)) + 620 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor9)
            staticcall stor9.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address), mem[(6 * ceil32(return_data.size)) + 588 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 14, 'time amount %s', 0
            mem[(7 * ceil32(return_data.size)) + 780] = 3
            mem[(7 * ceil32(return_data.size)) + 812] = stor9
            mem[(7 * ceil32(return_data.size)) + 844] = stor10
            mem[(7 * ceil32(return_data.size)) + 876] = stor8
            mem[(7 * ceil32(return_data.size)) + 912] = stor4
            mem[(7 * ceil32(return_data.size)) + 944] = stor5
            require ext_code.size(stor9)
            call stor9.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, stor5
            mem[(7 * ceil32(return_data.size)) + 908] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(8 * ceil32(return_data.size)) + 908] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
            mem[(8 * ceil32(return_data.size)) + 912] = ext_call.return_data[0]
            mem[(8 * ceil32(return_data.size)) + 944] = 0
            mem[(8 * ceil32(return_data.size)) + 976] = 160
            mem[(8 * ceil32(return_data.size)) + 1072] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 812
            t = (8 * ceil32(return_data.size)) + 1104
            while idx < mem[(7 * ceil32(return_data.size)) + 780]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor4)
            call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, mem[(8 * ceil32(return_data.size)) + 1072 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor8)
            staticcall stor8.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
            if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                revert with 0, 'not profitable'
            if ext_call.return_data[0] < cd[(arg4 + 36)]:
                revert with 'NH{q', 17
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
        else:
            if cd[(arg4 + 132)] == 2:
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, arg3, 14, 'before swap %s', 0
                require ext_code.size(address(cd[(arg4 + 100)]))
                staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
                mem[ceil32(return_data.size) + 552] = 2
                mem[ceil32(return_data.size) + 584] = stor10
                mem[ceil32(return_data.size) + 616] = stor9
                mem[ceil32(return_data.size) + 652] = stor4
                mem[ceil32(return_data.size) + 684] = stor5
                require ext_code.size(stor10)
                call stor10.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, stor5
                mem[ceil32(return_data.size) + 648] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(2 * ceil32(return_data.size)) + 648] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 652] = arg3
                mem[(2 * ceil32(return_data.size)) + 684] = 0
                mem[(2 * ceil32(return_data.size)) + 716] = 160
                mem[(2 * ceil32(return_data.size)) + 812] = 2
                idx = 0
                s = ceil32(return_data.size) + 584
                t = (2 * ceil32(return_data.size)) + 844
                while idx < mem[ceil32(return_data.size) + 552]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor4)
                call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg3, 0, 160, address(this.address), block.timestamp + 60, mem[(2 * ceil32(return_data.size)) + 812 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor9)
                staticcall stor9.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 14, 'time amount %s', 0
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.stake(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.claim(address arg1) with:
                     gas gas_remaining wei
                    args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor7)
                staticcall stor7.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 14, 'memo amount %s', 0
                mem[(8 * ceil32(return_data.size)) + 1140] = stor5
                require ext_code.size(stor7)
                call stor7.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor6)
                call stor6.wrap(uint256 arg1) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(11 * ceil32(return_data.size)) + 1140 len 9 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address), mem[(14 * ceil32(return_data.size)) + 1204 len 13 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(14 * ceil32(return_data.size)) + 1315] = 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wmemo amount %s', mem[(14 * ceil32(return_data.size)) + 1315 len (15 * ceil32(return_data.size)) + 17]
                mem[(14 * ceil32(return_data.size)) + 1364] = stor6
                mem[(14 * ceil32(return_data.size)) + 1396] = stor8
                require ext_code.size(stor6)
                call stor6.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor2, stor5
                mem[(14 * ceil32(return_data.size)) + 1428] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(15 * ceil32(return_data.size)) + 1428] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(15 * ceil32(return_data.size)) + 1432] = ext_call.return_data[0]
                idx = 0
                s = (14 * ceil32(return_data.size)) + 1364
                t = (15 * ceil32(return_data.size)) + 1624
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor2)
                call stor2.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, 2, mem[(15 * ceil32(return_data.size)) + 1624 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor8)
                staticcall stor8.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
                if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                    revert with 0, 'not profitable'
                if ext_call.return_data[0] < cd[(arg4 + 36)]:
                    revert with 'NH{q', 17
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
    else:
        if cd[(arg4 + 132)] == 1:
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, arg2, 14, 'before swap %s', 0
            require ext_code.size(address(cd[(arg4 + 100)]))
            staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
            mem[ceil32(return_data.size) + 556] = arg2
            require ext_code.size(stor6)
            call stor6.unwrap(uint256 arg1) with:
                 gas gas_remaining wei
                args arg2
            mem[ceil32(return_data.size) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 556] = this.address
            require ext_code.size(stor7)
            staticcall stor7.0x70a08231 with:
                    gas gas_remaining wei
                   args mem[(2 * ceil32(return_data.size)) + 556 len ceil32(return_data.size) + 32]
            mem[(2 * ceil32(return_data.size)) + 552] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 556] = stor11
            mem[(4 * ceil32(return_data.size)) + 588] = stor5
            require ext_code.size(stor7)
            call stor7.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[(4 * ceil32(return_data.size)) + 556 len (5 * ceil32(return_data.size)) + 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + 588] = 1
            require ext_code.size(stor11)
            call stor11.unstake(uint256 arg1, bool arg2) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, mem[(6 * ceil32(return_data.size)) + 620 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor9)
            staticcall stor9.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address), mem[(6 * ceil32(return_data.size)) + 588 len 9 * ceil32(return_data.size)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 0, ext_call.return_data[0], 14, 'time amount %s', 0
            mem[(7 * ceil32(return_data.size)) + 780] = 3
            mem[(7 * ceil32(return_data.size)) + 812] = stor9
            mem[(7 * ceil32(return_data.size)) + 844] = stor10
            mem[(7 * ceil32(return_data.size)) + 876] = stor8
            mem[(7 * ceil32(return_data.size)) + 912] = stor4
            mem[(7 * ceil32(return_data.size)) + 944] = stor5
            require ext_code.size(stor9)
            call stor9.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, stor5
            mem[(7 * ceil32(return_data.size)) + 908] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(8 * ceil32(return_data.size)) + 908] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
            mem[(8 * ceil32(return_data.size)) + 912] = ext_call.return_data[0]
            mem[(8 * ceil32(return_data.size)) + 944] = 0
            mem[(8 * ceil32(return_data.size)) + 976] = 160
            mem[(8 * ceil32(return_data.size)) + 1072] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 812
            t = (8 * ceil32(return_data.size)) + 1104
            while idx < mem[(7 * ceil32(return_data.size)) + 780]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor4)
            call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, mem[(8 * ceil32(return_data.size)) + 1072 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor8)
            staticcall stor8.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 64, ext_call.return_data[0], 18, 'amount Mim back %s', 0
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
            if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                revert with 0, 'not profitable'
            if ext_call.return_data[0] < cd[(arg4 + 36)]:
                revert with 'NH{q', 17
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor8)
            call stor8.0xa9059cbb with:
                 gas gas_remaining wei
                args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
        else:
            if cd[(arg4 + 132)] == 2:
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, arg2, 14, 'before swap %s', 0
                require ext_code.size(address(cd[(arg4 + 100)]))
                staticcall address(cd[(arg4 + 100)]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wavax amount %s', 0
                mem[ceil32(return_data.size) + 552] = 2
                mem[ceil32(return_data.size) + 584] = stor10
                mem[ceil32(return_data.size) + 616] = stor9
                mem[ceil32(return_data.size) + 652] = stor4
                mem[ceil32(return_data.size) + 684] = stor5
                require ext_code.size(stor10)
                call stor10.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, stor5
                mem[ceil32(return_data.size) + 648] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(2 * ceil32(return_data.size)) + 648] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 652] = arg2
                mem[(2 * ceil32(return_data.size)) + 684] = 0
                mem[(2 * ceil32(return_data.size)) + 716] = 160
                mem[(2 * ceil32(return_data.size)) + 812] = 2
                idx = 0
                s = ceil32(return_data.size) + 584
                t = (2 * ceil32(return_data.size)) + 844
                while idx < mem[ceil32(return_data.size) + 552]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor4)
                call stor4.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2, 0, 160, address(this.address), block.timestamp + 60, mem[(2 * ceil32(return_data.size)) + 812 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor9)
                staticcall stor9.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 64, ext_call.return_data[0], 14, 'time amount %s', 0
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.stake(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor11)
                call stor11.claim(address arg1) with:
                     gas gas_remaining wei
                    args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor7)
                staticcall stor7.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 14, 'memo amount %s', 0
                mem[(8 * ceil32(return_data.size)) + 1140] = stor5
                require ext_code.size(stor7)
                call stor7.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor6, stor5
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor6)
                call stor6.wrap(uint256 arg1) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(11 * ceil32(return_data.size)) + 1140 len 9 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address), mem[(14 * ceil32(return_data.size)) + 1204 len 13 * ceil32(return_data.size)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(14 * ceil32(return_data.size)) + 1315] = 0
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 0, ext_call.return_data[0], 15, 'wmemo amount %s', mem[(14 * ceil32(return_data.size)) + 1315 len (15 * ceil32(return_data.size)) + 17]
                mem[(14 * ceil32(return_data.size)) + 1364] = stor6
                mem[(14 * ceil32(return_data.size)) + 1396] = stor8
                require ext_code.size(stor6)
                call stor6.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor2, stor5
                mem[(14 * ceil32(return_data.size)) + 1428] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[(15 * ceil32(return_data.size)) + 1428] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                mem[(15 * ceil32(return_data.size)) + 1432] = ext_call.return_data[0]
                mem[(15 * ceil32(return_data.size)) + 1592] = 2
                idx = 0
                s = (14 * ceil32(return_data.size)) + 1364
                t = (15 * ceil32(return_data.size)) + 1624
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(15 * ceil32(return_data.size)) + 1528] = this.address
                mem[(15 * ceil32(return_data.size)) + 1560] = block.timestamp + 60
                require ext_code.size(stor2)
                call stor2.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 60, 2, mem[(15 * ceil32(return_data.size)) + 1624 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(stor8)
                staticcall stor8.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(16 * ceil32(return_data.size)) + 1528] = 64
                mem[(16 * ceil32(return_data.size)) + 1592] = 18
                mem[(16 * ceil32(return_data.size)) + 1624] = 'amount Mim back %s'
                mem[(16 * ceil32(return_data.size)) + 1642] = 0
                mem[(16 * ceil32(return_data.size)) + 1560] = ext_call.return_data[0]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args mem[(16 * ceil32(return_data.size)) + 1528 len (9 * ceil32(return_data.size)) + 128]
                staticcall 'console.log'.0x9710a9d0 with:
                        gas gas_remaining wei
                       args 0, 64, cd[(arg4 + 36)], 25, 'amount Mim need to return', 0
                if ext_call.return_data[0] <= cd[(arg4 + 36)]:
                    revert with 0, 'not profitable'
                if ext_call.return_data[0] < cd[(arg4 + 36)]:
                    revert with 'NH{q', 17
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(stor8)
                call stor8.0xa9059cbb with:
                     gas gas_remaining wei
                    args owner, ext_call.return_data[0] - cd[(arg4 + 36)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_9aba03bf(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if (32 * ('cd', 4).length) + 128 > test266151307() or (32 * ('cd', 4).length) + 128 < 96:
        revert with 'NH{q', 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == cd[s]
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 4).length
    if not ('cd', 4).length:
        if ('cd', 4).length > test266151307():
            revert with 'NH{q', 65
        mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
        mem[64] = (98 * ('cd', 4).length) + 192
        if not ('cd', 4).length:
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 'NH{q', 50
                _7063 = mem[(32 * idx) + 128]
                require ext_code.size(stor13)
                staticcall stor13.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7079 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7086 = mem[_7079]
                require mem[_7079] == mem[_7079 + 18 len 14]
                _7095 = mem[_7079 + 32]
                require mem[_7079 + 32] == mem[_7079 + 50 len 14]
                require mem[_7079 + 64] == mem[_7079 + 92 len 4]
                if _7063 <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7079 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7079 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if _7063 and 997 > -1 / _7063:
                    revert with 'NH{q', 17
                if 997 * _7063 / 997 != _7063:
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7079 + 50 len 14]:
                    if mem[_7079 + 18 len 14] and 1000 > -1 / mem[_7079 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7079 + 18 len 14] / 1000 != mem[_7079 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7079 + 18 len 14] > (-997 * _7063) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7079 + 18 len 14]) + (997 * _7063) < 1000 * mem[_7079 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7079 + 18 len 14]) + (997 * _7063):
                        revert with 'NH{q', 18
                    require ext_code.size(stor14)
                    staticcall stor14.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7182 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7190 = mem[_7182]
                    require mem[_7182] == mem[_7182 + 18 len 14]
                    _7198 = mem[_7182 + 32]
                    require mem[_7182 + 32] == mem[_7182 + 50 len 14]
                    require mem[_7182 + 64] == mem[_7182 + 92 len 4]
                    if 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7182 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7182 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) and 997 > -1 / 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                        revert with 'NH{q', 17
                    if 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) / 997 != 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7182 + 50 len 14]:
                        if mem[_7182 + 18 len 14] and 1000 > -1 / mem[_7182 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7182 + 18 len 14] / 1000 != mem[_7182 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7182 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) < 1000 * mem[_7182 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063))
                        require ext_code.size(stor6)
                        staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7190)) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7362 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7366 = mem[_7362]
                        require mem[_7362] == mem[_7362]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7410 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_7410] == mem[_7410 + 18 len 14]
                        require mem[_7410 + 32] == mem[_7410 + 50 len 14]
                        require mem[_7410 + 64] == mem[_7410 + 92 len 4]
                        if _7366 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7410 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7410 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7366 and 997 > -1 / _7366:
                            revert with 'NH{q', 17
                        if 997 * _7366 / 997 != _7366:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7410 + 50 len 14]:
                            if mem[_7410 + 18 len 14] and 1000 > -1 / mem[_7410 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7410 + 18 len 14] / 1000 != mem[_7410 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7410 + 18 len 14] > (-997 * _7366) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7410 + 18 len 14]) + (997 * _7366) < 1000 * mem[_7410 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7410 + 18 len 14]) + (997 * _7366):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7410 + 18 len 14]) + (997 * _7366)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7754 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7766 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _7786 = mem[_7766]
                            require mem[_7766] == mem[_7766 + 18 len 14]
                            _7818 = mem[_7766 + 32]
                            require mem[_7766 + 32] == mem[_7766 + 50 len 14]
                            require mem[_7766 + 64] == mem[_7766 + 92 len 4]
                            if _7754 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_7766 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_7766 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7754 and 997 > -1 / _7754:
                                revert with 'NH{q', 17
                            if 997 * _7754 / 997 != _7754:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_7766 + 18 len 14]:
                                if mem[_7766 + 50 len 14] and 1000 > -1 / mem[_7766 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7766 + 50 len 14] / 1000 != mem[_7766 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7766 + 50 len 14] > (-997 * _7754) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7766 + 50 len 14]) + (997 * _7754) < 1000 * mem[_7766 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7766 + 50 len 14]) + (997 * _7754):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_7766 + 50 len 14]) + (997 * _7754)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _7818)) + (997 * _7754))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8498 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8506 = mem[_8498]
                                require mem[_8498] == mem[_8498]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8618 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _8666 = mem[_8618]
                                require mem[_8618] == mem[_8618 + 18 len 14]
                                _8746 = mem[_8618 + 32]
                                require mem[_8618 + 32] == mem[_8618 + 50 len 14]
                                require mem[_8618 + 64] == mem[_8618 + 92 len 4]
                                if _8506 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8618 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_8618 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8506 and 997 > -1 / _8506:
                                    revert with 'NH{q', 17
                                if 997 * _8506 / 997 != _8506:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_8618 + 18 len 14]:
                                    if mem[_8618 + 50 len 14] and 1000 > -1 / mem[_8618 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8618 + 50 len 14] / 1000 != mem[_8618 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8618 + 50 len 14] > (-997 * _8506) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8618 + 50 len 14]) + (997 * _8506) < 1000 * mem[_8618 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8618 + 50 len 14]) + (997 * _8506):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_9898] == mem[_9898 + 18 len 14]
                                    require mem[_9898 + 32] == mem[_9898 + 50 len 14]
                                    require mem[_9898 + 64] == mem[_9898 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_9898 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_9898 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) / 997 != 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_9898 + 18 len 14]:
                                        if mem[_9898 + 50 len 14] and 1000 > -1 / mem[_9898 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_9898 + 50 len 14] / 1000 != mem[_9898 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_9898 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) < 1000 * mem[_9898 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) and mem[_9898 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                            revert with 'NH{q', 17
                                        if not mem[_9898 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) * mem[_9898 + 18 len 14] / mem[_9898 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_9898 + 50 len 14] and 1000 > -1 / mem[_9898 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_9898 + 50 len 14] / 1000 != mem[_9898 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_9898 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) < 1000 * mem[_9898 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506) * mem[_9898 + 18 len 14] / (1000 * mem[_9898 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8746)) + (997 * _8506))
                                else:
                                    if 997 * _8506 and mem[_8618 + 18 len 14] > -1 / 997 * _8506:
                                        revert with 'NH{q', 17
                                    if not mem[_8618 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8506 * mem[_8618 + 18 len 14] / mem[_8618 + 18 len 14] != 997 * _8506:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_8618 + 50 len 14] and 1000 > -1 / mem[_8618 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8618 + 50 len 14] / 1000 != mem[_8618 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8618 + 50 len 14] > (-997 * _8506) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8618 + 50 len 14]) + (997 * _8506) < 1000 * mem[_8618 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8618 + 50 len 14]) + (997 * _8506):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10142 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10142] == mem[_10142 + 18 len 14]
                                    require mem[_10142 + 32] == mem[_10142 + 50 len 14]
                                    require mem[_10142 + 64] == mem[_10142 + 92 len 4]
                                    if 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10142 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10142 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) and 997 > -1 / 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) / 997 != 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10142 + 18 len 14]:
                                        if mem[_10142 + 50 len 14] and 1000 > -1 / mem[_10142 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10142 + 50 len 14] / 1000 != mem[_10142 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10142 + 50 len 14] > (-997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) < 1000 * mem[_10142 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506))
                                    else:
                                        if 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) and mem[_10142 + 18 len 14] > -1 / 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                            revert with 'NH{q', 17
                                        if not mem[_10142 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) * mem[_10142 + 18 len 14] / mem[_10142 + 18 len 14] != 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10142 + 50 len 14] and 1000 > -1 / mem[_10142 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10142 + 50 len 14] / 1000 != mem[_10142 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10142 + 50 len 14] > (-997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)) < 1000 * mem[_10142 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506) * mem[_10142 + 18 len 14] / (1000 * mem[_10142 + 50 len 14]) + (997 * 997 * _8506 * Mask(112, 0, _8666) / (1000 * Mask(112, 0, _8746)) + (997 * _8506))
                            else:
                                if 997 * _7754 and mem[_7766 + 18 len 14] > -1 / 997 * _7754:
                                    revert with 'NH{q', 17
                                if not mem[_7766 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7754 * mem[_7766 + 18 len 14] / mem[_7766 + 18 len 14] != 997 * _7754:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_7766 + 50 len 14] and 1000 > -1 / mem[_7766 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7766 + 50 len 14] / 1000 != mem[_7766 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7766 + 50 len 14] > (-997 * _7754) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7766 + 50 len 14]) + (997 * _7754) < 1000 * mem[_7766 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7766 + 50 len 14]) + (997 * _7754):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7754 * mem[_7766 + 18 len 14] / (1000 * mem[_7766 + 50 len 14]) + (997 * _7754)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7754 * Mask(112, 0, _7786) / (1000 * Mask(112, 0, _7818)) + (997 * _7754))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8667 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8686 = mem[_8667]
                                require mem[_8667] == mem[_8667]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8822 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _8882 = mem[_8822]
                                require mem[_8822] == mem[_8822 + 18 len 14]
                                _8966 = mem[_8822 + 32]
                                require mem[_8822 + 32] == mem[_8822 + 50 len 14]
                                require mem[_8822 + 64] == mem[_8822 + 92 len 4]
                                if _8686 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8822 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_8822 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8686 and 997 > -1 / _8686:
                                    revert with 'NH{q', 17
                                if 997 * _8686 / 997 != _8686:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_8822 + 18 len 14]:
                                    if mem[_8822 + 50 len 14] and 1000 > -1 / mem[_8822 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8822 + 50 len 14] / 1000 != mem[_8822 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8822 + 50 len 14] > (-997 * _8686) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8822 + 50 len 14]) + (997 * _8686) < 1000 * mem[_8822 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8822 + 50 len 14]) + (997 * _8686):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10143 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10143] == mem[_10143 + 18 len 14]
                                    require mem[_10143 + 32] == mem[_10143 + 50 len 14]
                                    require mem[_10143 + 64] == mem[_10143 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10143 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10143 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) / 997 != 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10143 + 18 len 14]:
                                        if mem[_10143 + 50 len 14] and 1000 > -1 / mem[_10143 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10143 + 50 len 14] / 1000 != mem[_10143 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10143 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) < 1000 * mem[_10143 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) and mem[_10143 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                            revert with 'NH{q', 17
                                        if not mem[_10143 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) * mem[_10143 + 18 len 14] / mem[_10143 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10143 + 50 len 14] and 1000 > -1 / mem[_10143 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10143 + 50 len 14] / 1000 != mem[_10143 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10143 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) < 1000 * mem[_10143 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686) * mem[_10143 + 18 len 14] / (1000 * mem[_10143 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8966)) + (997 * _8686))
                                else:
                                    if 997 * _8686 and mem[_8822 + 18 len 14] > -1 / 997 * _8686:
                                        revert with 'NH{q', 17
                                    if not mem[_8822 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8686 * mem[_8822 + 18 len 14] / mem[_8822 + 18 len 14] != 997 * _8686:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_8822 + 50 len 14] and 1000 > -1 / mem[_8822 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8822 + 50 len 14] / 1000 != mem[_8822 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8822 + 50 len 14] > (-997 * _8686) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8822 + 50 len 14]) + (997 * _8686) < 1000 * mem[_8822 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8822 + 50 len 14]) + (997 * _8686):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10498 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10498] == mem[_10498 + 18 len 14]
                                    require mem[_10498 + 32] == mem[_10498 + 50 len 14]
                                    require mem[_10498 + 64] == mem[_10498 + 92 len 4]
                                    if 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10498 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10498 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) and 997 > -1 / 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) / 997 != 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10498 + 18 len 14]:
                                        if mem[_10498 + 50 len 14] and 1000 > -1 / mem[_10498 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10498 + 50 len 14] / 1000 != mem[_10498 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10498 + 50 len 14] > (-997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) < 1000 * mem[_10498 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686))
                                    else:
                                        if 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) and mem[_10498 + 18 len 14] > -1 / 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                            revert with 'NH{q', 17
                                        if not mem[_10498 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) * mem[_10498 + 18 len 14] / mem[_10498 + 18 len 14] != 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10498 + 50 len 14] and 1000 > -1 / mem[_10498 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10498 + 50 len 14] / 1000 != mem[_10498 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10498 + 50 len 14] > (-997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)) < 1000 * mem[_10498 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686) * mem[_10498 + 18 len 14] / (1000 * mem[_10498 + 50 len 14]) + (997 * 997 * _8686 * Mask(112, 0, _8882) / (1000 * Mask(112, 0, _8966)) + (997 * _8686))
                        else:
                            if 997 * _7366 and mem[_7410 + 50 len 14] > -1 / 997 * _7366:
                                revert with 'NH{q', 17
                            if not mem[_7410 + 50 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7366 * mem[_7410 + 50 len 14] / mem[_7410 + 50 len 14] != 997 * _7366:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7410 + 18 len 14] and 1000 > -1 / mem[_7410 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7410 + 18 len 14] / 1000 != mem[_7410 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7410 + 18 len 14] > (-997 * _7366) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7410 + 18 len 14]) + (997 * _7366) < 1000 * mem[_7410 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7410 + 18 len 14]) + (997 * _7366):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7366 * mem[_7410 + 50 len 14] / (1000 * mem[_7410 + 18 len 14]) + (997 * _7366)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7858 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7894 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _7922 = mem[_7894]
                            require mem[_7894] == mem[_7894 + 18 len 14]
                            _7950 = mem[_7894 + 32]
                            require mem[_7894 + 32] == mem[_7894 + 50 len 14]
                            require mem[_7894 + 64] == mem[_7894 + 92 len 4]
                            if _7858 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_7894 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_7894 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7858 and 997 > -1 / _7858:
                                revert with 'NH{q', 17
                            if 997 * _7858 / 997 != _7858:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_7894 + 18 len 14]:
                                if mem[_7894 + 50 len 14] and 1000 > -1 / mem[_7894 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7894 + 50 len 14] / 1000 != mem[_7894 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7894 + 50 len 14] > (-997 * _7858) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7894 + 50 len 14]) + (997 * _7858) < 1000 * mem[_7894 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7894 + 50 len 14]) + (997 * _7858):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_7894 + 50 len 14]) + (997 * _7858)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _7950)) + (997 * _7858))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8668 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8687 = mem[_8668]
                                require mem[_8668] == mem[_8668]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8823 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _8883 = mem[_8823]
                                require mem[_8823] == mem[_8823 + 18 len 14]
                                _8967 = mem[_8823 + 32]
                                require mem[_8823 + 32] == mem[_8823 + 50 len 14]
                                require mem[_8823 + 64] == mem[_8823 + 92 len 4]
                                if _8687 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8823 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_8823 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8687 and 997 > -1 / _8687:
                                    revert with 'NH{q', 17
                                if 997 * _8687 / 997 != _8687:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_8823 + 18 len 14]:
                                    if mem[_8823 + 50 len 14] and 1000 > -1 / mem[_8823 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8823 + 50 len 14] / 1000 != mem[_8823 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8823 + 50 len 14] > (-997 * _8687) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8823 + 50 len 14]) + (997 * _8687) < 1000 * mem[_8823 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8823 + 50 len 14]) + (997 * _8687):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10145 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10145] == mem[_10145 + 18 len 14]
                                    require mem[_10145 + 32] == mem[_10145 + 50 len 14]
                                    require mem[_10145 + 64] == mem[_10145 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10145 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10145 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) / 997 != 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10145 + 18 len 14]:
                                        if mem[_10145 + 50 len 14] and 1000 > -1 / mem[_10145 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10145 + 50 len 14] / 1000 != mem[_10145 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10145 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) < 1000 * mem[_10145 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) and mem[_10145 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                            revert with 'NH{q', 17
                                        if not mem[_10145 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) * mem[_10145 + 18 len 14] / mem[_10145 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10145 + 50 len 14] and 1000 > -1 / mem[_10145 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10145 + 50 len 14] / 1000 != mem[_10145 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10145 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) < 1000 * mem[_10145 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687) * mem[_10145 + 18 len 14] / (1000 * mem[_10145 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8967)) + (997 * _8687))
                                else:
                                    if 997 * _8687 and mem[_8823 + 18 len 14] > -1 / 997 * _8687:
                                        revert with 'NH{q', 17
                                    if not mem[_8823 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8687 * mem[_8823 + 18 len 14] / mem[_8823 + 18 len 14] != 997 * _8687:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_8823 + 50 len 14] and 1000 > -1 / mem[_8823 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8823 + 50 len 14] / 1000 != mem[_8823 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8823 + 50 len 14] > (-997 * _8687) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8823 + 50 len 14]) + (997 * _8687) < 1000 * mem[_8823 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8823 + 50 len 14]) + (997 * _8687):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10499 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10499] == mem[_10499 + 18 len 14]
                                    require mem[_10499 + 32] == mem[_10499 + 50 len 14]
                                    require mem[_10499 + 64] == mem[_10499 + 92 len 4]
                                    if 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10499 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10499 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) and 997 > -1 / 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) / 997 != 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10499 + 18 len 14]:
                                        if mem[_10499 + 50 len 14] and 1000 > -1 / mem[_10499 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10499 + 50 len 14] / 1000 != mem[_10499 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10499 + 50 len 14] > (-997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) < 1000 * mem[_10499 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687))
                                    else:
                                        if 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) and mem[_10499 + 18 len 14] > -1 / 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                            revert with 'NH{q', 17
                                        if not mem[_10499 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) * mem[_10499 + 18 len 14] / mem[_10499 + 18 len 14] != 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10499 + 50 len 14] and 1000 > -1 / mem[_10499 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10499 + 50 len 14] / 1000 != mem[_10499 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10499 + 50 len 14] > (-997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)) < 1000 * mem[_10499 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687) * mem[_10499 + 18 len 14] / (1000 * mem[_10499 + 50 len 14]) + (997 * 997 * _8687 * Mask(112, 0, _8883) / (1000 * Mask(112, 0, _8967)) + (997 * _8687))
                            else:
                                if 997 * _7858 and mem[_7894 + 18 len 14] > -1 / 997 * _7858:
                                    revert with 'NH{q', 17
                                if not mem[_7894 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7858 * mem[_7894 + 18 len 14] / mem[_7894 + 18 len 14] != 997 * _7858:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_7894 + 50 len 14] and 1000 > -1 / mem[_7894 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7894 + 50 len 14] / 1000 != mem[_7894 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7894 + 50 len 14] > (-997 * _7858) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7894 + 50 len 14]) + (997 * _7858) < 1000 * mem[_7894 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7894 + 50 len 14]) + (997 * _7858):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7858 * mem[_7894 + 18 len 14] / (1000 * mem[_7894 + 50 len 14]) + (997 * _7858)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7858 * Mask(112, 0, _7922) / (1000 * Mask(112, 0, _7950)) + (997 * _7858))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8884 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8922 = mem[_8884]
                                require mem[_8884] == mem[_8884]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9062 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9126 = mem[_9062]
                                require mem[_9062] == mem[_9062 + 18 len 14]
                                _9194 = mem[_9062 + 32]
                                require mem[_9062 + 32] == mem[_9062 + 50 len 14]
                                require mem[_9062 + 64] == mem[_9062 + 92 len 4]
                                if _8922 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9062 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9062 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8922 and 997 > -1 / _8922:
                                    revert with 'NH{q', 17
                                if 997 * _8922 / 997 != _8922:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9062 + 18 len 14]:
                                    if mem[_9062 + 50 len 14] and 1000 > -1 / mem[_9062 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9062 + 50 len 14] / 1000 != mem[_9062 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9062 + 50 len 14] > (-997 * _8922) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9062 + 50 len 14]) + (997 * _8922) < 1000 * mem[_9062 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9062 + 50 len 14]) + (997 * _8922):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10500 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10500] == mem[_10500 + 18 len 14]
                                    require mem[_10500 + 32] == mem[_10500 + 50 len 14]
                                    require mem[_10500 + 64] == mem[_10500 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10500 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10500 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) / 997 != 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10500 + 18 len 14]:
                                        if mem[_10500 + 50 len 14] and 1000 > -1 / mem[_10500 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10500 + 50 len 14] / 1000 != mem[_10500 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10500 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) < 1000 * mem[_10500 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) and mem[_10500 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                            revert with 'NH{q', 17
                                        if not mem[_10500 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) * mem[_10500 + 18 len 14] / mem[_10500 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10500 + 50 len 14] and 1000 > -1 / mem[_10500 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10500 + 50 len 14] / 1000 != mem[_10500 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10500 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) < 1000 * mem[_10500 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922) * mem[_10500 + 18 len 14] / (1000 * mem[_10500 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9194)) + (997 * _8922))
                                else:
                                    if 997 * _8922 and mem[_9062 + 18 len 14] > -1 / 997 * _8922:
                                        revert with 'NH{q', 17
                                    if not mem[_9062 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8922 * mem[_9062 + 18 len 14] / mem[_9062 + 18 len 14] != 997 * _8922:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9062 + 50 len 14] and 1000 > -1 / mem[_9062 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9062 + 50 len 14] / 1000 != mem[_9062 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9062 + 50 len 14] > (-997 * _8922) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9062 + 50 len 14]) + (997 * _8922) < 1000 * mem[_9062 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9062 + 50 len 14]) + (997 * _8922):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10938 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10938] == mem[_10938 + 18 len 14]
                                    require mem[_10938 + 32] == mem[_10938 + 50 len 14]
                                    require mem[_10938 + 64] == mem[_10938 + 92 len 4]
                                    if 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10938 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10938 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) and 997 > -1 / 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) / 997 != 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10938 + 18 len 14]:
                                        if mem[_10938 + 50 len 14] and 1000 > -1 / mem[_10938 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10938 + 50 len 14] / 1000 != mem[_10938 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10938 + 50 len 14] > (-997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) < 1000 * mem[_10938 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922))
                                    else:
                                        if 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) and mem[_10938 + 18 len 14] > -1 / 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                            revert with 'NH{q', 17
                                        if not mem[_10938 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) * mem[_10938 + 18 len 14] / mem[_10938 + 18 len 14] != 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10938 + 50 len 14] and 1000 > -1 / mem[_10938 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10938 + 50 len 14] / 1000 != mem[_10938 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10938 + 50 len 14] > (-997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)) < 1000 * mem[_10938 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922) * mem[_10938 + 18 len 14] / (1000 * mem[_10938 + 50 len 14]) + (997 * 997 * _8922 * Mask(112, 0, _9126) / (1000 * Mask(112, 0, _9194)) + (997 * _8922))
                    else:
                        if 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) and mem[_7182 + 50 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                            revert with 'NH{q', 17
                        if not mem[_7182 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * mem[_7182 + 50 len 14] / mem[_7182 + 50 len 14] != 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7182 + 18 len 14] and 1000 > -1 / mem[_7182 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7182 + 18 len 14] / 1000 != mem[_7182 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7182 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) < 1000 * mem[_7182 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * mem[_7182 + 50 len 14] / (1000 * mem[_7182 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063))
                        require ext_code.size(stor6)
                        staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * Mask(112, 0, _7198) / (1000 * Mask(112, 0, _7190)) + (997 * 0 / (1000 * Mask(112, 0, _7086)) + (997 * _7063)))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7427 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7439 = mem[_7427]
                        require mem[_7427] == mem[_7427]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7482 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_7482] == mem[_7482 + 18 len 14]
                        require mem[_7482 + 32] == mem[_7482 + 50 len 14]
                        require mem[_7482 + 64] == mem[_7482 + 92 len 4]
                        if _7439 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7482 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7482 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7439 and 997 > -1 / _7439:
                            revert with 'NH{q', 17
                        if 997 * _7439 / 997 != _7439:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7482 + 50 len 14]:
                            if mem[_7482 + 18 len 14] and 1000 > -1 / mem[_7482 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7482 + 18 len 14] / 1000 != mem[_7482 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7482 + 18 len 14] > (-997 * _7439) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7482 + 18 len 14]) + (997 * _7439) < 1000 * mem[_7482 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7482 + 18 len 14]) + (997 * _7439):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7482 + 18 len 14]) + (997 * _7439)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7859 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7895 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _7923 = mem[_7895]
                            require mem[_7895] == mem[_7895 + 18 len 14]
                            _7951 = mem[_7895 + 32]
                            require mem[_7895 + 32] == mem[_7895 + 50 len 14]
                            require mem[_7895 + 64] == mem[_7895 + 92 len 4]
                            if _7859 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_7895 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_7895 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7859 and 997 > -1 / _7859:
                                revert with 'NH{q', 17
                            if 997 * _7859 / 997 != _7859:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_7895 + 18 len 14]:
                                if mem[_7895 + 50 len 14] and 1000 > -1 / mem[_7895 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7895 + 50 len 14] / 1000 != mem[_7895 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7895 + 50 len 14] > (-997 * _7859) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7895 + 50 len 14]) + (997 * _7859) < 1000 * mem[_7895 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7895 + 50 len 14]) + (997 * _7859):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_7895 + 50 len 14]) + (997 * _7859)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _7951)) + (997 * _7859))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8669 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8688 = mem[_8669]
                                require mem[_8669] == mem[_8669]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8824 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _8885 = mem[_8824]
                                require mem[_8824] == mem[_8824 + 18 len 14]
                                _8968 = mem[_8824 + 32]
                                require mem[_8824 + 32] == mem[_8824 + 50 len 14]
                                require mem[_8824 + 64] == mem[_8824 + 92 len 4]
                                if _8688 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8824 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_8824 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8688 and 997 > -1 / _8688:
                                    revert with 'NH{q', 17
                                if 997 * _8688 / 997 != _8688:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_8824 + 18 len 14]:
                                    if mem[_8824 + 50 len 14] and 1000 > -1 / mem[_8824 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8824 + 50 len 14] / 1000 != mem[_8824 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8824 + 50 len 14] > (-997 * _8688) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8824 + 50 len 14]) + (997 * _8688) < 1000 * mem[_8824 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8824 + 50 len 14]) + (997 * _8688):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10148 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10148] == mem[_10148 + 18 len 14]
                                    require mem[_10148 + 32] == mem[_10148 + 50 len 14]
                                    require mem[_10148 + 64] == mem[_10148 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10148 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10148 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) / 997 != 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10148 + 18 len 14]:
                                        if mem[_10148 + 50 len 14] and 1000 > -1 / mem[_10148 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10148 + 50 len 14] / 1000 != mem[_10148 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10148 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) < 1000 * mem[_10148 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) and mem[_10148 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                            revert with 'NH{q', 17
                                        if not mem[_10148 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) * mem[_10148 + 18 len 14] / mem[_10148 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10148 + 50 len 14] and 1000 > -1 / mem[_10148 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10148 + 50 len 14] / 1000 != mem[_10148 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10148 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) < 1000 * mem[_10148 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688) * mem[_10148 + 18 len 14] / (1000 * mem[_10148 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8968)) + (997 * _8688))
                                else:
                                    if 997 * _8688 and mem[_8824 + 18 len 14] > -1 / 997 * _8688:
                                        revert with 'NH{q', 17
                                    if not mem[_8824 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8688 * mem[_8824 + 18 len 14] / mem[_8824 + 18 len 14] != 997 * _8688:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_8824 + 50 len 14] and 1000 > -1 / mem[_8824 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8824 + 50 len 14] / 1000 != mem[_8824 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8824 + 50 len 14] > (-997 * _8688) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8824 + 50 len 14]) + (997 * _8688) < 1000 * mem[_8824 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8824 + 50 len 14]) + (997 * _8688):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10502 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10502] == mem[_10502 + 18 len 14]
                                    require mem[_10502 + 32] == mem[_10502 + 50 len 14]
                                    require mem[_10502 + 64] == mem[_10502 + 92 len 4]
                                    if 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10502 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10502 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) and 997 > -1 / 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) / 997 != 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10502 + 18 len 14]:
                                        if mem[_10502 + 50 len 14] and 1000 > -1 / mem[_10502 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10502 + 50 len 14] / 1000 != mem[_10502 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10502 + 50 len 14] > (-997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) < 1000 * mem[_10502 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688))
                                    else:
                                        if 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) and mem[_10502 + 18 len 14] > -1 / 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                            revert with 'NH{q', 17
                                        if not mem[_10502 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) * mem[_10502 + 18 len 14] / mem[_10502 + 18 len 14] != 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10502 + 50 len 14] and 1000 > -1 / mem[_10502 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10502 + 50 len 14] / 1000 != mem[_10502 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10502 + 50 len 14] > (-997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)) < 1000 * mem[_10502 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688) * mem[_10502 + 18 len 14] / (1000 * mem[_10502 + 50 len 14]) + (997 * 997 * _8688 * Mask(112, 0, _8885) / (1000 * Mask(112, 0, _8968)) + (997 * _8688))
                            else:
                                if 997 * _7859 and mem[_7895 + 18 len 14] > -1 / 997 * _7859:
                                    revert with 'NH{q', 17
                                if not mem[_7895 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7859 * mem[_7895 + 18 len 14] / mem[_7895 + 18 len 14] != 997 * _7859:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_7895 + 50 len 14] and 1000 > -1 / mem[_7895 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7895 + 50 len 14] / 1000 != mem[_7895 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7895 + 50 len 14] > (-997 * _7859) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7895 + 50 len 14]) + (997 * _7859) < 1000 * mem[_7895 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7895 + 50 len 14]) + (997 * _7859):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7859 * mem[_7895 + 18 len 14] / (1000 * mem[_7895 + 50 len 14]) + (997 * _7859)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7859 * Mask(112, 0, _7923) / (1000 * Mask(112, 0, _7951)) + (997 * _7859))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8886 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8923 = mem[_8886]
                                require mem[_8886] == mem[_8886]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9063 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9127 = mem[_9063]
                                require mem[_9063] == mem[_9063 + 18 len 14]
                                _9195 = mem[_9063 + 32]
                                require mem[_9063 + 32] == mem[_9063 + 50 len 14]
                                require mem[_9063 + 64] == mem[_9063 + 92 len 4]
                                if _8923 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9063 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9063 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8923 and 997 > -1 / _8923:
                                    revert with 'NH{q', 17
                                if 997 * _8923 / 997 != _8923:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9063 + 18 len 14]:
                                    if mem[_9063 + 50 len 14] and 1000 > -1 / mem[_9063 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9063 + 50 len 14] / 1000 != mem[_9063 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9063 + 50 len 14] > (-997 * _8923) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9063 + 50 len 14]) + (997 * _8923) < 1000 * mem[_9063 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9063 + 50 len 14]) + (997 * _8923):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10503 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10503] == mem[_10503 + 18 len 14]
                                    require mem[_10503 + 32] == mem[_10503 + 50 len 14]
                                    require mem[_10503 + 64] == mem[_10503 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10503 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10503 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) / 997 != 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10503 + 18 len 14]:
                                        if mem[_10503 + 50 len 14] and 1000 > -1 / mem[_10503 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10503 + 50 len 14] / 1000 != mem[_10503 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10503 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) < 1000 * mem[_10503 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) and mem[_10503 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                            revert with 'NH{q', 17
                                        if not mem[_10503 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) * mem[_10503 + 18 len 14] / mem[_10503 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10503 + 50 len 14] and 1000 > -1 / mem[_10503 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10503 + 50 len 14] / 1000 != mem[_10503 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10503 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) < 1000 * mem[_10503 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923) * mem[_10503 + 18 len 14] / (1000 * mem[_10503 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9195)) + (997 * _8923))
                                else:
                                    if 997 * _8923 and mem[_9063 + 18 len 14] > -1 / 997 * _8923:
                                        revert with 'NH{q', 17
                                    if not mem[_9063 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8923 * mem[_9063 + 18 len 14] / mem[_9063 + 18 len 14] != 997 * _8923:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9063 + 50 len 14] and 1000 > -1 / mem[_9063 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9063 + 50 len 14] / 1000 != mem[_9063 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9063 + 50 len 14] > (-997 * _8923) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9063 + 50 len 14]) + (997 * _8923) < 1000 * mem[_9063 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9063 + 50 len 14]) + (997 * _8923):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10939 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10939] == mem[_10939 + 18 len 14]
                                    require mem[_10939 + 32] == mem[_10939 + 50 len 14]
                                    require mem[_10939 + 64] == mem[_10939 + 92 len 4]
                                    if 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10939 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10939 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) and 997 > -1 / 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) / 997 != 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10939 + 18 len 14]:
                                        if mem[_10939 + 50 len 14] and 1000 > -1 / mem[_10939 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10939 + 50 len 14] / 1000 != mem[_10939 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10939 + 50 len 14] > (-997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) < 1000 * mem[_10939 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923))
                                    else:
                                        if 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) and mem[_10939 + 18 len 14] > -1 / 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                            revert with 'NH{q', 17
                                        if not mem[_10939 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) * mem[_10939 + 18 len 14] / mem[_10939 + 18 len 14] != 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10939 + 50 len 14] and 1000 > -1 / mem[_10939 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10939 + 50 len 14] / 1000 != mem[_10939 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10939 + 50 len 14] > (-997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)) < 1000 * mem[_10939 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923) * mem[_10939 + 18 len 14] / (1000 * mem[_10939 + 50 len 14]) + (997 * 997 * _8923 * Mask(112, 0, _9127) / (1000 * Mask(112, 0, _9195)) + (997 * _8923))
                        else:
                            if 997 * _7439 and mem[_7482 + 50 len 14] > -1 / 997 * _7439:
                                revert with 'NH{q', 17
                            if not mem[_7482 + 50 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7439 * mem[_7482 + 50 len 14] / mem[_7482 + 50 len 14] != 997 * _7439:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7482 + 18 len 14] and 1000 > -1 / mem[_7482 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7482 + 18 len 14] / 1000 != mem[_7482 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7482 + 18 len 14] > (-997 * _7439) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7482 + 18 len 14]) + (997 * _7439) < 1000 * mem[_7482 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7482 + 18 len 14]) + (997 * _7439):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7439 * mem[_7482 + 50 len 14] / (1000 * mem[_7482 + 18 len 14]) + (997 * _7439)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7994 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8038 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8070 = mem[_8038]
                            require mem[_8038] == mem[_8038 + 18 len 14]
                            _8094 = mem[_8038 + 32]
                            require mem[_8038 + 32] == mem[_8038 + 50 len 14]
                            require mem[_8038 + 64] == mem[_8038 + 92 len 4]
                            if _7994 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8038 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8038 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7994 and 997 > -1 / _7994:
                                revert with 'NH{q', 17
                            if 997 * _7994 / 997 != _7994:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8038 + 18 len 14]:
                                if mem[_8038 + 50 len 14] and 1000 > -1 / mem[_8038 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8038 + 50 len 14] / 1000 != mem[_8038 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8038 + 50 len 14] > (-997 * _7994) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8038 + 50 len 14]) + (997 * _7994) < 1000 * mem[_8038 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8038 + 50 len 14]) + (997 * _7994):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_8038 + 50 len 14]) + (997 * _7994)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _8094)) + (997 * _7994))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8887 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8924 = mem[_8887]
                                require mem[_8887] == mem[_8887]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9064 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9128 = mem[_9064]
                                require mem[_9064] == mem[_9064 + 18 len 14]
                                _9196 = mem[_9064 + 32]
                                require mem[_9064 + 32] == mem[_9064 + 50 len 14]
                                require mem[_9064 + 64] == mem[_9064 + 92 len 4]
                                if _8924 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9064 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9064 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8924 and 997 > -1 / _8924:
                                    revert with 'NH{q', 17
                                if 997 * _8924 / 997 != _8924:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9064 + 18 len 14]:
                                    if mem[_9064 + 50 len 14] and 1000 > -1 / mem[_9064 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9064 + 50 len 14] / 1000 != mem[_9064 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9064 + 50 len 14] > (-997 * _8924) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9064 + 50 len 14]) + (997 * _8924) < 1000 * mem[_9064 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9064 + 50 len 14]) + (997 * _8924):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10505 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10505] == mem[_10505 + 18 len 14]
                                    require mem[_10505 + 32] == mem[_10505 + 50 len 14]
                                    require mem[_10505 + 64] == mem[_10505 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10505 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10505 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) / 997 != 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10505 + 18 len 14]:
                                        if mem[_10505 + 50 len 14] and 1000 > -1 / mem[_10505 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10505 + 50 len 14] / 1000 != mem[_10505 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10505 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) < 1000 * mem[_10505 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) and mem[_10505 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                            revert with 'NH{q', 17
                                        if not mem[_10505 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) * mem[_10505 + 18 len 14] / mem[_10505 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10505 + 50 len 14] and 1000 > -1 / mem[_10505 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10505 + 50 len 14] / 1000 != mem[_10505 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10505 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) < 1000 * mem[_10505 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924) * mem[_10505 + 18 len 14] / (1000 * mem[_10505 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9196)) + (997 * _8924))
                                else:
                                    if 997 * _8924 and mem[_9064 + 18 len 14] > -1 / 997 * _8924:
                                        revert with 'NH{q', 17
                                    if not mem[_9064 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8924 * mem[_9064 + 18 len 14] / mem[_9064 + 18 len 14] != 997 * _8924:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9064 + 50 len 14] and 1000 > -1 / mem[_9064 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9064 + 50 len 14] / 1000 != mem[_9064 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9064 + 50 len 14] > (-997 * _8924) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9064 + 50 len 14]) + (997 * _8924) < 1000 * mem[_9064 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9064 + 50 len 14]) + (997 * _8924):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10940 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10940] == mem[_10940 + 18 len 14]
                                    require mem[_10940 + 32] == mem[_10940 + 50 len 14]
                                    require mem[_10940 + 64] == mem[_10940 + 92 len 4]
                                    if 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10940 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10940 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) and 997 > -1 / 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) / 997 != 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10940 + 18 len 14]:
                                        if mem[_10940 + 50 len 14] and 1000 > -1 / mem[_10940 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10940 + 50 len 14] / 1000 != mem[_10940 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10940 + 50 len 14] > (-997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) < 1000 * mem[_10940 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924))
                                    else:
                                        if 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) and mem[_10940 + 18 len 14] > -1 / 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                            revert with 'NH{q', 17
                                        if not mem[_10940 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) * mem[_10940 + 18 len 14] / mem[_10940 + 18 len 14] != 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10940 + 50 len 14] and 1000 > -1 / mem[_10940 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10940 + 50 len 14] / 1000 != mem[_10940 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10940 + 50 len 14] > (-997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)) < 1000 * mem[_10940 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924) * mem[_10940 + 18 len 14] / (1000 * mem[_10940 + 50 len 14]) + (997 * 997 * _8924 * Mask(112, 0, _9128) / (1000 * Mask(112, 0, _9196)) + (997 * _8924))
                            else:
                                if 997 * _7994 and mem[_8038 + 18 len 14] > -1 / 997 * _7994:
                                    revert with 'NH{q', 17
                                if not mem[_8038 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7994 * mem[_8038 + 18 len 14] / mem[_8038 + 18 len 14] != 997 * _7994:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8038 + 50 len 14] and 1000 > -1 / mem[_8038 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8038 + 50 len 14] / 1000 != mem[_8038 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8038 + 50 len 14] > (-997 * _7994) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8038 + 50 len 14]) + (997 * _7994) < 1000 * mem[_8038 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8038 + 50 len 14]) + (997 * _7994):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7994 * mem[_8038 + 18 len 14] / (1000 * mem[_8038 + 50 len 14]) + (997 * _7994)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7994 * Mask(112, 0, _8070) / (1000 * Mask(112, 0, _8094)) + (997 * _7994))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9129 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _9174 = mem[_9129]
                                require mem[_9129] == mem[_9129]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9302 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9366 = mem[_9302]
                                require mem[_9302] == mem[_9302 + 18 len 14]
                                _9426 = mem[_9302 + 32]
                                require mem[_9302 + 32] == mem[_9302 + 50 len 14]
                                require mem[_9302 + 64] == mem[_9302 + 92 len 4]
                                if _9174 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9302 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9302 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _9174 and 997 > -1 / _9174:
                                    revert with 'NH{q', 17
                                if 997 * _9174 / 997 != _9174:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9302 + 18 len 14]:
                                    if mem[_9302 + 50 len 14] and 1000 > -1 / mem[_9302 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9302 + 50 len 14] / 1000 != mem[_9302 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9302 + 50 len 14] > (-997 * _9174) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9302 + 50 len 14]) + (997 * _9174) < 1000 * mem[_9302 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9302 + 50 len 14]) + (997 * _9174):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10941 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10941] == mem[_10941 + 18 len 14]
                                    require mem[_10941 + 32] == mem[_10941 + 50 len 14]
                                    require mem[_10941 + 64] == mem[_10941 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10941 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10941 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) / 997 != 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10941 + 18 len 14]:
                                        if mem[_10941 + 50 len 14] and 1000 > -1 / mem[_10941 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10941 + 50 len 14] / 1000 != mem[_10941 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10941 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) < 1000 * mem[_10941 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) and mem[_10941 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                            revert with 'NH{q', 17
                                        if not mem[_10941 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) * mem[_10941 + 18 len 14] / mem[_10941 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10941 + 50 len 14] and 1000 > -1 / mem[_10941 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10941 + 50 len 14] / 1000 != mem[_10941 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10941 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) < 1000 * mem[_10941 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174) * mem[_10941 + 18 len 14] / (1000 * mem[_10941 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9426)) + (997 * _9174))
                                else:
                                    if 997 * _9174 and mem[_9302 + 18 len 14] > -1 / 997 * _9174:
                                        revert with 'NH{q', 17
                                    if not mem[_9302 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _9174 * mem[_9302 + 18 len 14] / mem[_9302 + 18 len 14] != 997 * _9174:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9302 + 50 len 14] and 1000 > -1 / mem[_9302 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9302 + 50 len 14] / 1000 != mem[_9302 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9302 + 50 len 14] > (-997 * _9174) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9302 + 50 len 14]) + (997 * _9174) < 1000 * mem[_9302 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9302 + 50 len 14]) + (997 * _9174):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11390 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11390] == mem[_11390 + 18 len 14]
                                    require mem[_11390 + 32] == mem[_11390 + 50 len 14]
                                    require mem[_11390 + 64] == mem[_11390 + 92 len 4]
                                    if 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11390 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11390 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) and 997 > -1 / 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) / 997 != 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11390 + 18 len 14]:
                                        if mem[_11390 + 50 len 14] and 1000 > -1 / mem[_11390 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11390 + 50 len 14] / 1000 != mem[_11390 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11390 + 50 len 14] > (-997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) < 1000 * mem[_11390 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174))
                                    else:
                                        if 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) and mem[_11390 + 18 len 14] > -1 / 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                            revert with 'NH{q', 17
                                        if not mem[_11390 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) * mem[_11390 + 18 len 14] / mem[_11390 + 18 len 14] != 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11390 + 50 len 14] and 1000 > -1 / mem[_11390 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11390 + 50 len 14] / 1000 != mem[_11390 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11390 + 50 len 14] > (-997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)) < 1000 * mem[_11390 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174) * mem[_11390 + 18 len 14] / (1000 * mem[_11390 + 50 len 14]) + (997 * 997 * _9174 * Mask(112, 0, _9366) / (1000 * Mask(112, 0, _9426)) + (997 * _9174))
                else:
                    if 997 * _7063 and mem[_7079 + 50 len 14] > -1 / 997 * _7063:
                        revert with 'NH{q', 17
                    if not mem[_7079 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * _7063 * mem[_7079 + 50 len 14] / mem[_7079 + 50 len 14] != 997 * _7063:
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7079 + 18 len 14] and 1000 > -1 / mem[_7079 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7079 + 18 len 14] / 1000 != mem[_7079 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7079 + 18 len 14] > (-997 * _7063) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7079 + 18 len 14]) + (997 * _7063) < 1000 * mem[_7079 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7079 + 18 len 14]) + (997 * _7063):
                        revert with 'NH{q', 18
                    require ext_code.size(stor14)
                    staticcall stor14.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7214 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7222 = mem[_7214]
                    require mem[_7214] == mem[_7214 + 18 len 14]
                    _7226 = mem[_7214 + 32]
                    require mem[_7214 + 32] == mem[_7214 + 50 len 14]
                    require mem[_7214 + 64] == mem[_7214 + 92 len 4]
                    if 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7214 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7214 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) and 997 > -1 / 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                        revert with 'NH{q', 17
                    if 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) / 997 != 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7214 + 50 len 14]:
                        if mem[_7214 + 18 len 14] and 1000 > -1 / mem[_7214 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7214 + 18 len 14] / 1000 != mem[_7214 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7214 + 18 len 14] > (-997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) < 1000 * mem[_7214 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063))
                        require ext_code.size(stor6)
                        staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7222)) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7428 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7440 = mem[_7428]
                        require mem[_7428] == mem[_7428]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7483 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_7483] == mem[_7483 + 18 len 14]
                        require mem[_7483 + 32] == mem[_7483 + 50 len 14]
                        require mem[_7483 + 64] == mem[_7483 + 92 len 4]
                        if _7440 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7483 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7483 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7440 and 997 > -1 / _7440:
                            revert with 'NH{q', 17
                        if 997 * _7440 / 997 != _7440:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7483 + 50 len 14]:
                            if mem[_7483 + 18 len 14] and 1000 > -1 / mem[_7483 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7483 + 18 len 14] / 1000 != mem[_7483 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7483 + 18 len 14] > (-997 * _7440) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7483 + 18 len 14]) + (997 * _7440) < 1000 * mem[_7483 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7483 + 18 len 14]) + (997 * _7440):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7483 + 18 len 14]) + (997 * _7440)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7860 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7897 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _7924 = mem[_7897]
                            require mem[_7897] == mem[_7897 + 18 len 14]
                            _7953 = mem[_7897 + 32]
                            require mem[_7897 + 32] == mem[_7897 + 50 len 14]
                            require mem[_7897 + 64] == mem[_7897 + 92 len 4]
                            if _7860 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_7897 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_7897 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7860 and 997 > -1 / _7860:
                                revert with 'NH{q', 17
                            if 997 * _7860 / 997 != _7860:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_7897 + 18 len 14]:
                                if mem[_7897 + 50 len 14] and 1000 > -1 / mem[_7897 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7897 + 50 len 14] / 1000 != mem[_7897 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7897 + 50 len 14] > (-997 * _7860) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7897 + 50 len 14]) + (997 * _7860) < 1000 * mem[_7897 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7897 + 50 len 14]) + (997 * _7860):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_7897 + 50 len 14]) + (997 * _7860)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _7953)) + (997 * _7860))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8670 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8690 = mem[_8670]
                                require mem[_8670] == mem[_8670]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8825 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _8888 = mem[_8825]
                                require mem[_8825] == mem[_8825 + 18 len 14]
                                _8970 = mem[_8825 + 32]
                                require mem[_8825 + 32] == mem[_8825 + 50 len 14]
                                require mem[_8825 + 64] == mem[_8825 + 92 len 4]
                                if _8690 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_8825 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_8825 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8690 and 997 > -1 / _8690:
                                    revert with 'NH{q', 17
                                if 997 * _8690 / 997 != _8690:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_8825 + 18 len 14]:
                                    if mem[_8825 + 50 len 14] and 1000 > -1 / mem[_8825 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8825 + 50 len 14] / 1000 != mem[_8825 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8825 + 50 len 14] > (-997 * _8690) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8825 + 50 len 14]) + (997 * _8690) < 1000 * mem[_8825 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8825 + 50 len 14]) + (997 * _8690):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10152 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10152] == mem[_10152 + 18 len 14]
                                    require mem[_10152 + 32] == mem[_10152 + 50 len 14]
                                    require mem[_10152 + 64] == mem[_10152 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10152 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10152 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) / 997 != 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10152 + 18 len 14]:
                                        if mem[_10152 + 50 len 14] and 1000 > -1 / mem[_10152 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10152 + 50 len 14] / 1000 != mem[_10152 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10152 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) < 1000 * mem[_10152 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) and mem[_10152 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                            revert with 'NH{q', 17
                                        if not mem[_10152 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) * mem[_10152 + 18 len 14] / mem[_10152 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10152 + 50 len 14] and 1000 > -1 / mem[_10152 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10152 + 50 len 14] / 1000 != mem[_10152 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10152 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) < 1000 * mem[_10152 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690) * mem[_10152 + 18 len 14] / (1000 * mem[_10152 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8970)) + (997 * _8690))
                                else:
                                    if 997 * _8690 and mem[_8825 + 18 len 14] > -1 / 997 * _8690:
                                        revert with 'NH{q', 17
                                    if not mem[_8825 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8690 * mem[_8825 + 18 len 14] / mem[_8825 + 18 len 14] != 997 * _8690:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_8825 + 50 len 14] and 1000 > -1 / mem[_8825 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_8825 + 50 len 14] / 1000 != mem[_8825 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_8825 + 50 len 14] > (-997 * _8690) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_8825 + 50 len 14]) + (997 * _8690) < 1000 * mem[_8825 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_8825 + 50 len 14]) + (997 * _8690):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10508 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10508] == mem[_10508 + 18 len 14]
                                    require mem[_10508 + 32] == mem[_10508 + 50 len 14]
                                    require mem[_10508 + 64] == mem[_10508 + 92 len 4]
                                    if 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10508 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10508 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) and 997 > -1 / 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) / 997 != 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10508 + 18 len 14]:
                                        if mem[_10508 + 50 len 14] and 1000 > -1 / mem[_10508 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10508 + 50 len 14] / 1000 != mem[_10508 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10508 + 50 len 14] > (-997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) < 1000 * mem[_10508 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690))
                                    else:
                                        if 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) and mem[_10508 + 18 len 14] > -1 / 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                            revert with 'NH{q', 17
                                        if not mem[_10508 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) * mem[_10508 + 18 len 14] / mem[_10508 + 18 len 14] != 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10508 + 50 len 14] and 1000 > -1 / mem[_10508 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10508 + 50 len 14] / 1000 != mem[_10508 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10508 + 50 len 14] > (-997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)) < 1000 * mem[_10508 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690) * mem[_10508 + 18 len 14] / (1000 * mem[_10508 + 50 len 14]) + (997 * 997 * _8690 * Mask(112, 0, _8888) / (1000 * Mask(112, 0, _8970)) + (997 * _8690))
                            else:
                                if 997 * _7860 and mem[_7897 + 18 len 14] > -1 / 997 * _7860:
                                    revert with 'NH{q', 17
                                if not mem[_7897 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7860 * mem[_7897 + 18 len 14] / mem[_7897 + 18 len 14] != 997 * _7860:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_7897 + 50 len 14] and 1000 > -1 / mem[_7897 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_7897 + 50 len 14] / 1000 != mem[_7897 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_7897 + 50 len 14] > (-997 * _7860) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_7897 + 50 len 14]) + (997 * _7860) < 1000 * mem[_7897 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_7897 + 50 len 14]) + (997 * _7860):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7860 * mem[_7897 + 18 len 14] / (1000 * mem[_7897 + 50 len 14]) + (997 * _7860)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7860 * Mask(112, 0, _7924) / (1000 * Mask(112, 0, _7953)) + (997 * _7860))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8889 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8925 = mem[_8889]
                                require mem[_8889] == mem[_8889]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9065 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9130 = mem[_9065]
                                require mem[_9065] == mem[_9065 + 18 len 14]
                                _9197 = mem[_9065 + 32]
                                require mem[_9065 + 32] == mem[_9065 + 50 len 14]
                                require mem[_9065 + 64] == mem[_9065 + 92 len 4]
                                if _8925 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9065 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9065 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8925 and 997 > -1 / _8925:
                                    revert with 'NH{q', 17
                                if 997 * _8925 / 997 != _8925:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9065 + 18 len 14]:
                                    if mem[_9065 + 50 len 14] and 1000 > -1 / mem[_9065 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9065 + 50 len 14] / 1000 != mem[_9065 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9065 + 50 len 14] > (-997 * _8925) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9065 + 50 len 14]) + (997 * _8925) < 1000 * mem[_9065 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9065 + 50 len 14]) + (997 * _8925):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10509 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10509] == mem[_10509 + 18 len 14]
                                    require mem[_10509 + 32] == mem[_10509 + 50 len 14]
                                    require mem[_10509 + 64] == mem[_10509 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10509 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10509 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) / 997 != 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10509 + 18 len 14]:
                                        if mem[_10509 + 50 len 14] and 1000 > -1 / mem[_10509 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10509 + 50 len 14] / 1000 != mem[_10509 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10509 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) < 1000 * mem[_10509 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) and mem[_10509 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                            revert with 'NH{q', 17
                                        if not mem[_10509 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) * mem[_10509 + 18 len 14] / mem[_10509 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10509 + 50 len 14] and 1000 > -1 / mem[_10509 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10509 + 50 len 14] / 1000 != mem[_10509 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10509 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) < 1000 * mem[_10509 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925) * mem[_10509 + 18 len 14] / (1000 * mem[_10509 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9197)) + (997 * _8925))
                                else:
                                    if 997 * _8925 and mem[_9065 + 18 len 14] > -1 / 997 * _8925:
                                        revert with 'NH{q', 17
                                    if not mem[_9065 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8925 * mem[_9065 + 18 len 14] / mem[_9065 + 18 len 14] != 997 * _8925:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9065 + 50 len 14] and 1000 > -1 / mem[_9065 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9065 + 50 len 14] / 1000 != mem[_9065 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9065 + 50 len 14] > (-997 * _8925) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9065 + 50 len 14]) + (997 * _8925) < 1000 * mem[_9065 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9065 + 50 len 14]) + (997 * _8925):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10943 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10943] == mem[_10943 + 18 len 14]
                                    require mem[_10943 + 32] == mem[_10943 + 50 len 14]
                                    require mem[_10943 + 64] == mem[_10943 + 92 len 4]
                                    if 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10943 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10943 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) and 997 > -1 / 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) / 997 != 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10943 + 18 len 14]:
                                        if mem[_10943 + 50 len 14] and 1000 > -1 / mem[_10943 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10943 + 50 len 14] / 1000 != mem[_10943 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10943 + 50 len 14] > (-997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) < 1000 * mem[_10943 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925))
                                    else:
                                        if 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) and mem[_10943 + 18 len 14] > -1 / 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                            revert with 'NH{q', 17
                                        if not mem[_10943 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) * mem[_10943 + 18 len 14] / mem[_10943 + 18 len 14] != 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10943 + 50 len 14] and 1000 > -1 / mem[_10943 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10943 + 50 len 14] / 1000 != mem[_10943 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10943 + 50 len 14] > (-997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)) < 1000 * mem[_10943 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925) * mem[_10943 + 18 len 14] / (1000 * mem[_10943 + 50 len 14]) + (997 * 997 * _8925 * Mask(112, 0, _9130) / (1000 * Mask(112, 0, _9197)) + (997 * _8925))
                        else:
                            if 997 * _7440 and mem[_7483 + 50 len 14] > -1 / 997 * _7440:
                                revert with 'NH{q', 17
                            if not mem[_7483 + 50 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7440 * mem[_7483 + 50 len 14] / mem[_7483 + 50 len 14] != 997 * _7440:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7483 + 18 len 14] and 1000 > -1 / mem[_7483 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7483 + 18 len 14] / 1000 != mem[_7483 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7483 + 18 len 14] > (-997 * _7440) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7483 + 18 len 14]) + (997 * _7440) < 1000 * mem[_7483 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7483 + 18 len 14]) + (997 * _7440):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7440 * mem[_7483 + 50 len 14] / (1000 * mem[_7483 + 18 len 14]) + (997 * _7440)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7995 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8039 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8071 = mem[_8039]
                            require mem[_8039] == mem[_8039 + 18 len 14]
                            _8095 = mem[_8039 + 32]
                            require mem[_8039 + 32] == mem[_8039 + 50 len 14]
                            require mem[_8039 + 64] == mem[_8039 + 92 len 4]
                            if _7995 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8039 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8039 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7995 and 997 > -1 / _7995:
                                revert with 'NH{q', 17
                            if 997 * _7995 / 997 != _7995:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8039 + 18 len 14]:
                                if mem[_8039 + 50 len 14] and 1000 > -1 / mem[_8039 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8039 + 50 len 14] / 1000 != mem[_8039 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8039 + 50 len 14] > (-997 * _7995) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8039 + 50 len 14]) + (997 * _7995) < 1000 * mem[_8039 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8039 + 50 len 14]) + (997 * _7995):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_8039 + 50 len 14]) + (997 * _7995)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _8095)) + (997 * _7995))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8890 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8926 = mem[_8890]
                                require mem[_8890] == mem[_8890]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9066 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9131 = mem[_9066]
                                require mem[_9066] == mem[_9066 + 18 len 14]
                                _9198 = mem[_9066 + 32]
                                require mem[_9066 + 32] == mem[_9066 + 50 len 14]
                                require mem[_9066 + 64] == mem[_9066 + 92 len 4]
                                if _8926 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9066 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9066 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8926 and 997 > -1 / _8926:
                                    revert with 'NH{q', 17
                                if 997 * _8926 / 997 != _8926:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9066 + 18 len 14]:
                                    if mem[_9066 + 50 len 14] and 1000 > -1 / mem[_9066 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9066 + 50 len 14] / 1000 != mem[_9066 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9066 + 50 len 14] > (-997 * _8926) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9066 + 50 len 14]) + (997 * _8926) < 1000 * mem[_9066 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9066 + 50 len 14]) + (997 * _8926):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10511 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10511] == mem[_10511 + 18 len 14]
                                    require mem[_10511 + 32] == mem[_10511 + 50 len 14]
                                    require mem[_10511 + 64] == mem[_10511 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10511 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10511 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) / 997 != 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10511 + 18 len 14]:
                                        if mem[_10511 + 50 len 14] and 1000 > -1 / mem[_10511 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10511 + 50 len 14] / 1000 != mem[_10511 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10511 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) < 1000 * mem[_10511 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) and mem[_10511 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                            revert with 'NH{q', 17
                                        if not mem[_10511 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) * mem[_10511 + 18 len 14] / mem[_10511 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10511 + 50 len 14] and 1000 > -1 / mem[_10511 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10511 + 50 len 14] / 1000 != mem[_10511 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10511 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) < 1000 * mem[_10511 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926) * mem[_10511 + 18 len 14] / (1000 * mem[_10511 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9198)) + (997 * _8926))
                                else:
                                    if 997 * _8926 and mem[_9066 + 18 len 14] > -1 / 997 * _8926:
                                        revert with 'NH{q', 17
                                    if not mem[_9066 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8926 * mem[_9066 + 18 len 14] / mem[_9066 + 18 len 14] != 997 * _8926:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9066 + 50 len 14] and 1000 > -1 / mem[_9066 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9066 + 50 len 14] / 1000 != mem[_9066 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9066 + 50 len 14] > (-997 * _8926) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9066 + 50 len 14]) + (997 * _8926) < 1000 * mem[_9066 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9066 + 50 len 14]) + (997 * _8926):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10944 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10944] == mem[_10944 + 18 len 14]
                                    require mem[_10944 + 32] == mem[_10944 + 50 len 14]
                                    require mem[_10944 + 64] == mem[_10944 + 92 len 4]
                                    if 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10944 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10944 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) and 997 > -1 / 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) / 997 != 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10944 + 18 len 14]:
                                        if mem[_10944 + 50 len 14] and 1000 > -1 / mem[_10944 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10944 + 50 len 14] / 1000 != mem[_10944 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10944 + 50 len 14] > (-997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) < 1000 * mem[_10944 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926))
                                    else:
                                        if 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) and mem[_10944 + 18 len 14] > -1 / 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                            revert with 'NH{q', 17
                                        if not mem[_10944 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) * mem[_10944 + 18 len 14] / mem[_10944 + 18 len 14] != 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10944 + 50 len 14] and 1000 > -1 / mem[_10944 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10944 + 50 len 14] / 1000 != mem[_10944 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10944 + 50 len 14] > (-997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)) < 1000 * mem[_10944 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926) * mem[_10944 + 18 len 14] / (1000 * mem[_10944 + 50 len 14]) + (997 * 997 * _8926 * Mask(112, 0, _9131) / (1000 * Mask(112, 0, _9198)) + (997 * _8926))
                            else:
                                if 997 * _7995 and mem[_8039 + 18 len 14] > -1 / 997 * _7995:
                                    revert with 'NH{q', 17
                                if not mem[_8039 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7995 * mem[_8039 + 18 len 14] / mem[_8039 + 18 len 14] != 997 * _7995:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8039 + 50 len 14] and 1000 > -1 / mem[_8039 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8039 + 50 len 14] / 1000 != mem[_8039 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8039 + 50 len 14] > (-997 * _7995) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8039 + 50 len 14]) + (997 * _7995) < 1000 * mem[_8039 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8039 + 50 len 14]) + (997 * _7995):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7995 * mem[_8039 + 18 len 14] / (1000 * mem[_8039 + 50 len 14]) + (997 * _7995)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7995 * Mask(112, 0, _8071) / (1000 * Mask(112, 0, _8095)) + (997 * _7995))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9132 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _9175 = mem[_9132]
                                require mem[_9132] == mem[_9132]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9303 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9367 = mem[_9303]
                                require mem[_9303] == mem[_9303 + 18 len 14]
                                _9427 = mem[_9303 + 32]
                                require mem[_9303 + 32] == mem[_9303 + 50 len 14]
                                require mem[_9303 + 64] == mem[_9303 + 92 len 4]
                                if _9175 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9303 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9303 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _9175 and 997 > -1 / _9175:
                                    revert with 'NH{q', 17
                                if 997 * _9175 / 997 != _9175:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9303 + 18 len 14]:
                                    if mem[_9303 + 50 len 14] and 1000 > -1 / mem[_9303 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9303 + 50 len 14] / 1000 != mem[_9303 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9303 + 50 len 14] > (-997 * _9175) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9303 + 50 len 14]) + (997 * _9175) < 1000 * mem[_9303 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9303 + 50 len 14]) + (997 * _9175):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10945 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10945] == mem[_10945 + 18 len 14]
                                    require mem[_10945 + 32] == mem[_10945 + 50 len 14]
                                    require mem[_10945 + 64] == mem[_10945 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10945 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10945 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) / 997 != 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10945 + 18 len 14]:
                                        if mem[_10945 + 50 len 14] and 1000 > -1 / mem[_10945 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10945 + 50 len 14] / 1000 != mem[_10945 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10945 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) < 1000 * mem[_10945 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) and mem[_10945 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                            revert with 'NH{q', 17
                                        if not mem[_10945 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) * mem[_10945 + 18 len 14] / mem[_10945 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10945 + 50 len 14] and 1000 > -1 / mem[_10945 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10945 + 50 len 14] / 1000 != mem[_10945 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10945 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) < 1000 * mem[_10945 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175) * mem[_10945 + 18 len 14] / (1000 * mem[_10945 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9427)) + (997 * _9175))
                                else:
                                    if 997 * _9175 and mem[_9303 + 18 len 14] > -1 / 997 * _9175:
                                        revert with 'NH{q', 17
                                    if not mem[_9303 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _9175 * mem[_9303 + 18 len 14] / mem[_9303 + 18 len 14] != 997 * _9175:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9303 + 50 len 14] and 1000 > -1 / mem[_9303 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9303 + 50 len 14] / 1000 != mem[_9303 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9303 + 50 len 14] > (-997 * _9175) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9303 + 50 len 14]) + (997 * _9175) < 1000 * mem[_9303 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9303 + 50 len 14]) + (997 * _9175):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11391 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11391] == mem[_11391 + 18 len 14]
                                    require mem[_11391 + 32] == mem[_11391 + 50 len 14]
                                    require mem[_11391 + 64] == mem[_11391 + 92 len 4]
                                    if 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11391 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11391 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) and 997 > -1 / 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) / 997 != 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11391 + 18 len 14]:
                                        if mem[_11391 + 50 len 14] and 1000 > -1 / mem[_11391 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11391 + 50 len 14] / 1000 != mem[_11391 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11391 + 50 len 14] > (-997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) < 1000 * mem[_11391 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175))
                                    else:
                                        if 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) and mem[_11391 + 18 len 14] > -1 / 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                            revert with 'NH{q', 17
                                        if not mem[_11391 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) * mem[_11391 + 18 len 14] / mem[_11391 + 18 len 14] != 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11391 + 50 len 14] and 1000 > -1 / mem[_11391 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11391 + 50 len 14] / 1000 != mem[_11391 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11391 + 50 len 14] > (-997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)) < 1000 * mem[_11391 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175) * mem[_11391 + 18 len 14] / (1000 * mem[_11391 + 50 len 14]) + (997 * 997 * _9175 * Mask(112, 0, _9367) / (1000 * Mask(112, 0, _9427)) + (997 * _9175))
                    else:
                        if 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) and mem[_7214 + 50 len 14] > -1 / 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                            revert with 'NH{q', 17
                        if not mem[_7214 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * mem[_7214 + 50 len 14] / mem[_7214 + 50 len 14] != 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063):
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7214 + 18 len 14] and 1000 > -1 / mem[_7214 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7214 + 18 len 14] / 1000 != mem[_7214 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7214 + 18 len 14] > (-997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)) < 1000 * mem[_7214 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * mem[_7214 + 50 len 14] / (1000 * mem[_7214 + 18 len 14]) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063))
                        require ext_code.size(stor6)
                        staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063) * Mask(112, 0, _7226) / (1000 * Mask(112, 0, _7222)) + (997 * 997 * _7063 * Mask(112, 0, _7095) / (1000 * Mask(112, 0, _7086)) + (997 * _7063)))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7500 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7510 = mem[_7500]
                        require mem[_7500] == mem[_7500]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7542 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        require mem[_7542] == mem[_7542 + 18 len 14]
                        require mem[_7542 + 32] == mem[_7542 + 50 len 14]
                        require mem[_7542 + 64] == mem[_7542 + 92 len 4]
                        if _7510 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7542 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7542 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7510 and 997 > -1 / _7510:
                            revert with 'NH{q', 17
                        if 997 * _7510 / 997 != _7510:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7542 + 50 len 14]:
                            if mem[_7542 + 18 len 14] and 1000 > -1 / mem[_7542 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7542 + 18 len 14] / 1000 != mem[_7542 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7542 + 18 len 14] > (-997 * _7510) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7542 + 18 len 14]) + (997 * _7510) < 1000 * mem[_7542 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7542 + 18 len 14]) + (997 * _7510):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7542 + 18 len 14]) + (997 * _7510)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _7996 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8040 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8072 = mem[_8040]
                            require mem[_8040] == mem[_8040 + 18 len 14]
                            _8096 = mem[_8040 + 32]
                            require mem[_8040 + 32] == mem[_8040 + 50 len 14]
                            require mem[_8040 + 64] == mem[_8040 + 92 len 4]
                            if _7996 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8040 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8040 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _7996 and 997 > -1 / _7996:
                                revert with 'NH{q', 17
                            if 997 * _7996 / 997 != _7996:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8040 + 18 len 14]:
                                if mem[_8040 + 50 len 14] and 1000 > -1 / mem[_8040 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8040 + 50 len 14] / 1000 != mem[_8040 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8040 + 50 len 14] > (-997 * _7996) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8040 + 50 len 14]) + (997 * _7996) < 1000 * mem[_8040 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8040 + 50 len 14]) + (997 * _7996):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_8040 + 50 len 14]) + (997 * _7996)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _8096)) + (997 * _7996))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8891 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _8927 = mem[_8891]
                                require mem[_8891] == mem[_8891]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9067 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9133 = mem[_9067]
                                require mem[_9067] == mem[_9067 + 18 len 14]
                                _9199 = mem[_9067 + 32]
                                require mem[_9067 + 32] == mem[_9067 + 50 len 14]
                                require mem[_9067 + 64] == mem[_9067 + 92 len 4]
                                if _8927 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9067 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9067 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _8927 and 997 > -1 / _8927:
                                    revert with 'NH{q', 17
                                if 997 * _8927 / 997 != _8927:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9067 + 18 len 14]:
                                    if mem[_9067 + 50 len 14] and 1000 > -1 / mem[_9067 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9067 + 50 len 14] / 1000 != mem[_9067 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9067 + 50 len 14] > (-997 * _8927) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9067 + 50 len 14]) + (997 * _8927) < 1000 * mem[_9067 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9067 + 50 len 14]) + (997 * _8927):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10514 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10514] == mem[_10514 + 18 len 14]
                                    require mem[_10514 + 32] == mem[_10514 + 50 len 14]
                                    require mem[_10514 + 64] == mem[_10514 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10514 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10514 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) / 997 != 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10514 + 18 len 14]:
                                        if mem[_10514 + 50 len 14] and 1000 > -1 / mem[_10514 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10514 + 50 len 14] / 1000 != mem[_10514 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10514 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) < 1000 * mem[_10514 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) and mem[_10514 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                            revert with 'NH{q', 17
                                        if not mem[_10514 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) * mem[_10514 + 18 len 14] / mem[_10514 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10514 + 50 len 14] and 1000 > -1 / mem[_10514 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10514 + 50 len 14] / 1000 != mem[_10514 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10514 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) < 1000 * mem[_10514 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927) * mem[_10514 + 18 len 14] / (1000 * mem[_10514 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9199)) + (997 * _8927))
                                else:
                                    if 997 * _8927 and mem[_9067 + 18 len 14] > -1 / 997 * _8927:
                                        revert with 'NH{q', 17
                                    if not mem[_9067 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _8927 * mem[_9067 + 18 len 14] / mem[_9067 + 18 len 14] != 997 * _8927:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9067 + 50 len 14] and 1000 > -1 / mem[_9067 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9067 + 50 len 14] / 1000 != mem[_9067 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9067 + 50 len 14] > (-997 * _8927) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9067 + 50 len 14]) + (997 * _8927) < 1000 * mem[_9067 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9067 + 50 len 14]) + (997 * _8927):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10947 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10947] == mem[_10947 + 18 len 14]
                                    require mem[_10947 + 32] == mem[_10947 + 50 len 14]
                                    require mem[_10947 + 64] == mem[_10947 + 92 len 4]
                                    if 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10947 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10947 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) and 997 > -1 / 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) / 997 != 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10947 + 18 len 14]:
                                        if mem[_10947 + 50 len 14] and 1000 > -1 / mem[_10947 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10947 + 50 len 14] / 1000 != mem[_10947 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10947 + 50 len 14] > (-997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) < 1000 * mem[_10947 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927))
                                    else:
                                        if 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) and mem[_10947 + 18 len 14] > -1 / 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                            revert with 'NH{q', 17
                                        if not mem[_10947 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) * mem[_10947 + 18 len 14] / mem[_10947 + 18 len 14] != 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10947 + 50 len 14] and 1000 > -1 / mem[_10947 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10947 + 50 len 14] / 1000 != mem[_10947 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10947 + 50 len 14] > (-997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)) < 1000 * mem[_10947 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927) * mem[_10947 + 18 len 14] / (1000 * mem[_10947 + 50 len 14]) + (997 * 997 * _8927 * Mask(112, 0, _9133) / (1000 * Mask(112, 0, _9199)) + (997 * _8927))
                            else:
                                if 997 * _7996 and mem[_8040 + 18 len 14] > -1 / 997 * _7996:
                                    revert with 'NH{q', 17
                                if not mem[_8040 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _7996 * mem[_8040 + 18 len 14] / mem[_8040 + 18 len 14] != 997 * _7996:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8040 + 50 len 14] and 1000 > -1 / mem[_8040 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8040 + 50 len 14] / 1000 != mem[_8040 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8040 + 50 len 14] > (-997 * _7996) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8040 + 50 len 14]) + (997 * _7996) < 1000 * mem[_8040 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8040 + 50 len 14]) + (997 * _7996):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _7996 * mem[_8040 + 18 len 14] / (1000 * mem[_8040 + 50 len 14]) + (997 * _7996)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _7996 * Mask(112, 0, _8072) / (1000 * Mask(112, 0, _8096)) + (997 * _7996))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9134 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _9176 = mem[_9134]
                                require mem[_9134] == mem[_9134]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9304 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9368 = mem[_9304]
                                require mem[_9304] == mem[_9304 + 18 len 14]
                                _9428 = mem[_9304 + 32]
                                require mem[_9304 + 32] == mem[_9304 + 50 len 14]
                                require mem[_9304 + 64] == mem[_9304 + 92 len 4]
                                if _9176 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9304 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9304 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _9176 and 997 > -1 / _9176:
                                    revert with 'NH{q', 17
                                if 997 * _9176 / 997 != _9176:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9304 + 18 len 14]:
                                    if mem[_9304 + 50 len 14] and 1000 > -1 / mem[_9304 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9304 + 50 len 14] / 1000 != mem[_9304 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9304 + 50 len 14] > (-997 * _9176) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9304 + 50 len 14]) + (997 * _9176) < 1000 * mem[_9304 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9304 + 50 len 14]) + (997 * _9176):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10948 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10948] == mem[_10948 + 18 len 14]
                                    require mem[_10948 + 32] == mem[_10948 + 50 len 14]
                                    require mem[_10948 + 64] == mem[_10948 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10948 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10948 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) / 997 != 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10948 + 18 len 14]:
                                        if mem[_10948 + 50 len 14] and 1000 > -1 / mem[_10948 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10948 + 50 len 14] / 1000 != mem[_10948 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10948 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) < 1000 * mem[_10948 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) and mem[_10948 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                            revert with 'NH{q', 17
                                        if not mem[_10948 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) * mem[_10948 + 18 len 14] / mem[_10948 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10948 + 50 len 14] and 1000 > -1 / mem[_10948 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10948 + 50 len 14] / 1000 != mem[_10948 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10948 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) < 1000 * mem[_10948 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176) * mem[_10948 + 18 len 14] / (1000 * mem[_10948 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9428)) + (997 * _9176))
                                else:
                                    if 997 * _9176 and mem[_9304 + 18 len 14] > -1 / 997 * _9176:
                                        revert with 'NH{q', 17
                                    if not mem[_9304 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _9176 * mem[_9304 + 18 len 14] / mem[_9304 + 18 len 14] != 997 * _9176:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9304 + 50 len 14] and 1000 > -1 / mem[_9304 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9304 + 50 len 14] / 1000 != mem[_9304 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9304 + 50 len 14] > (-997 * _9176) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9304 + 50 len 14]) + (997 * _9176) < 1000 * mem[_9304 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9304 + 50 len 14]) + (997 * _9176):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11392 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11392] == mem[_11392 + 18 len 14]
                                    require mem[_11392 + 32] == mem[_11392 + 50 len 14]
                                    require mem[_11392 + 64] == mem[_11392 + 92 len 4]
                                    if 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11392 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11392 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) and 997 > -1 / 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) / 997 != 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11392 + 18 len 14]:
                                        if mem[_11392 + 50 len 14] and 1000 > -1 / mem[_11392 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11392 + 50 len 14] / 1000 != mem[_11392 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11392 + 50 len 14] > (-997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) < 1000 * mem[_11392 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176))
                                    else:
                                        if 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) and mem[_11392 + 18 len 14] > -1 / 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                            revert with 'NH{q', 17
                                        if not mem[_11392 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) * mem[_11392 + 18 len 14] / mem[_11392 + 18 len 14] != 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11392 + 50 len 14] and 1000 > -1 / mem[_11392 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11392 + 50 len 14] / 1000 != mem[_11392 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11392 + 50 len 14] > (-997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)) < 1000 * mem[_11392 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176) * mem[_11392 + 18 len 14] / (1000 * mem[_11392 + 50 len 14]) + (997 * 997 * _9176 * Mask(112, 0, _9368) / (1000 * Mask(112, 0, _9428)) + (997 * _9176))
                        else:
                            if 997 * _7510 and mem[_7542 + 50 len 14] > -1 / 997 * _7510:
                                revert with 'NH{q', 17
                            if not mem[_7542 + 50 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7510 * mem[_7542 + 50 len 14] / mem[_7542 + 50 len 14] != 997 * _7510:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7542 + 18 len 14] and 1000 > -1 / mem[_7542 + 18 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7542 + 18 len 14] / 1000 != mem[_7542 + 18 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7542 + 18 len 14] > (-997 * _7510) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7542 + 18 len 14]) + (997 * _7510) < 1000 * mem[_7542 + 18 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7542 + 18 len 14]) + (997 * _7510):
                                revert with 'NH{q', 18
                            if idx >= mem[(32 * ('cd', 4).length) + 128]:
                                revert with 'NH{q', 50
                            mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7510 * mem[_7542 + 50 len 14] / (1000 * mem[_7542 + 18 len 14]) + (997 * _7510)
                            if idx >= mem[96]:
                                revert with 'NH{q', 50
                            _8126 = mem[(32 * idx) + 128]
                            require ext_code.size(stor12)
                            staticcall stor12.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8162 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8194 = mem[_8162]
                            require mem[_8162] == mem[_8162 + 18 len 14]
                            _8226 = mem[_8162 + 32]
                            require mem[_8162 + 32] == mem[_8162 + 50 len 14]
                            require mem[_8162 + 64] == mem[_8162 + 92 len 4]
                            if _8126 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8162 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8162 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8126 and 997 > -1 / _8126:
                                revert with 'NH{q', 17
                            if 997 * _8126 / 997 != _8126:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8162 + 18 len 14]:
                                if mem[_8162 + 50 len 14] and 1000 > -1 / mem[_8162 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8162 + 50 len 14] / 1000 != mem[_8162 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8162 + 50 len 14] > (-997 * _8126) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8162 + 50 len 14]) + (997 * _8126) < 1000 * mem[_8162 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8162 + 50 len 14]) + (997 * _8126):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 0 / (1000 * mem[_8162 + 50 len 14]) + (997 * _8126)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (0 / (1000 * Mask(112, 0, _8226)) + (997 * _8126))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9135 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _9177 = mem[_9135]
                                require mem[_9135] == mem[_9135]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9305 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9369 = mem[_9305]
                                require mem[_9305] == mem[_9305 + 18 len 14]
                                _9429 = mem[_9305 + 32]
                                require mem[_9305 + 32] == mem[_9305 + 50 len 14]
                                require mem[_9305 + 64] == mem[_9305 + 92 len 4]
                                if _9177 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9305 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9305 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _9177 and 997 > -1 / _9177:
                                    revert with 'NH{q', 17
                                if 997 * _9177 / 997 != _9177:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9305 + 18 len 14]:
                                    if mem[_9305 + 50 len 14] and 1000 > -1 / mem[_9305 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9305 + 50 len 14] / 1000 != mem[_9305 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9305 + 50 len 14] > (-997 * _9177) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9305 + 50 len 14]) + (997 * _9177) < 1000 * mem[_9305 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9305 + 50 len 14]) + (997 * _9177):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10950 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_10950] == mem[_10950 + 18 len 14]
                                    require mem[_10950 + 32] == mem[_10950 + 50 len 14]
                                    require mem[_10950 + 64] == mem[_10950 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_10950 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_10950 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) / 997 != 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_10950 + 18 len 14]:
                                        if mem[_10950 + 50 len 14] and 1000 > -1 / mem[_10950 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10950 + 50 len 14] / 1000 != mem[_10950 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10950 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) < 1000 * mem[_10950 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) and mem[_10950 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                            revert with 'NH{q', 17
                                        if not mem[_10950 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) * mem[_10950 + 18 len 14] / mem[_10950 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_10950 + 50 len 14] and 1000 > -1 / mem[_10950 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_10950 + 50 len 14] / 1000 != mem[_10950 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_10950 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) < 1000 * mem[_10950 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177) * mem[_10950 + 18 len 14] / (1000 * mem[_10950 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9429)) + (997 * _9177))
                                else:
                                    if 997 * _9177 and mem[_9305 + 18 len 14] > -1 / 997 * _9177:
                                        revert with 'NH{q', 17
                                    if not mem[_9305 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _9177 * mem[_9305 + 18 len 14] / mem[_9305 + 18 len 14] != 997 * _9177:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9305 + 50 len 14] and 1000 > -1 / mem[_9305 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9305 + 50 len 14] / 1000 != mem[_9305 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9305 + 50 len 14] > (-997 * _9177) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9305 + 50 len 14]) + (997 * _9177) < 1000 * mem[_9305 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9305 + 50 len 14]) + (997 * _9177):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11393 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11393] == mem[_11393 + 18 len 14]
                                    require mem[_11393 + 32] == mem[_11393 + 50 len 14]
                                    require mem[_11393 + 64] == mem[_11393 + 92 len 4]
                                    if 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11393 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11393 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) and 997 > -1 / 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) / 997 != 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11393 + 18 len 14]:
                                        if mem[_11393 + 50 len 14] and 1000 > -1 / mem[_11393 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11393 + 50 len 14] / 1000 != mem[_11393 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11393 + 50 len 14] > (-997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) < 1000 * mem[_11393 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177))
                                    else:
                                        if 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) and mem[_11393 + 18 len 14] > -1 / 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                            revert with 'NH{q', 17
                                        if not mem[_11393 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) * mem[_11393 + 18 len 14] / mem[_11393 + 18 len 14] != 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11393 + 50 len 14] and 1000 > -1 / mem[_11393 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11393 + 50 len 14] / 1000 != mem[_11393 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11393 + 50 len 14] > (-997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)) < 1000 * mem[_11393 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177) * mem[_11393 + 18 len 14] / (1000 * mem[_11393 + 50 len 14]) + (997 * 997 * _9177 * Mask(112, 0, _9369) / (1000 * Mask(112, 0, _9429)) + (997 * _9177))
                            else:
                                if 997 * _8126 and mem[_8162 + 18 len 14] > -1 / 997 * _8126:
                                    revert with 'NH{q', 17
                                if not mem[_8162 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8126 * mem[_8162 + 18 len 14] / mem[_8162 + 18 len 14] != 997 * _8126:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8162 + 50 len 14] and 1000 > -1 / mem[_8162 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8162 + 50 len 14] / 1000 != mem[_8162 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8162 + 50 len 14] > (-997 * _8126) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8162 + 50 len 14]) + (997 * _8126) < 1000 * mem[_8162 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8162 + 50 len 14]) + (997 * _8126):
                                    revert with 'NH{q', 18
                                mem[mem[64] + 4] = 997 * _8126 * mem[_8162 + 18 len 14] / (1000 * mem[_8162 + 50 len 14]) + (997 * _8126)
                                require ext_code.size(stor6)
                                staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                        gas gas_remaining wei
                                       args (997 * _8126 * Mask(112, 0, _8194) / (1000 * Mask(112, 0, _8226)) + (997 * _8126))
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9370 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _9418 = mem[_9370]
                                require mem[_9370] == mem[_9370]
                                require ext_code.size(stor14)
                                staticcall stor14.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9522 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                _9582 = mem[_9522]
                                require mem[_9522] == mem[_9522 + 18 len 14]
                                _9655 = mem[_9522 + 32]
                                require mem[_9522 + 32] == mem[_9522 + 50 len 14]
                                require mem[_9522 + 64] == mem[_9522 + 92 len 4]
                                if _9418 <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9522 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9522 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if _9418 and 997 > -1 / _9418:
                                    revert with 'NH{q', 17
                                if 997 * _9418 / 997 != _9418:
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9522 + 18 len 14]:
                                    if mem[_9522 + 50 len 14] and 1000 > -1 / mem[_9522 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9522 + 50 len 14] / 1000 != mem[_9522 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9522 + 50 len 14] > (-997 * _9418) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9522 + 50 len 14]) + (997 * _9418) < 1000 * mem[_9522 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9522 + 50 len 14]) + (997 * _9418):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11394 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11394] == mem[_11394 + 18 len 14]
                                    require mem[_11394 + 32] == mem[_11394 + 50 len 14]
                                    require mem[_11394 + 64] == mem[_11394 + 92 len 4]
                                    if 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11394 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11394 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                        revert with 'NH{q', 17
                                    if 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) / 997 != 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11394 + 18 len 14]:
                                        if mem[_11394 + 50 len 14] and 1000 > -1 / mem[_11394 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11394 + 50 len 14] / 1000 != mem[_11394 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11394 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) < 1000 * mem[_11394 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418))
                                    else:
                                        if 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) and mem[_11394 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                            revert with 'NH{q', 17
                                        if not mem[_11394 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) * mem[_11394 + 18 len 14] / mem[_11394 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11394 + 50 len 14] and 1000 > -1 / mem[_11394 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11394 + 50 len 14] / 1000 != mem[_11394 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11394 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) < 1000 * mem[_11394 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418) * mem[_11394 + 18 len 14] / (1000 * mem[_11394 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9655)) + (997 * _9418))
                                else:
                                    if 997 * _9418 and mem[_9522 + 18 len 14] > -1 / 997 * _9418:
                                        revert with 'NH{q', 17
                                    if not mem[_9522 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * _9418 * mem[_9522 + 18 len 14] / mem[_9522 + 18 len 14] != 997 * _9418:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9522 + 50 len 14] and 1000 > -1 / mem[_9522 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9522 + 50 len 14] / 1000 != mem[_9522 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9522 + 50 len 14] > (-997 * _9418) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9522 + 50 len 14]) + (997 * _9418) < 1000 * mem[_9522 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9522 + 50 len 14]) + (997 * _9418):
                                        revert with 'NH{q', 18
                                    require ext_code.size(stor13)
                                    staticcall stor13.getReserves() with:
                                            gas gas_remaining wei
                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _11802 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 96
                                    require mem[_11802] == mem[_11802 + 18 len 14]
                                    require mem[_11802 + 32] == mem[_11802 + 50 len 14]
                                    require mem[_11802 + 64] == mem[_11802 + 92 len 4]
                                    if 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                    if mem[_11802 + 50 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if mem[_11802 + 18 len 14] <= 0:
                                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                    if 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) and 997 > -1 / 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                        revert with 'NH{q', 17
                                    if 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) / 997 != 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if not mem[_11802 + 18 len 14]:
                                        if mem[_11802 + 50 len 14] and 1000 > -1 / mem[_11802 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11802 + 50 len 14] / 1000 != mem[_11802 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11802 + 50 len 14] > (-997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) < 1000 * mem[_11802 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418))
                                    else:
                                        if 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) and mem[_11802 + 18 len 14] > -1 / 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                            revert with 'NH{q', 17
                                        if not mem[_11802 + 18 len 14]:
                                            revert with 'NH{q', 18
                                        if 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) * mem[_11802 + 18 len 14] / mem[_11802 + 18 len 14] != 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418):
                                            revert with 0, 'ds-math-mul-overflow'
                                        if mem[_11802 + 50 len 14] and 1000 > -1 / mem[_11802 + 50 len 14]:
                                            revert with 'NH{q', 17
                                        if 1000 * mem[_11802 + 50 len 14] / 1000 != mem[_11802 + 50 len 14]:
                                            revert with 0, 'ds-math-mul-overflow'
                                        if 1000 * mem[_11802 + 50 len 14] > (-997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) - 1:
                                            revert with 'NH{q', 17
                                        if (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)) < 1000 * mem[_11802 + 50 len 14]:
                                            revert with 0, 'ds-math-add-overflow'
                                        if not (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418)):
                                            revert with 'NH{q', 18
                                        if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                            revert with 'NH{q', 50
                                        mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418) * mem[_11802 + 18 len 14] / (1000 * mem[_11802 + 50 len 14]) + (997 * 997 * _9418 * Mask(112, 0, _9582) / (1000 * Mask(112, 0, _9655)) + (997 * _9418))
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _7062 = mem[64]
            mem[mem[64]] = 64
            _7078 = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + 64] = mem[(32 * ('cd', 4).length) + 128]
            mem[mem[64] + 96 len 32 * _7078] = mem[(32 * ('cd', 4).length) + 160 len 32 * _7078]
            mem[mem[64] + 32] = (32 * _7078) + 96
            _7406 = mem[(64 * ('cd', 4).length) + 160]
            mem[_7062 + (32 * _7078) + 96] = mem[(64 * ('cd', 4).length) + 160]
            mem[_7062 + (32 * _7078) + 128 len 32 * _7406] = mem[(64 * ('cd', 4).length) + 192 len 32 * _7406]
            return memory
              from mem[64]
               len _7062 + (32 * _7078) + (32 * _7406) + -mem[64] + 128
        mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            _7065 = mem[(32 * idx) + 128]
            require ext_code.size(stor13)
            staticcall stor13.getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7081 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _7087 = mem[_7081]
            require mem[_7081] == mem[_7081 + 18 len 14]
            _7097 = mem[_7081 + 32]
            require mem[_7081 + 32] == mem[_7081 + 50 len 14]
            require mem[_7081 + 64] == mem[_7081 + 92 len 4]
            if _7065 <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
            if mem[_7081 + 18 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if mem[_7081 + 50 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if _7065 and 997 > -1 / _7065:
                revert with 'NH{q', 17
            if 997 * _7065 / 997 != _7065:
                revert with 0, 'ds-math-mul-overflow'
            if not mem[_7081 + 50 len 14]:
                if mem[_7081 + 18 len 14] and 1000 > -1 / mem[_7081 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7081 + 18 len 14] / 1000 != mem[_7081 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7081 + 18 len 14] > (-997 * _7065) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7081 + 18 len 14]) + (997 * _7065) < 1000 * mem[_7081 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7081 + 18 len 14]) + (997 * _7065):
                    revert with 'NH{q', 18
                require ext_code.size(stor14)
                staticcall stor14.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7184 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7191 = mem[_7184]
                require mem[_7184] == mem[_7184 + 18 len 14]
                _7200 = mem[_7184 + 32]
                require mem[_7184 + 32] == mem[_7184 + 50 len 14]
                require mem[_7184 + 64] == mem[_7184 + 92 len 4]
                if 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7184 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7184 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) and 997 > -1 / 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                    revert with 'NH{q', 17
                if 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) / 997 != 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7184 + 50 len 14]:
                    if mem[_7184 + 18 len 14] and 1000 > -1 / mem[_7184 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7184 + 18 len 14] / 1000 != mem[_7184 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7184 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) < 1000 * mem[_7184 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 0 / (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (0 / (1000 * Mask(112, 0, _7191)) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7363 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7368 = mem[_7363]
                    require mem[_7363] == mem[_7363]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7411 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7411] == mem[_7411 + 18 len 14]
                    require mem[_7411 + 32] == mem[_7411 + 50 len 14]
                    require mem[_7411 + 64] == mem[_7411 + 92 len 4]
                    if _7368 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7411 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7411 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7368 and 997 > -1 / _7368:
                        revert with 'NH{q', 17
                    if 997 * _7368 / 997 != _7368:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7411 + 50 len 14]:
                        if mem[_7411 + 18 len 14] and 1000 > -1 / mem[_7411 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7411 + 18 len 14] / 1000 != mem[_7411 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7411 + 18 len 14] > (-997 * _7368) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7411 + 18 len 14]) + (997 * _7368) < 1000 * mem[_7411 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7411 + 18 len 14]) + (997 * _7368):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7411 + 18 len 14]) + (997 * _7368)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7755 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7770 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7787 = mem[_7770]
                        require mem[_7770] == mem[_7770 + 18 len 14]
                        _7822 = mem[_7770 + 32]
                        require mem[_7770 + 32] == mem[_7770 + 50 len 14]
                        require mem[_7770 + 64] == mem[_7770 + 92 len 4]
                        if _7755 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7770 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7770 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7755 and 997 > -1 / _7755:
                            revert with 'NH{q', 17
                        if 997 * _7755 / 997 != _7755:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7770 + 18 len 14]:
                            if mem[_7770 + 50 len 14] and 1000 > -1 / mem[_7770 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7770 + 50 len 14] / 1000 != mem[_7770 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7770 + 50 len 14] > (-997 * _7755) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7770 + 50 len 14]) + (997 * _7755) < 1000 * mem[_7770 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7770 + 50 len 14]) + (997 * _7755):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7770 + 50 len 14]) + (997 * _7755)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7822)) + (997 * _7755))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8499 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8513 = mem[_8499]
                            require mem[_8499] == mem[_8499]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8619 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8671 = mem[_8619]
                            require mem[_8619] == mem[_8619 + 18 len 14]
                            _8753 = mem[_8619 + 32]
                            require mem[_8619 + 32] == mem[_8619 + 50 len 14]
                            require mem[_8619 + 64] == mem[_8619 + 92 len 4]
                            if _8513 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8619 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8619 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8513 and 997 > -1 / _8513:
                                revert with 'NH{q', 17
                            if 997 * _8513 / 997 != _8513:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8619 + 18 len 14]:
                                if mem[_8619 + 50 len 14] and 1000 > -1 / mem[_8619 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8619 + 50 len 14] / 1000 != mem[_8619 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8619 + 50 len 14] > (-997 * _8513) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8619 + 50 len 14]) + (997 * _8513) < 1000 * mem[_8619 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8619 + 50 len 14]) + (997 * _8513):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9904 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_9904] == mem[_9904 + 18 len 14]
                                require mem[_9904 + 32] == mem[_9904 + 50 len 14]
                                require mem[_9904 + 64] == mem[_9904 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9904 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9904 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) / 997 != 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9904 + 18 len 14]:
                                    if mem[_9904 + 50 len 14] and 1000 > -1 / mem[_9904 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9904 + 50 len 14] / 1000 != mem[_9904 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9904 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) < 1000 * mem[_9904 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) and mem[_9904 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                        revert with 'NH{q', 17
                                    if not mem[_9904 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) * mem[_9904 + 18 len 14] / mem[_9904 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9904 + 50 len 14] and 1000 > -1 / mem[_9904 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9904 + 50 len 14] / 1000 != mem[_9904 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9904 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) < 1000 * mem[_9904 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513) * mem[_9904 + 18 len 14] / (1000 * mem[_9904 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8753)) + (997 * _8513))
                            else:
                                if 997 * _8513 and mem[_8619 + 18 len 14] > -1 / 997 * _8513:
                                    revert with 'NH{q', 17
                                if not mem[_8619 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8513 * mem[_8619 + 18 len 14] / mem[_8619 + 18 len 14] != 997 * _8513:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8619 + 50 len 14] and 1000 > -1 / mem[_8619 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8619 + 50 len 14] / 1000 != mem[_8619 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8619 + 50 len 14] > (-997 * _8513) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8619 + 50 len 14]) + (997 * _8513) < 1000 * mem[_8619 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8619 + 50 len 14]) + (997 * _8513):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10157 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10157] == mem[_10157 + 18 len 14]
                                require mem[_10157 + 32] == mem[_10157 + 50 len 14]
                                require mem[_10157 + 64] == mem[_10157 + 92 len 4]
                                if 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10157 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10157 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) and 997 > -1 / 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) / 997 != 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10157 + 18 len 14]:
                                    if mem[_10157 + 50 len 14] and 1000 > -1 / mem[_10157 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10157 + 50 len 14] / 1000 != mem[_10157 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10157 + 50 len 14] > (-997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) < 1000 * mem[_10157 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513))
                                else:
                                    if 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) and mem[_10157 + 18 len 14] > -1 / 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                        revert with 'NH{q', 17
                                    if not mem[_10157 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) * mem[_10157 + 18 len 14] / mem[_10157 + 18 len 14] != 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10157 + 50 len 14] and 1000 > -1 / mem[_10157 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10157 + 50 len 14] / 1000 != mem[_10157 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10157 + 50 len 14] > (-997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)) < 1000 * mem[_10157 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513) * mem[_10157 + 18 len 14] / (1000 * mem[_10157 + 50 len 14]) + (997 * 997 * _8513 * Mask(112, 0, _8671) / (1000 * Mask(112, 0, _8753)) + (997 * _8513))
                        else:
                            if 997 * _7755 and mem[_7770 + 18 len 14] > -1 / 997 * _7755:
                                revert with 'NH{q', 17
                            if not mem[_7770 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7755 * mem[_7770 + 18 len 14] / mem[_7770 + 18 len 14] != 997 * _7755:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7770 + 50 len 14] and 1000 > -1 / mem[_7770 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7770 + 50 len 14] / 1000 != mem[_7770 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7770 + 50 len 14] > (-997 * _7755) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7770 + 50 len 14]) + (997 * _7755) < 1000 * mem[_7770 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7770 + 50 len 14]) + (997 * _7755):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7755 * mem[_7770 + 18 len 14] / (1000 * mem[_7770 + 50 len 14]) + (997 * _7755)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7755 * Mask(112, 0, _7787) / (1000 * Mask(112, 0, _7822)) + (997 * _7755))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8672 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8694 = mem[_8672]
                            require mem[_8672] == mem[_8672]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8826 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8892 = mem[_8826]
                            require mem[_8826] == mem[_8826 + 18 len 14]
                            _8974 = mem[_8826 + 32]
                            require mem[_8826 + 32] == mem[_8826 + 50 len 14]
                            require mem[_8826 + 64] == mem[_8826 + 92 len 4]
                            if _8694 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8826 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8826 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8694 and 997 > -1 / _8694:
                                revert with 'NH{q', 17
                            if 997 * _8694 / 997 != _8694:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8826 + 18 len 14]:
                                if mem[_8826 + 50 len 14] and 1000 > -1 / mem[_8826 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8826 + 50 len 14] / 1000 != mem[_8826 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8826 + 50 len 14] > (-997 * _8694) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8826 + 50 len 14]) + (997 * _8694) < 1000 * mem[_8826 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8826 + 50 len 14]) + (997 * _8694):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10158 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10158] == mem[_10158 + 18 len 14]
                                require mem[_10158 + 32] == mem[_10158 + 50 len 14]
                                require mem[_10158 + 64] == mem[_10158 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10158 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10158 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) / 997 != 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10158 + 18 len 14]:
                                    if mem[_10158 + 50 len 14] and 1000 > -1 / mem[_10158 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10158 + 50 len 14] / 1000 != mem[_10158 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10158 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) < 1000 * mem[_10158 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) and mem[_10158 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                        revert with 'NH{q', 17
                                    if not mem[_10158 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) * mem[_10158 + 18 len 14] / mem[_10158 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10158 + 50 len 14] and 1000 > -1 / mem[_10158 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10158 + 50 len 14] / 1000 != mem[_10158 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10158 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) < 1000 * mem[_10158 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694) * mem[_10158 + 18 len 14] / (1000 * mem[_10158 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8974)) + (997 * _8694))
                            else:
                                if 997 * _8694 and mem[_8826 + 18 len 14] > -1 / 997 * _8694:
                                    revert with 'NH{q', 17
                                if not mem[_8826 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8694 * mem[_8826 + 18 len 14] / mem[_8826 + 18 len 14] != 997 * _8694:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8826 + 50 len 14] and 1000 > -1 / mem[_8826 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8826 + 50 len 14] / 1000 != mem[_8826 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8826 + 50 len 14] > (-997 * _8694) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8826 + 50 len 14]) + (997 * _8694) < 1000 * mem[_8826 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8826 + 50 len 14]) + (997 * _8694):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10518 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10518] == mem[_10518 + 18 len 14]
                                require mem[_10518 + 32] == mem[_10518 + 50 len 14]
                                require mem[_10518 + 64] == mem[_10518 + 92 len 4]
                                if 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10518 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10518 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) and 997 > -1 / 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) / 997 != 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10518 + 18 len 14]:
                                    if mem[_10518 + 50 len 14] and 1000 > -1 / mem[_10518 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10518 + 50 len 14] / 1000 != mem[_10518 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10518 + 50 len 14] > (-997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) < 1000 * mem[_10518 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694))
                                else:
                                    if 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) and mem[_10518 + 18 len 14] > -1 / 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                        revert with 'NH{q', 17
                                    if not mem[_10518 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) * mem[_10518 + 18 len 14] / mem[_10518 + 18 len 14] != 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10518 + 50 len 14] and 1000 > -1 / mem[_10518 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10518 + 50 len 14] / 1000 != mem[_10518 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10518 + 50 len 14] > (-997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)) < 1000 * mem[_10518 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694) * mem[_10518 + 18 len 14] / (1000 * mem[_10518 + 50 len 14]) + (997 * 997 * _8694 * Mask(112, 0, _8892) / (1000 * Mask(112, 0, _8974)) + (997 * _8694))
                    else:
                        if 997 * _7368 and mem[_7411 + 50 len 14] > -1 / 997 * _7368:
                            revert with 'NH{q', 17
                        if not mem[_7411 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7368 * mem[_7411 + 50 len 14] / mem[_7411 + 50 len 14] != 997 * _7368:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7411 + 18 len 14] and 1000 > -1 / mem[_7411 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7411 + 18 len 14] / 1000 != mem[_7411 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7411 + 18 len 14] > (-997 * _7368) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7411 + 18 len 14]) + (997 * _7368) < 1000 * mem[_7411 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7411 + 18 len 14]) + (997 * _7368):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7368 * mem[_7411 + 50 len 14] / (1000 * mem[_7411 + 18 len 14]) + (997 * _7368)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7861 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7900 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7925 = mem[_7900]
                        require mem[_7900] == mem[_7900 + 18 len 14]
                        _7956 = mem[_7900 + 32]
                        require mem[_7900 + 32] == mem[_7900 + 50 len 14]
                        require mem[_7900 + 64] == mem[_7900 + 92 len 4]
                        if _7861 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7900 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7900 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7861 and 997 > -1 / _7861:
                            revert with 'NH{q', 17
                        if 997 * _7861 / 997 != _7861:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7900 + 18 len 14]:
                            if mem[_7900 + 50 len 14] and 1000 > -1 / mem[_7900 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7900 + 50 len 14] / 1000 != mem[_7900 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7900 + 50 len 14] > (-997 * _7861) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7900 + 50 len 14]) + (997 * _7861) < 1000 * mem[_7900 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7900 + 50 len 14]) + (997 * _7861):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7900 + 50 len 14]) + (997 * _7861)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7956)) + (997 * _7861))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8673 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8695 = mem[_8673]
                            require mem[_8673] == mem[_8673]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8827 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8893 = mem[_8827]
                            require mem[_8827] == mem[_8827 + 18 len 14]
                            _8975 = mem[_8827 + 32]
                            require mem[_8827 + 32] == mem[_8827 + 50 len 14]
                            require mem[_8827 + 64] == mem[_8827 + 92 len 4]
                            if _8695 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8827 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8827 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8695 and 997 > -1 / _8695:
                                revert with 'NH{q', 17
                            if 997 * _8695 / 997 != _8695:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8827 + 18 len 14]:
                                if mem[_8827 + 50 len 14] and 1000 > -1 / mem[_8827 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8827 + 50 len 14] / 1000 != mem[_8827 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8827 + 50 len 14] > (-997 * _8695) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8827 + 50 len 14]) + (997 * _8695) < 1000 * mem[_8827 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8827 + 50 len 14]) + (997 * _8695):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10160 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10160] == mem[_10160 + 18 len 14]
                                require mem[_10160 + 32] == mem[_10160 + 50 len 14]
                                require mem[_10160 + 64] == mem[_10160 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10160 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10160 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) / 997 != 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10160 + 18 len 14]:
                                    if mem[_10160 + 50 len 14] and 1000 > -1 / mem[_10160 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10160 + 50 len 14] / 1000 != mem[_10160 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10160 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) < 1000 * mem[_10160 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) and mem[_10160 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                        revert with 'NH{q', 17
                                    if not mem[_10160 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) * mem[_10160 + 18 len 14] / mem[_10160 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10160 + 50 len 14] and 1000 > -1 / mem[_10160 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10160 + 50 len 14] / 1000 != mem[_10160 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10160 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) < 1000 * mem[_10160 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695) * mem[_10160 + 18 len 14] / (1000 * mem[_10160 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8975)) + (997 * _8695))
                            else:
                                if 997 * _8695 and mem[_8827 + 18 len 14] > -1 / 997 * _8695:
                                    revert with 'NH{q', 17
                                if not mem[_8827 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8695 * mem[_8827 + 18 len 14] / mem[_8827 + 18 len 14] != 997 * _8695:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8827 + 50 len 14] and 1000 > -1 / mem[_8827 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8827 + 50 len 14] / 1000 != mem[_8827 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8827 + 50 len 14] > (-997 * _8695) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8827 + 50 len 14]) + (997 * _8695) < 1000 * mem[_8827 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8827 + 50 len 14]) + (997 * _8695):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10519 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10519] == mem[_10519 + 18 len 14]
                                require mem[_10519 + 32] == mem[_10519 + 50 len 14]
                                require mem[_10519 + 64] == mem[_10519 + 92 len 4]
                                if 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10519 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10519 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) and 997 > -1 / 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) / 997 != 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10519 + 18 len 14]:
                                    if mem[_10519 + 50 len 14] and 1000 > -1 / mem[_10519 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10519 + 50 len 14] / 1000 != mem[_10519 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10519 + 50 len 14] > (-997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) < 1000 * mem[_10519 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695))
                                else:
                                    if 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) and mem[_10519 + 18 len 14] > -1 / 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                        revert with 'NH{q', 17
                                    if not mem[_10519 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) * mem[_10519 + 18 len 14] / mem[_10519 + 18 len 14] != 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10519 + 50 len 14] and 1000 > -1 / mem[_10519 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10519 + 50 len 14] / 1000 != mem[_10519 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10519 + 50 len 14] > (-997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)) < 1000 * mem[_10519 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695) * mem[_10519 + 18 len 14] / (1000 * mem[_10519 + 50 len 14]) + (997 * 997 * _8695 * Mask(112, 0, _8893) / (1000 * Mask(112, 0, _8975)) + (997 * _8695))
                        else:
                            if 997 * _7861 and mem[_7900 + 18 len 14] > -1 / 997 * _7861:
                                revert with 'NH{q', 17
                            if not mem[_7900 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7861 * mem[_7900 + 18 len 14] / mem[_7900 + 18 len 14] != 997 * _7861:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7900 + 50 len 14] and 1000 > -1 / mem[_7900 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7900 + 50 len 14] / 1000 != mem[_7900 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7900 + 50 len 14] > (-997 * _7861) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7900 + 50 len 14]) + (997 * _7861) < 1000 * mem[_7900 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7900 + 50 len 14]) + (997 * _7861):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7861 * mem[_7900 + 18 len 14] / (1000 * mem[_7900 + 50 len 14]) + (997 * _7861)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7861 * Mask(112, 0, _7925) / (1000 * Mask(112, 0, _7956)) + (997 * _7861))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8894 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8929 = mem[_8894]
                            require mem[_8894] == mem[_8894]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9068 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9136 = mem[_9068]
                            require mem[_9068] == mem[_9068 + 18 len 14]
                            _9201 = mem[_9068 + 32]
                            require mem[_9068 + 32] == mem[_9068 + 50 len 14]
                            require mem[_9068 + 64] == mem[_9068 + 92 len 4]
                            if _8929 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9068 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9068 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8929 and 997 > -1 / _8929:
                                revert with 'NH{q', 17
                            if 997 * _8929 / 997 != _8929:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9068 + 18 len 14]:
                                if mem[_9068 + 50 len 14] and 1000 > -1 / mem[_9068 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9068 + 50 len 14] / 1000 != mem[_9068 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9068 + 50 len 14] > (-997 * _8929) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9068 + 50 len 14]) + (997 * _8929) < 1000 * mem[_9068 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9068 + 50 len 14]) + (997 * _8929):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10520 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10520] == mem[_10520 + 18 len 14]
                                require mem[_10520 + 32] == mem[_10520 + 50 len 14]
                                require mem[_10520 + 64] == mem[_10520 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10520 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10520 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) / 997 != 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10520 + 18 len 14]:
                                    if mem[_10520 + 50 len 14] and 1000 > -1 / mem[_10520 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10520 + 50 len 14] / 1000 != mem[_10520 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10520 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) < 1000 * mem[_10520 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) and mem[_10520 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                        revert with 'NH{q', 17
                                    if not mem[_10520 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) * mem[_10520 + 18 len 14] / mem[_10520 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10520 + 50 len 14] and 1000 > -1 / mem[_10520 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10520 + 50 len 14] / 1000 != mem[_10520 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10520 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) < 1000 * mem[_10520 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929) * mem[_10520 + 18 len 14] / (1000 * mem[_10520 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9201)) + (997 * _8929))
                            else:
                                if 997 * _8929 and mem[_9068 + 18 len 14] > -1 / 997 * _8929:
                                    revert with 'NH{q', 17
                                if not mem[_9068 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8929 * mem[_9068 + 18 len 14] / mem[_9068 + 18 len 14] != 997 * _8929:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9068 + 50 len 14] and 1000 > -1 / mem[_9068 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9068 + 50 len 14] / 1000 != mem[_9068 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9068 + 50 len 14] > (-997 * _8929) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9068 + 50 len 14]) + (997 * _8929) < 1000 * mem[_9068 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9068 + 50 len 14]) + (997 * _8929):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10953 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10953] == mem[_10953 + 18 len 14]
                                require mem[_10953 + 32] == mem[_10953 + 50 len 14]
                                require mem[_10953 + 64] == mem[_10953 + 92 len 4]
                                if 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10953 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10953 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) and 997 > -1 / 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) / 997 != 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10953 + 18 len 14]:
                                    if mem[_10953 + 50 len 14] and 1000 > -1 / mem[_10953 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10953 + 50 len 14] / 1000 != mem[_10953 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10953 + 50 len 14] > (-997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) < 1000 * mem[_10953 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929))
                                else:
                                    if 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) and mem[_10953 + 18 len 14] > -1 / 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                        revert with 'NH{q', 17
                                    if not mem[_10953 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) * mem[_10953 + 18 len 14] / mem[_10953 + 18 len 14] != 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10953 + 50 len 14] and 1000 > -1 / mem[_10953 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10953 + 50 len 14] / 1000 != mem[_10953 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10953 + 50 len 14] > (-997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)) < 1000 * mem[_10953 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929) * mem[_10953 + 18 len 14] / (1000 * mem[_10953 + 50 len 14]) + (997 * 997 * _8929 * Mask(112, 0, _9136) / (1000 * Mask(112, 0, _9201)) + (997 * _8929))
                else:
                    if 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) and mem[_7184 + 50 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                        revert with 'NH{q', 17
                    if not mem[_7184 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * mem[_7184 + 50 len 14] / mem[_7184 + 50 len 14] != 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7184 + 18 len 14] and 1000 > -1 / mem[_7184 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7184 + 18 len 14] / 1000 != mem[_7184 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7184 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) < 1000 * mem[_7184 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * mem[_7184 + 50 len 14] / (1000 * mem[_7184 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * Mask(112, 0, _7200) / (1000 * Mask(112, 0, _7191)) + (997 * 0 / (1000 * Mask(112, 0, _7087)) + (997 * _7065)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7430 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7442 = mem[_7430]
                    require mem[_7430] == mem[_7430]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7484 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7484] == mem[_7484 + 18 len 14]
                    require mem[_7484 + 32] == mem[_7484 + 50 len 14]
                    require mem[_7484 + 64] == mem[_7484 + 92 len 4]
                    if _7442 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7484 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7484 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7442 and 997 > -1 / _7442:
                        revert with 'NH{q', 17
                    if 997 * _7442 / 997 != _7442:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7484 + 50 len 14]:
                        if mem[_7484 + 18 len 14] and 1000 > -1 / mem[_7484 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7484 + 18 len 14] / 1000 != mem[_7484 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7484 + 18 len 14] > (-997 * _7442) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7484 + 18 len 14]) + (997 * _7442) < 1000 * mem[_7484 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7484 + 18 len 14]) + (997 * _7442):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7484 + 18 len 14]) + (997 * _7442)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7862 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7901 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7926 = mem[_7901]
                        require mem[_7901] == mem[_7901 + 18 len 14]
                        _7957 = mem[_7901 + 32]
                        require mem[_7901 + 32] == mem[_7901 + 50 len 14]
                        require mem[_7901 + 64] == mem[_7901 + 92 len 4]
                        if _7862 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7901 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7901 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7862 and 997 > -1 / _7862:
                            revert with 'NH{q', 17
                        if 997 * _7862 / 997 != _7862:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7901 + 18 len 14]:
                            if mem[_7901 + 50 len 14] and 1000 > -1 / mem[_7901 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7901 + 50 len 14] / 1000 != mem[_7901 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7901 + 50 len 14] > (-997 * _7862) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7901 + 50 len 14]) + (997 * _7862) < 1000 * mem[_7901 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7901 + 50 len 14]) + (997 * _7862):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7901 + 50 len 14]) + (997 * _7862)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7957)) + (997 * _7862))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8674 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8696 = mem[_8674]
                            require mem[_8674] == mem[_8674]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8828 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8895 = mem[_8828]
                            require mem[_8828] == mem[_8828 + 18 len 14]
                            _8976 = mem[_8828 + 32]
                            require mem[_8828 + 32] == mem[_8828 + 50 len 14]
                            require mem[_8828 + 64] == mem[_8828 + 92 len 4]
                            if _8696 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8828 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8828 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8696 and 997 > -1 / _8696:
                                revert with 'NH{q', 17
                            if 997 * _8696 / 997 != _8696:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8828 + 18 len 14]:
                                if mem[_8828 + 50 len 14] and 1000 > -1 / mem[_8828 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8828 + 50 len 14] / 1000 != mem[_8828 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8828 + 50 len 14] > (-997 * _8696) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8828 + 50 len 14]) + (997 * _8696) < 1000 * mem[_8828 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8828 + 50 len 14]) + (997 * _8696):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10163 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10163] == mem[_10163 + 18 len 14]
                                require mem[_10163 + 32] == mem[_10163 + 50 len 14]
                                require mem[_10163 + 64] == mem[_10163 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10163 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10163 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) / 997 != 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10163 + 18 len 14]:
                                    if mem[_10163 + 50 len 14] and 1000 > -1 / mem[_10163 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10163 + 50 len 14] / 1000 != mem[_10163 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10163 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) < 1000 * mem[_10163 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) and mem[_10163 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                        revert with 'NH{q', 17
                                    if not mem[_10163 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) * mem[_10163 + 18 len 14] / mem[_10163 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10163 + 50 len 14] and 1000 > -1 / mem[_10163 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10163 + 50 len 14] / 1000 != mem[_10163 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10163 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) < 1000 * mem[_10163 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696) * mem[_10163 + 18 len 14] / (1000 * mem[_10163 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8976)) + (997 * _8696))
                            else:
                                if 997 * _8696 and mem[_8828 + 18 len 14] > -1 / 997 * _8696:
                                    revert with 'NH{q', 17
                                if not mem[_8828 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8696 * mem[_8828 + 18 len 14] / mem[_8828 + 18 len 14] != 997 * _8696:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8828 + 50 len 14] and 1000 > -1 / mem[_8828 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8828 + 50 len 14] / 1000 != mem[_8828 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8828 + 50 len 14] > (-997 * _8696) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8828 + 50 len 14]) + (997 * _8696) < 1000 * mem[_8828 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8828 + 50 len 14]) + (997 * _8696):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10522 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10522] == mem[_10522 + 18 len 14]
                                require mem[_10522 + 32] == mem[_10522 + 50 len 14]
                                require mem[_10522 + 64] == mem[_10522 + 92 len 4]
                                if 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10522 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10522 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) and 997 > -1 / 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) / 997 != 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10522 + 18 len 14]:
                                    if mem[_10522 + 50 len 14] and 1000 > -1 / mem[_10522 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10522 + 50 len 14] / 1000 != mem[_10522 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10522 + 50 len 14] > (-997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) < 1000 * mem[_10522 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696))
                                else:
                                    if 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) and mem[_10522 + 18 len 14] > -1 / 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                        revert with 'NH{q', 17
                                    if not mem[_10522 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) * mem[_10522 + 18 len 14] / mem[_10522 + 18 len 14] != 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10522 + 50 len 14] and 1000 > -1 / mem[_10522 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10522 + 50 len 14] / 1000 != mem[_10522 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10522 + 50 len 14] > (-997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)) < 1000 * mem[_10522 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696) * mem[_10522 + 18 len 14] / (1000 * mem[_10522 + 50 len 14]) + (997 * 997 * _8696 * Mask(112, 0, _8895) / (1000 * Mask(112, 0, _8976)) + (997 * _8696))
                        else:
                            if 997 * _7862 and mem[_7901 + 18 len 14] > -1 / 997 * _7862:
                                revert with 'NH{q', 17
                            if not mem[_7901 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7862 * mem[_7901 + 18 len 14] / mem[_7901 + 18 len 14] != 997 * _7862:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7901 + 50 len 14] and 1000 > -1 / mem[_7901 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7901 + 50 len 14] / 1000 != mem[_7901 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7901 + 50 len 14] > (-997 * _7862) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7901 + 50 len 14]) + (997 * _7862) < 1000 * mem[_7901 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7901 + 50 len 14]) + (997 * _7862):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7862 * mem[_7901 + 18 len 14] / (1000 * mem[_7901 + 50 len 14]) + (997 * _7862)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7862 * Mask(112, 0, _7926) / (1000 * Mask(112, 0, _7957)) + (997 * _7862))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8896 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8930 = mem[_8896]
                            require mem[_8896] == mem[_8896]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9069 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9137 = mem[_9069]
                            require mem[_9069] == mem[_9069 + 18 len 14]
                            _9202 = mem[_9069 + 32]
                            require mem[_9069 + 32] == mem[_9069 + 50 len 14]
                            require mem[_9069 + 64] == mem[_9069 + 92 len 4]
                            if _8930 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9069 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9069 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8930 and 997 > -1 / _8930:
                                revert with 'NH{q', 17
                            if 997 * _8930 / 997 != _8930:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9069 + 18 len 14]:
                                if mem[_9069 + 50 len 14] and 1000 > -1 / mem[_9069 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9069 + 50 len 14] / 1000 != mem[_9069 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9069 + 50 len 14] > (-997 * _8930) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9069 + 50 len 14]) + (997 * _8930) < 1000 * mem[_9069 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9069 + 50 len 14]) + (997 * _8930):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10523 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10523] == mem[_10523 + 18 len 14]
                                require mem[_10523 + 32] == mem[_10523 + 50 len 14]
                                require mem[_10523 + 64] == mem[_10523 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10523 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10523 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) / 997 != 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10523 + 18 len 14]:
                                    if mem[_10523 + 50 len 14] and 1000 > -1 / mem[_10523 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10523 + 50 len 14] / 1000 != mem[_10523 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10523 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) < 1000 * mem[_10523 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) and mem[_10523 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                        revert with 'NH{q', 17
                                    if not mem[_10523 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) * mem[_10523 + 18 len 14] / mem[_10523 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10523 + 50 len 14] and 1000 > -1 / mem[_10523 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10523 + 50 len 14] / 1000 != mem[_10523 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10523 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) < 1000 * mem[_10523 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930) * mem[_10523 + 18 len 14] / (1000 * mem[_10523 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9202)) + (997 * _8930))
                            else:
                                if 997 * _8930 and mem[_9069 + 18 len 14] > -1 / 997 * _8930:
                                    revert with 'NH{q', 17
                                if not mem[_9069 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8930 * mem[_9069 + 18 len 14] / mem[_9069 + 18 len 14] != 997 * _8930:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9069 + 50 len 14] and 1000 > -1 / mem[_9069 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9069 + 50 len 14] / 1000 != mem[_9069 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9069 + 50 len 14] > (-997 * _8930) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9069 + 50 len 14]) + (997 * _8930) < 1000 * mem[_9069 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9069 + 50 len 14]) + (997 * _8930):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10954 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10954] == mem[_10954 + 18 len 14]
                                require mem[_10954 + 32] == mem[_10954 + 50 len 14]
                                require mem[_10954 + 64] == mem[_10954 + 92 len 4]
                                if 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10954 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10954 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) and 997 > -1 / 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) / 997 != 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10954 + 18 len 14]:
                                    if mem[_10954 + 50 len 14] and 1000 > -1 / mem[_10954 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10954 + 50 len 14] / 1000 != mem[_10954 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10954 + 50 len 14] > (-997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) < 1000 * mem[_10954 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930))
                                else:
                                    if 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) and mem[_10954 + 18 len 14] > -1 / 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                        revert with 'NH{q', 17
                                    if not mem[_10954 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) * mem[_10954 + 18 len 14] / mem[_10954 + 18 len 14] != 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10954 + 50 len 14] and 1000 > -1 / mem[_10954 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10954 + 50 len 14] / 1000 != mem[_10954 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10954 + 50 len 14] > (-997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)) < 1000 * mem[_10954 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930) * mem[_10954 + 18 len 14] / (1000 * mem[_10954 + 50 len 14]) + (997 * 997 * _8930 * Mask(112, 0, _9137) / (1000 * Mask(112, 0, _9202)) + (997 * _8930))
                    else:
                        if 997 * _7442 and mem[_7484 + 50 len 14] > -1 / 997 * _7442:
                            revert with 'NH{q', 17
                        if not mem[_7484 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7442 * mem[_7484 + 50 len 14] / mem[_7484 + 50 len 14] != 997 * _7442:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7484 + 18 len 14] and 1000 > -1 / mem[_7484 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7484 + 18 len 14] / 1000 != mem[_7484 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7484 + 18 len 14] > (-997 * _7442) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7484 + 18 len 14]) + (997 * _7442) < 1000 * mem[_7484 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7484 + 18 len 14]) + (997 * _7442):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7442 * mem[_7484 + 50 len 14] / (1000 * mem[_7484 + 18 len 14]) + (997 * _7442)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7997 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8042 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8073 = mem[_8042]
                        require mem[_8042] == mem[_8042 + 18 len 14]
                        _8098 = mem[_8042 + 32]
                        require mem[_8042 + 32] == mem[_8042 + 50 len 14]
                        require mem[_8042 + 64] == mem[_8042 + 92 len 4]
                        if _7997 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8042 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8042 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7997 and 997 > -1 / _7997:
                            revert with 'NH{q', 17
                        if 997 * _7997 / 997 != _7997:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8042 + 18 len 14]:
                            if mem[_8042 + 50 len 14] and 1000 > -1 / mem[_8042 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8042 + 50 len 14] / 1000 != mem[_8042 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8042 + 50 len 14] > (-997 * _7997) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8042 + 50 len 14]) + (997 * _7997) < 1000 * mem[_8042 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8042 + 50 len 14]) + (997 * _7997):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8042 + 50 len 14]) + (997 * _7997)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8098)) + (997 * _7997))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8897 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8931 = mem[_8897]
                            require mem[_8897] == mem[_8897]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9070 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9138 = mem[_9070]
                            require mem[_9070] == mem[_9070 + 18 len 14]
                            _9203 = mem[_9070 + 32]
                            require mem[_9070 + 32] == mem[_9070 + 50 len 14]
                            require mem[_9070 + 64] == mem[_9070 + 92 len 4]
                            if _8931 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9070 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9070 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8931 and 997 > -1 / _8931:
                                revert with 'NH{q', 17
                            if 997 * _8931 / 997 != _8931:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9070 + 18 len 14]:
                                if mem[_9070 + 50 len 14] and 1000 > -1 / mem[_9070 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9070 + 50 len 14] / 1000 != mem[_9070 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9070 + 50 len 14] > (-997 * _8931) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9070 + 50 len 14]) + (997 * _8931) < 1000 * mem[_9070 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9070 + 50 len 14]) + (997 * _8931):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10525 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10525] == mem[_10525 + 18 len 14]
                                require mem[_10525 + 32] == mem[_10525 + 50 len 14]
                                require mem[_10525 + 64] == mem[_10525 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10525 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10525 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) / 997 != 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10525 + 18 len 14]:
                                    if mem[_10525 + 50 len 14] and 1000 > -1 / mem[_10525 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10525 + 50 len 14] / 1000 != mem[_10525 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10525 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) < 1000 * mem[_10525 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) and mem[_10525 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                        revert with 'NH{q', 17
                                    if not mem[_10525 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) * mem[_10525 + 18 len 14] / mem[_10525 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10525 + 50 len 14] and 1000 > -1 / mem[_10525 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10525 + 50 len 14] / 1000 != mem[_10525 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10525 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) < 1000 * mem[_10525 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931) * mem[_10525 + 18 len 14] / (1000 * mem[_10525 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9203)) + (997 * _8931))
                            else:
                                if 997 * _8931 and mem[_9070 + 18 len 14] > -1 / 997 * _8931:
                                    revert with 'NH{q', 17
                                if not mem[_9070 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8931 * mem[_9070 + 18 len 14] / mem[_9070 + 18 len 14] != 997 * _8931:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9070 + 50 len 14] and 1000 > -1 / mem[_9070 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9070 + 50 len 14] / 1000 != mem[_9070 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9070 + 50 len 14] > (-997 * _8931) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9070 + 50 len 14]) + (997 * _8931) < 1000 * mem[_9070 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9070 + 50 len 14]) + (997 * _8931):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10955 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10955] == mem[_10955 + 18 len 14]
                                require mem[_10955 + 32] == mem[_10955 + 50 len 14]
                                require mem[_10955 + 64] == mem[_10955 + 92 len 4]
                                if 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10955 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10955 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) and 997 > -1 / 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) / 997 != 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10955 + 18 len 14]:
                                    if mem[_10955 + 50 len 14] and 1000 > -1 / mem[_10955 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10955 + 50 len 14] / 1000 != mem[_10955 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10955 + 50 len 14] > (-997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) < 1000 * mem[_10955 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931))
                                else:
                                    if 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) and mem[_10955 + 18 len 14] > -1 / 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                        revert with 'NH{q', 17
                                    if not mem[_10955 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) * mem[_10955 + 18 len 14] / mem[_10955 + 18 len 14] != 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10955 + 50 len 14] and 1000 > -1 / mem[_10955 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10955 + 50 len 14] / 1000 != mem[_10955 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10955 + 50 len 14] > (-997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)) < 1000 * mem[_10955 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931) * mem[_10955 + 18 len 14] / (1000 * mem[_10955 + 50 len 14]) + (997 * 997 * _8931 * Mask(112, 0, _9138) / (1000 * Mask(112, 0, _9203)) + (997 * _8931))
                        else:
                            if 997 * _7997 and mem[_8042 + 18 len 14] > -1 / 997 * _7997:
                                revert with 'NH{q', 17
                            if not mem[_8042 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7997 * mem[_8042 + 18 len 14] / mem[_8042 + 18 len 14] != 997 * _7997:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8042 + 50 len 14] and 1000 > -1 / mem[_8042 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8042 + 50 len 14] / 1000 != mem[_8042 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8042 + 50 len 14] > (-997 * _7997) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8042 + 50 len 14]) + (997 * _7997) < 1000 * mem[_8042 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8042 + 50 len 14]) + (997 * _7997):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7997 * mem[_8042 + 18 len 14] / (1000 * mem[_8042 + 50 len 14]) + (997 * _7997)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7997 * Mask(112, 0, _8073) / (1000 * Mask(112, 0, _8098)) + (997 * _7997))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9139 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9178 = mem[_9139]
                            require mem[_9139] == mem[_9139]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9306 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9371 = mem[_9306]
                            require mem[_9306] == mem[_9306 + 18 len 14]
                            _9430 = mem[_9306 + 32]
                            require mem[_9306 + 32] == mem[_9306 + 50 len 14]
                            require mem[_9306 + 64] == mem[_9306 + 92 len 4]
                            if _9178 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9306 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9306 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9178 and 997 > -1 / _9178:
                                revert with 'NH{q', 17
                            if 997 * _9178 / 997 != _9178:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9306 + 18 len 14]:
                                if mem[_9306 + 50 len 14] and 1000 > -1 / mem[_9306 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9306 + 50 len 14] / 1000 != mem[_9306 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9306 + 50 len 14] > (-997 * _9178) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9306 + 50 len 14]) + (997 * _9178) < 1000 * mem[_9306 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9306 + 50 len 14]) + (997 * _9178):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10956 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10956] == mem[_10956 + 18 len 14]
                                require mem[_10956 + 32] == mem[_10956 + 50 len 14]
                                require mem[_10956 + 64] == mem[_10956 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10956 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10956 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) / 997 != 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10956 + 18 len 14]:
                                    if mem[_10956 + 50 len 14] and 1000 > -1 / mem[_10956 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10956 + 50 len 14] / 1000 != mem[_10956 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10956 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) < 1000 * mem[_10956 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) and mem[_10956 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                        revert with 'NH{q', 17
                                    if not mem[_10956 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) * mem[_10956 + 18 len 14] / mem[_10956 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10956 + 50 len 14] and 1000 > -1 / mem[_10956 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10956 + 50 len 14] / 1000 != mem[_10956 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10956 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) < 1000 * mem[_10956 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178) * mem[_10956 + 18 len 14] / (1000 * mem[_10956 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9430)) + (997 * _9178))
                            else:
                                if 997 * _9178 and mem[_9306 + 18 len 14] > -1 / 997 * _9178:
                                    revert with 'NH{q', 17
                                if not mem[_9306 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9178 * mem[_9306 + 18 len 14] / mem[_9306 + 18 len 14] != 997 * _9178:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9306 + 50 len 14] and 1000 > -1 / mem[_9306 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9306 + 50 len 14] / 1000 != mem[_9306 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9306 + 50 len 14] > (-997 * _9178) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9306 + 50 len 14]) + (997 * _9178) < 1000 * mem[_9306 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9306 + 50 len 14]) + (997 * _9178):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11396 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11396] == mem[_11396 + 18 len 14]
                                require mem[_11396 + 32] == mem[_11396 + 50 len 14]
                                require mem[_11396 + 64] == mem[_11396 + 92 len 4]
                                if 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11396 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11396 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) and 997 > -1 / 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) / 997 != 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11396 + 18 len 14]:
                                    if mem[_11396 + 50 len 14] and 1000 > -1 / mem[_11396 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11396 + 50 len 14] / 1000 != mem[_11396 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11396 + 50 len 14] > (-997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) < 1000 * mem[_11396 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178))
                                else:
                                    if 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) and mem[_11396 + 18 len 14] > -1 / 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                        revert with 'NH{q', 17
                                    if not mem[_11396 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) * mem[_11396 + 18 len 14] / mem[_11396 + 18 len 14] != 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11396 + 50 len 14] and 1000 > -1 / mem[_11396 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11396 + 50 len 14] / 1000 != mem[_11396 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11396 + 50 len 14] > (-997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)) < 1000 * mem[_11396 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178) * mem[_11396 + 18 len 14] / (1000 * mem[_11396 + 50 len 14]) + (997 * 997 * _9178 * Mask(112, 0, _9371) / (1000 * Mask(112, 0, _9430)) + (997 * _9178))
            else:
                if 997 * _7065 and mem[_7081 + 50 len 14] > -1 / 997 * _7065:
                    revert with 'NH{q', 17
                if not mem[_7081 + 50 len 14]:
                    revert with 'NH{q', 18
                if 997 * _7065 * mem[_7081 + 50 len 14] / mem[_7081 + 50 len 14] != 997 * _7065:
                    revert with 0, 'ds-math-mul-overflow'
                if mem[_7081 + 18 len 14] and 1000 > -1 / mem[_7081 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7081 + 18 len 14] / 1000 != mem[_7081 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7081 + 18 len 14] > (-997 * _7065) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7081 + 18 len 14]) + (997 * _7065) < 1000 * mem[_7081 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7081 + 18 len 14]) + (997 * _7065):
                    revert with 'NH{q', 18
                require ext_code.size(stor14)
                staticcall stor14.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7215 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7223 = mem[_7215]
                require mem[_7215] == mem[_7215 + 18 len 14]
                _7227 = mem[_7215 + 32]
                require mem[_7215 + 32] == mem[_7215 + 50 len 14]
                require mem[_7215 + 64] == mem[_7215 + 92 len 4]
                if 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7215 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7215 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) and 997 > -1 / 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                    revert with 'NH{q', 17
                if 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) / 997 != 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7215 + 50 len 14]:
                    if mem[_7215 + 18 len 14] and 1000 > -1 / mem[_7215 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7215 + 18 len 14] / 1000 != mem[_7215 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7215 + 18 len 14] > (-997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) < 1000 * mem[_7215 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 0 / (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (0 / (1000 * Mask(112, 0, _7223)) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7431 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7443 = mem[_7431]
                    require mem[_7431] == mem[_7431]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7485 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7485] == mem[_7485 + 18 len 14]
                    require mem[_7485 + 32] == mem[_7485 + 50 len 14]
                    require mem[_7485 + 64] == mem[_7485 + 92 len 4]
                    if _7443 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7485 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7485 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7443 and 997 > -1 / _7443:
                        revert with 'NH{q', 17
                    if 997 * _7443 / 997 != _7443:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7485 + 50 len 14]:
                        if mem[_7485 + 18 len 14] and 1000 > -1 / mem[_7485 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7485 + 18 len 14] / 1000 != mem[_7485 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7485 + 18 len 14] > (-997 * _7443) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7485 + 18 len 14]) + (997 * _7443) < 1000 * mem[_7485 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7485 + 18 len 14]) + (997 * _7443):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7485 + 18 len 14]) + (997 * _7443)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7863 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7903 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7927 = mem[_7903]
                        require mem[_7903] == mem[_7903 + 18 len 14]
                        _7959 = mem[_7903 + 32]
                        require mem[_7903 + 32] == mem[_7903 + 50 len 14]
                        require mem[_7903 + 64] == mem[_7903 + 92 len 4]
                        if _7863 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7903 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7903 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7863 and 997 > -1 / _7863:
                            revert with 'NH{q', 17
                        if 997 * _7863 / 997 != _7863:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7903 + 18 len 14]:
                            if mem[_7903 + 50 len 14] and 1000 > -1 / mem[_7903 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7903 + 50 len 14] / 1000 != mem[_7903 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7903 + 50 len 14] > (-997 * _7863) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7903 + 50 len 14]) + (997 * _7863) < 1000 * mem[_7903 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7903 + 50 len 14]) + (997 * _7863):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7903 + 50 len 14]) + (997 * _7863)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7959)) + (997 * _7863))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8675 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8698 = mem[_8675]
                            require mem[_8675] == mem[_8675]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8829 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8898 = mem[_8829]
                            require mem[_8829] == mem[_8829 + 18 len 14]
                            _8978 = mem[_8829 + 32]
                            require mem[_8829 + 32] == mem[_8829 + 50 len 14]
                            require mem[_8829 + 64] == mem[_8829 + 92 len 4]
                            if _8698 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8829 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8829 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8698 and 997 > -1 / _8698:
                                revert with 'NH{q', 17
                            if 997 * _8698 / 997 != _8698:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8829 + 18 len 14]:
                                if mem[_8829 + 50 len 14] and 1000 > -1 / mem[_8829 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8829 + 50 len 14] / 1000 != mem[_8829 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8829 + 50 len 14] > (-997 * _8698) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8829 + 50 len 14]) + (997 * _8698) < 1000 * mem[_8829 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8829 + 50 len 14]) + (997 * _8698):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10167 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10167] == mem[_10167 + 18 len 14]
                                require mem[_10167 + 32] == mem[_10167 + 50 len 14]
                                require mem[_10167 + 64] == mem[_10167 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10167 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10167 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) / 997 != 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10167 + 18 len 14]:
                                    if mem[_10167 + 50 len 14] and 1000 > -1 / mem[_10167 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10167 + 50 len 14] / 1000 != mem[_10167 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10167 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) < 1000 * mem[_10167 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) and mem[_10167 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                        revert with 'NH{q', 17
                                    if not mem[_10167 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) * mem[_10167 + 18 len 14] / mem[_10167 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10167 + 50 len 14] and 1000 > -1 / mem[_10167 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10167 + 50 len 14] / 1000 != mem[_10167 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10167 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) < 1000 * mem[_10167 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698) * mem[_10167 + 18 len 14] / (1000 * mem[_10167 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8978)) + (997 * _8698))
                            else:
                                if 997 * _8698 and mem[_8829 + 18 len 14] > -1 / 997 * _8698:
                                    revert with 'NH{q', 17
                                if not mem[_8829 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8698 * mem[_8829 + 18 len 14] / mem[_8829 + 18 len 14] != 997 * _8698:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8829 + 50 len 14] and 1000 > -1 / mem[_8829 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8829 + 50 len 14] / 1000 != mem[_8829 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8829 + 50 len 14] > (-997 * _8698) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8829 + 50 len 14]) + (997 * _8698) < 1000 * mem[_8829 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8829 + 50 len 14]) + (997 * _8698):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10528 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10528] == mem[_10528 + 18 len 14]
                                require mem[_10528 + 32] == mem[_10528 + 50 len 14]
                                require mem[_10528 + 64] == mem[_10528 + 92 len 4]
                                if 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10528 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10528 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) and 997 > -1 / 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) / 997 != 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10528 + 18 len 14]:
                                    if mem[_10528 + 50 len 14] and 1000 > -1 / mem[_10528 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10528 + 50 len 14] / 1000 != mem[_10528 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10528 + 50 len 14] > (-997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) < 1000 * mem[_10528 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698))
                                else:
                                    if 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) and mem[_10528 + 18 len 14] > -1 / 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                        revert with 'NH{q', 17
                                    if not mem[_10528 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) * mem[_10528 + 18 len 14] / mem[_10528 + 18 len 14] != 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10528 + 50 len 14] and 1000 > -1 / mem[_10528 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10528 + 50 len 14] / 1000 != mem[_10528 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10528 + 50 len 14] > (-997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)) < 1000 * mem[_10528 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698) * mem[_10528 + 18 len 14] / (1000 * mem[_10528 + 50 len 14]) + (997 * 997 * _8698 * Mask(112, 0, _8898) / (1000 * Mask(112, 0, _8978)) + (997 * _8698))
                        else:
                            if 997 * _7863 and mem[_7903 + 18 len 14] > -1 / 997 * _7863:
                                revert with 'NH{q', 17
                            if not mem[_7903 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7863 * mem[_7903 + 18 len 14] / mem[_7903 + 18 len 14] != 997 * _7863:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7903 + 50 len 14] and 1000 > -1 / mem[_7903 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7903 + 50 len 14] / 1000 != mem[_7903 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7903 + 50 len 14] > (-997 * _7863) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7903 + 50 len 14]) + (997 * _7863) < 1000 * mem[_7903 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7903 + 50 len 14]) + (997 * _7863):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7863 * mem[_7903 + 18 len 14] / (1000 * mem[_7903 + 50 len 14]) + (997 * _7863)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7863 * Mask(112, 0, _7927) / (1000 * Mask(112, 0, _7959)) + (997 * _7863))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8899 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8932 = mem[_8899]
                            require mem[_8899] == mem[_8899]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9071 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9140 = mem[_9071]
                            require mem[_9071] == mem[_9071 + 18 len 14]
                            _9204 = mem[_9071 + 32]
                            require mem[_9071 + 32] == mem[_9071 + 50 len 14]
                            require mem[_9071 + 64] == mem[_9071 + 92 len 4]
                            if _8932 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9071 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9071 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8932 and 997 > -1 / _8932:
                                revert with 'NH{q', 17
                            if 997 * _8932 / 997 != _8932:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9071 + 18 len 14]:
                                if mem[_9071 + 50 len 14] and 1000 > -1 / mem[_9071 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9071 + 50 len 14] / 1000 != mem[_9071 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9071 + 50 len 14] > (-997 * _8932) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9071 + 50 len 14]) + (997 * _8932) < 1000 * mem[_9071 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9071 + 50 len 14]) + (997 * _8932):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10529 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10529] == mem[_10529 + 18 len 14]
                                require mem[_10529 + 32] == mem[_10529 + 50 len 14]
                                require mem[_10529 + 64] == mem[_10529 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10529 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10529 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) / 997 != 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10529 + 18 len 14]:
                                    if mem[_10529 + 50 len 14] and 1000 > -1 / mem[_10529 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10529 + 50 len 14] / 1000 != mem[_10529 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10529 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) < 1000 * mem[_10529 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) and mem[_10529 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                        revert with 'NH{q', 17
                                    if not mem[_10529 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) * mem[_10529 + 18 len 14] / mem[_10529 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10529 + 50 len 14] and 1000 > -1 / mem[_10529 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10529 + 50 len 14] / 1000 != mem[_10529 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10529 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) < 1000 * mem[_10529 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932) * mem[_10529 + 18 len 14] / (1000 * mem[_10529 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9204)) + (997 * _8932))
                            else:
                                if 997 * _8932 and mem[_9071 + 18 len 14] > -1 / 997 * _8932:
                                    revert with 'NH{q', 17
                                if not mem[_9071 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8932 * mem[_9071 + 18 len 14] / mem[_9071 + 18 len 14] != 997 * _8932:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9071 + 50 len 14] and 1000 > -1 / mem[_9071 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9071 + 50 len 14] / 1000 != mem[_9071 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9071 + 50 len 14] > (-997 * _8932) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9071 + 50 len 14]) + (997 * _8932) < 1000 * mem[_9071 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9071 + 50 len 14]) + (997 * _8932):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10958 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10958] == mem[_10958 + 18 len 14]
                                require mem[_10958 + 32] == mem[_10958 + 50 len 14]
                                require mem[_10958 + 64] == mem[_10958 + 92 len 4]
                                if 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10958 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10958 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) and 997 > -1 / 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) / 997 != 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10958 + 18 len 14]:
                                    if mem[_10958 + 50 len 14] and 1000 > -1 / mem[_10958 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10958 + 50 len 14] / 1000 != mem[_10958 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10958 + 50 len 14] > (-997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) < 1000 * mem[_10958 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932))
                                else:
                                    if 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) and mem[_10958 + 18 len 14] > -1 / 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                        revert with 'NH{q', 17
                                    if not mem[_10958 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) * mem[_10958 + 18 len 14] / mem[_10958 + 18 len 14] != 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10958 + 50 len 14] and 1000 > -1 / mem[_10958 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10958 + 50 len 14] / 1000 != mem[_10958 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10958 + 50 len 14] > (-997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)) < 1000 * mem[_10958 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932) * mem[_10958 + 18 len 14] / (1000 * mem[_10958 + 50 len 14]) + (997 * 997 * _8932 * Mask(112, 0, _9140) / (1000 * Mask(112, 0, _9204)) + (997 * _8932))
                    else:
                        if 997 * _7443 and mem[_7485 + 50 len 14] > -1 / 997 * _7443:
                            revert with 'NH{q', 17
                        if not mem[_7485 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7443 * mem[_7485 + 50 len 14] / mem[_7485 + 50 len 14] != 997 * _7443:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7485 + 18 len 14] and 1000 > -1 / mem[_7485 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7485 + 18 len 14] / 1000 != mem[_7485 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7485 + 18 len 14] > (-997 * _7443) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7485 + 18 len 14]) + (997 * _7443) < 1000 * mem[_7485 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7485 + 18 len 14]) + (997 * _7443):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7443 * mem[_7485 + 50 len 14] / (1000 * mem[_7485 + 18 len 14]) + (997 * _7443)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7998 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8043 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8074 = mem[_8043]
                        require mem[_8043] == mem[_8043 + 18 len 14]
                        _8099 = mem[_8043 + 32]
                        require mem[_8043 + 32] == mem[_8043 + 50 len 14]
                        require mem[_8043 + 64] == mem[_8043 + 92 len 4]
                        if _7998 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8043 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8043 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7998 and 997 > -1 / _7998:
                            revert with 'NH{q', 17
                        if 997 * _7998 / 997 != _7998:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8043 + 18 len 14]:
                            if mem[_8043 + 50 len 14] and 1000 > -1 / mem[_8043 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8043 + 50 len 14] / 1000 != mem[_8043 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8043 + 50 len 14] > (-997 * _7998) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8043 + 50 len 14]) + (997 * _7998) < 1000 * mem[_8043 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8043 + 50 len 14]) + (997 * _7998):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8043 + 50 len 14]) + (997 * _7998)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8099)) + (997 * _7998))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8900 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8933 = mem[_8900]
                            require mem[_8900] == mem[_8900]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9072 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9141 = mem[_9072]
                            require mem[_9072] == mem[_9072 + 18 len 14]
                            _9205 = mem[_9072 + 32]
                            require mem[_9072 + 32] == mem[_9072 + 50 len 14]
                            require mem[_9072 + 64] == mem[_9072 + 92 len 4]
                            if _8933 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9072 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9072 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8933 and 997 > -1 / _8933:
                                revert with 'NH{q', 17
                            if 997 * _8933 / 997 != _8933:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9072 + 18 len 14]:
                                if mem[_9072 + 50 len 14] and 1000 > -1 / mem[_9072 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9072 + 50 len 14] / 1000 != mem[_9072 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9072 + 50 len 14] > (-997 * _8933) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9072 + 50 len 14]) + (997 * _8933) < 1000 * mem[_9072 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9072 + 50 len 14]) + (997 * _8933):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10531 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10531] == mem[_10531 + 18 len 14]
                                require mem[_10531 + 32] == mem[_10531 + 50 len 14]
                                require mem[_10531 + 64] == mem[_10531 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10531 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10531 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) / 997 != 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10531 + 18 len 14]:
                                    if mem[_10531 + 50 len 14] and 1000 > -1 / mem[_10531 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10531 + 50 len 14] / 1000 != mem[_10531 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10531 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) < 1000 * mem[_10531 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) and mem[_10531 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                        revert with 'NH{q', 17
                                    if not mem[_10531 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) * mem[_10531 + 18 len 14] / mem[_10531 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10531 + 50 len 14] and 1000 > -1 / mem[_10531 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10531 + 50 len 14] / 1000 != mem[_10531 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10531 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) < 1000 * mem[_10531 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933) * mem[_10531 + 18 len 14] / (1000 * mem[_10531 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9205)) + (997 * _8933))
                            else:
                                if 997 * _8933 and mem[_9072 + 18 len 14] > -1 / 997 * _8933:
                                    revert with 'NH{q', 17
                                if not mem[_9072 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8933 * mem[_9072 + 18 len 14] / mem[_9072 + 18 len 14] != 997 * _8933:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9072 + 50 len 14] and 1000 > -1 / mem[_9072 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9072 + 50 len 14] / 1000 != mem[_9072 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9072 + 50 len 14] > (-997 * _8933) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9072 + 50 len 14]) + (997 * _8933) < 1000 * mem[_9072 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9072 + 50 len 14]) + (997 * _8933):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10959 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10959] == mem[_10959 + 18 len 14]
                                require mem[_10959 + 32] == mem[_10959 + 50 len 14]
                                require mem[_10959 + 64] == mem[_10959 + 92 len 4]
                                if 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10959 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10959 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) and 997 > -1 / 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) / 997 != 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10959 + 18 len 14]:
                                    if mem[_10959 + 50 len 14] and 1000 > -1 / mem[_10959 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10959 + 50 len 14] / 1000 != mem[_10959 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10959 + 50 len 14] > (-997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) < 1000 * mem[_10959 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933))
                                else:
                                    if 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) and mem[_10959 + 18 len 14] > -1 / 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                        revert with 'NH{q', 17
                                    if not mem[_10959 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) * mem[_10959 + 18 len 14] / mem[_10959 + 18 len 14] != 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10959 + 50 len 14] and 1000 > -1 / mem[_10959 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10959 + 50 len 14] / 1000 != mem[_10959 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10959 + 50 len 14] > (-997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)) < 1000 * mem[_10959 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933) * mem[_10959 + 18 len 14] / (1000 * mem[_10959 + 50 len 14]) + (997 * 997 * _8933 * Mask(112, 0, _9141) / (1000 * Mask(112, 0, _9205)) + (997 * _8933))
                        else:
                            if 997 * _7998 and mem[_8043 + 18 len 14] > -1 / 997 * _7998:
                                revert with 'NH{q', 17
                            if not mem[_8043 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7998 * mem[_8043 + 18 len 14] / mem[_8043 + 18 len 14] != 997 * _7998:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8043 + 50 len 14] and 1000 > -1 / mem[_8043 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8043 + 50 len 14] / 1000 != mem[_8043 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8043 + 50 len 14] > (-997 * _7998) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8043 + 50 len 14]) + (997 * _7998) < 1000 * mem[_8043 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8043 + 50 len 14]) + (997 * _7998):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7998 * mem[_8043 + 18 len 14] / (1000 * mem[_8043 + 50 len 14]) + (997 * _7998)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7998 * Mask(112, 0, _8074) / (1000 * Mask(112, 0, _8099)) + (997 * _7998))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9142 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9179 = mem[_9142]
                            require mem[_9142] == mem[_9142]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9307 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9372 = mem[_9307]
                            require mem[_9307] == mem[_9307 + 18 len 14]
                            _9431 = mem[_9307 + 32]
                            require mem[_9307 + 32] == mem[_9307 + 50 len 14]
                            require mem[_9307 + 64] == mem[_9307 + 92 len 4]
                            if _9179 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9307 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9307 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9179 and 997 > -1 / _9179:
                                revert with 'NH{q', 17
                            if 997 * _9179 / 997 != _9179:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9307 + 18 len 14]:
                                if mem[_9307 + 50 len 14] and 1000 > -1 / mem[_9307 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9307 + 50 len 14] / 1000 != mem[_9307 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9307 + 50 len 14] > (-997 * _9179) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9307 + 50 len 14]) + (997 * _9179) < 1000 * mem[_9307 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9307 + 50 len 14]) + (997 * _9179):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10960 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10960] == mem[_10960 + 18 len 14]
                                require mem[_10960 + 32] == mem[_10960 + 50 len 14]
                                require mem[_10960 + 64] == mem[_10960 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10960 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10960 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) / 997 != 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10960 + 18 len 14]:
                                    if mem[_10960 + 50 len 14] and 1000 > -1 / mem[_10960 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10960 + 50 len 14] / 1000 != mem[_10960 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10960 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) < 1000 * mem[_10960 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) and mem[_10960 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                        revert with 'NH{q', 17
                                    if not mem[_10960 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) * mem[_10960 + 18 len 14] / mem[_10960 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10960 + 50 len 14] and 1000 > -1 / mem[_10960 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10960 + 50 len 14] / 1000 != mem[_10960 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10960 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) < 1000 * mem[_10960 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179) * mem[_10960 + 18 len 14] / (1000 * mem[_10960 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9431)) + (997 * _9179))
                            else:
                                if 997 * _9179 and mem[_9307 + 18 len 14] > -1 / 997 * _9179:
                                    revert with 'NH{q', 17
                                if not mem[_9307 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9179 * mem[_9307 + 18 len 14] / mem[_9307 + 18 len 14] != 997 * _9179:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9307 + 50 len 14] and 1000 > -1 / mem[_9307 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9307 + 50 len 14] / 1000 != mem[_9307 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9307 + 50 len 14] > (-997 * _9179) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9307 + 50 len 14]) + (997 * _9179) < 1000 * mem[_9307 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9307 + 50 len 14]) + (997 * _9179):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11397 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11397] == mem[_11397 + 18 len 14]
                                require mem[_11397 + 32] == mem[_11397 + 50 len 14]
                                require mem[_11397 + 64] == mem[_11397 + 92 len 4]
                                if 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11397 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11397 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) and 997 > -1 / 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) / 997 != 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11397 + 18 len 14]:
                                    if mem[_11397 + 50 len 14] and 1000 > -1 / mem[_11397 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11397 + 50 len 14] / 1000 != mem[_11397 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11397 + 50 len 14] > (-997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) < 1000 * mem[_11397 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179))
                                else:
                                    if 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) and mem[_11397 + 18 len 14] > -1 / 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                        revert with 'NH{q', 17
                                    if not mem[_11397 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) * mem[_11397 + 18 len 14] / mem[_11397 + 18 len 14] != 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11397 + 50 len 14] and 1000 > -1 / mem[_11397 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11397 + 50 len 14] / 1000 != mem[_11397 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11397 + 50 len 14] > (-997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)) < 1000 * mem[_11397 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179) * mem[_11397 + 18 len 14] / (1000 * mem[_11397 + 50 len 14]) + (997 * 997 * _9179 * Mask(112, 0, _9372) / (1000 * Mask(112, 0, _9431)) + (997 * _9179))
                else:
                    if 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) and mem[_7215 + 50 len 14] > -1 / 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                        revert with 'NH{q', 17
                    if not mem[_7215 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * mem[_7215 + 50 len 14] / mem[_7215 + 50 len 14] != 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065):
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7215 + 18 len 14] and 1000 > -1 / mem[_7215 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7215 + 18 len 14] / 1000 != mem[_7215 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7215 + 18 len 14] > (-997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)) < 1000 * mem[_7215 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * mem[_7215 + 50 len 14] / (1000 * mem[_7215 + 18 len 14]) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065) * Mask(112, 0, _7227) / (1000 * Mask(112, 0, _7223)) + (997 * 997 * _7065 * Mask(112, 0, _7097) / (1000 * Mask(112, 0, _7087)) + (997 * _7065)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7503 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7511 = mem[_7503]
                    require mem[_7503] == mem[_7503]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7543 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7543] == mem[_7543 + 18 len 14]
                    require mem[_7543 + 32] == mem[_7543 + 50 len 14]
                    require mem[_7543 + 64] == mem[_7543 + 92 len 4]
                    if _7511 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7543 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7543 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7511 and 997 > -1 / _7511:
                        revert with 'NH{q', 17
                    if 997 * _7511 / 997 != _7511:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7543 + 50 len 14]:
                        if mem[_7543 + 18 len 14] and 1000 > -1 / mem[_7543 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7543 + 18 len 14] / 1000 != mem[_7543 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7543 + 18 len 14] > (-997 * _7511) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7543 + 18 len 14]) + (997 * _7511) < 1000 * mem[_7543 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7543 + 18 len 14]) + (997 * _7511):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7543 + 18 len 14]) + (997 * _7511)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7999 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8044 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8075 = mem[_8044]
                        require mem[_8044] == mem[_8044 + 18 len 14]
                        _8100 = mem[_8044 + 32]
                        require mem[_8044 + 32] == mem[_8044 + 50 len 14]
                        require mem[_8044 + 64] == mem[_8044 + 92 len 4]
                        if _7999 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8044 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8044 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7999 and 997 > -1 / _7999:
                            revert with 'NH{q', 17
                        if 997 * _7999 / 997 != _7999:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8044 + 18 len 14]:
                            if mem[_8044 + 50 len 14] and 1000 > -1 / mem[_8044 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8044 + 50 len 14] / 1000 != mem[_8044 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8044 + 50 len 14] > (-997 * _7999) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8044 + 50 len 14]) + (997 * _7999) < 1000 * mem[_8044 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8044 + 50 len 14]) + (997 * _7999):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8044 + 50 len 14]) + (997 * _7999)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8100)) + (997 * _7999))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8901 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8934 = mem[_8901]
                            require mem[_8901] == mem[_8901]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9073 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9143 = mem[_9073]
                            require mem[_9073] == mem[_9073 + 18 len 14]
                            _9206 = mem[_9073 + 32]
                            require mem[_9073 + 32] == mem[_9073 + 50 len 14]
                            require mem[_9073 + 64] == mem[_9073 + 92 len 4]
                            if _8934 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9073 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9073 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8934 and 997 > -1 / _8934:
                                revert with 'NH{q', 17
                            if 997 * _8934 / 997 != _8934:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9073 + 18 len 14]:
                                if mem[_9073 + 50 len 14] and 1000 > -1 / mem[_9073 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9073 + 50 len 14] / 1000 != mem[_9073 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9073 + 50 len 14] > (-997 * _8934) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9073 + 50 len 14]) + (997 * _8934) < 1000 * mem[_9073 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9073 + 50 len 14]) + (997 * _8934):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10534 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10534] == mem[_10534 + 18 len 14]
                                require mem[_10534 + 32] == mem[_10534 + 50 len 14]
                                require mem[_10534 + 64] == mem[_10534 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10534 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10534 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) / 997 != 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10534 + 18 len 14]:
                                    if mem[_10534 + 50 len 14] and 1000 > -1 / mem[_10534 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10534 + 50 len 14] / 1000 != mem[_10534 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10534 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) < 1000 * mem[_10534 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) and mem[_10534 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                        revert with 'NH{q', 17
                                    if not mem[_10534 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) * mem[_10534 + 18 len 14] / mem[_10534 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10534 + 50 len 14] and 1000 > -1 / mem[_10534 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10534 + 50 len 14] / 1000 != mem[_10534 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10534 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) < 1000 * mem[_10534 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934) * mem[_10534 + 18 len 14] / (1000 * mem[_10534 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9206)) + (997 * _8934))
                            else:
                                if 997 * _8934 and mem[_9073 + 18 len 14] > -1 / 997 * _8934:
                                    revert with 'NH{q', 17
                                if not mem[_9073 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8934 * mem[_9073 + 18 len 14] / mem[_9073 + 18 len 14] != 997 * _8934:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9073 + 50 len 14] and 1000 > -1 / mem[_9073 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9073 + 50 len 14] / 1000 != mem[_9073 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9073 + 50 len 14] > (-997 * _8934) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9073 + 50 len 14]) + (997 * _8934) < 1000 * mem[_9073 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9073 + 50 len 14]) + (997 * _8934):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10962 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10962] == mem[_10962 + 18 len 14]
                                require mem[_10962 + 32] == mem[_10962 + 50 len 14]
                                require mem[_10962 + 64] == mem[_10962 + 92 len 4]
                                if 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10962 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10962 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) and 997 > -1 / 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) / 997 != 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10962 + 18 len 14]:
                                    if mem[_10962 + 50 len 14] and 1000 > -1 / mem[_10962 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10962 + 50 len 14] / 1000 != mem[_10962 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10962 + 50 len 14] > (-997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) < 1000 * mem[_10962 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934))
                                else:
                                    if 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) and mem[_10962 + 18 len 14] > -1 / 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                        revert with 'NH{q', 17
                                    if not mem[_10962 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) * mem[_10962 + 18 len 14] / mem[_10962 + 18 len 14] != 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10962 + 50 len 14] and 1000 > -1 / mem[_10962 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10962 + 50 len 14] / 1000 != mem[_10962 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10962 + 50 len 14] > (-997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)) < 1000 * mem[_10962 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934) * mem[_10962 + 18 len 14] / (1000 * mem[_10962 + 50 len 14]) + (997 * 997 * _8934 * Mask(112, 0, _9143) / (1000 * Mask(112, 0, _9206)) + (997 * _8934))
                        else:
                            if 997 * _7999 and mem[_8044 + 18 len 14] > -1 / 997 * _7999:
                                revert with 'NH{q', 17
                            if not mem[_8044 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7999 * mem[_8044 + 18 len 14] / mem[_8044 + 18 len 14] != 997 * _7999:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8044 + 50 len 14] and 1000 > -1 / mem[_8044 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8044 + 50 len 14] / 1000 != mem[_8044 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8044 + 50 len 14] > (-997 * _7999) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8044 + 50 len 14]) + (997 * _7999) < 1000 * mem[_8044 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8044 + 50 len 14]) + (997 * _7999):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7999 * mem[_8044 + 18 len 14] / (1000 * mem[_8044 + 50 len 14]) + (997 * _7999)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7999 * Mask(112, 0, _8075) / (1000 * Mask(112, 0, _8100)) + (997 * _7999))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9144 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9180 = mem[_9144]
                            require mem[_9144] == mem[_9144]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9308 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9373 = mem[_9308]
                            require mem[_9308] == mem[_9308 + 18 len 14]
                            _9432 = mem[_9308 + 32]
                            require mem[_9308 + 32] == mem[_9308 + 50 len 14]
                            require mem[_9308 + 64] == mem[_9308 + 92 len 4]
                            if _9180 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9308 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9308 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9180 and 997 > -1 / _9180:
                                revert with 'NH{q', 17
                            if 997 * _9180 / 997 != _9180:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9308 + 18 len 14]:
                                if mem[_9308 + 50 len 14] and 1000 > -1 / mem[_9308 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9308 + 50 len 14] / 1000 != mem[_9308 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9308 + 50 len 14] > (-997 * _9180) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9308 + 50 len 14]) + (997 * _9180) < 1000 * mem[_9308 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9308 + 50 len 14]) + (997 * _9180):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10963 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10963] == mem[_10963 + 18 len 14]
                                require mem[_10963 + 32] == mem[_10963 + 50 len 14]
                                require mem[_10963 + 64] == mem[_10963 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10963 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10963 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) / 997 != 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10963 + 18 len 14]:
                                    if mem[_10963 + 50 len 14] and 1000 > -1 / mem[_10963 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10963 + 50 len 14] / 1000 != mem[_10963 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10963 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) < 1000 * mem[_10963 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) and mem[_10963 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                        revert with 'NH{q', 17
                                    if not mem[_10963 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) * mem[_10963 + 18 len 14] / mem[_10963 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10963 + 50 len 14] and 1000 > -1 / mem[_10963 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10963 + 50 len 14] / 1000 != mem[_10963 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10963 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) < 1000 * mem[_10963 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180) * mem[_10963 + 18 len 14] / (1000 * mem[_10963 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9432)) + (997 * _9180))
                            else:
                                if 997 * _9180 and mem[_9308 + 18 len 14] > -1 / 997 * _9180:
                                    revert with 'NH{q', 17
                                if not mem[_9308 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9180 * mem[_9308 + 18 len 14] / mem[_9308 + 18 len 14] != 997 * _9180:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9308 + 50 len 14] and 1000 > -1 / mem[_9308 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9308 + 50 len 14] / 1000 != mem[_9308 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9308 + 50 len 14] > (-997 * _9180) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9308 + 50 len 14]) + (997 * _9180) < 1000 * mem[_9308 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9308 + 50 len 14]) + (997 * _9180):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11398 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11398] == mem[_11398 + 18 len 14]
                                require mem[_11398 + 32] == mem[_11398 + 50 len 14]
                                require mem[_11398 + 64] == mem[_11398 + 92 len 4]
                                if 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11398 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11398 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) and 997 > -1 / 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) / 997 != 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11398 + 18 len 14]:
                                    if mem[_11398 + 50 len 14] and 1000 > -1 / mem[_11398 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11398 + 50 len 14] / 1000 != mem[_11398 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11398 + 50 len 14] > (-997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) < 1000 * mem[_11398 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180))
                                else:
                                    if 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) and mem[_11398 + 18 len 14] > -1 / 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                        revert with 'NH{q', 17
                                    if not mem[_11398 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) * mem[_11398 + 18 len 14] / mem[_11398 + 18 len 14] != 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11398 + 50 len 14] and 1000 > -1 / mem[_11398 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11398 + 50 len 14] / 1000 != mem[_11398 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11398 + 50 len 14] > (-997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)) < 1000 * mem[_11398 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180) * mem[_11398 + 18 len 14] / (1000 * mem[_11398 + 50 len 14]) + (997 * 997 * _9180 * Mask(112, 0, _9373) / (1000 * Mask(112, 0, _9432)) + (997 * _9180))
                    else:
                        if 997 * _7511 and mem[_7543 + 50 len 14] > -1 / 997 * _7511:
                            revert with 'NH{q', 17
                        if not mem[_7543 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7511 * mem[_7543 + 50 len 14] / mem[_7543 + 50 len 14] != 997 * _7511:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7543 + 18 len 14] and 1000 > -1 / mem[_7543 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7543 + 18 len 14] / 1000 != mem[_7543 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7543 + 18 len 14] > (-997 * _7511) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7543 + 18 len 14]) + (997 * _7511) < 1000 * mem[_7543 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7543 + 18 len 14]) + (997 * _7511):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7511 * mem[_7543 + 50 len 14] / (1000 * mem[_7543 + 18 len 14]) + (997 * _7511)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _8127 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8163 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8195 = mem[_8163]
                        require mem[_8163] == mem[_8163 + 18 len 14]
                        _8227 = mem[_8163 + 32]
                        require mem[_8163 + 32] == mem[_8163 + 50 len 14]
                        require mem[_8163 + 64] == mem[_8163 + 92 len 4]
                        if _8127 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8163 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8163 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8127 and 997 > -1 / _8127:
                            revert with 'NH{q', 17
                        if 997 * _8127 / 997 != _8127:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8163 + 18 len 14]:
                            if mem[_8163 + 50 len 14] and 1000 > -1 / mem[_8163 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8163 + 50 len 14] / 1000 != mem[_8163 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8163 + 50 len 14] > (-997 * _8127) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8163 + 50 len 14]) + (997 * _8127) < 1000 * mem[_8163 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8163 + 50 len 14]) + (997 * _8127):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8163 + 50 len 14]) + (997 * _8127)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8227)) + (997 * _8127))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9145 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9181 = mem[_9145]
                            require mem[_9145] == mem[_9145]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9309 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9374 = mem[_9309]
                            require mem[_9309] == mem[_9309 + 18 len 14]
                            _9433 = mem[_9309 + 32]
                            require mem[_9309 + 32] == mem[_9309 + 50 len 14]
                            require mem[_9309 + 64] == mem[_9309 + 92 len 4]
                            if _9181 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9309 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9309 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9181 and 997 > -1 / _9181:
                                revert with 'NH{q', 17
                            if 997 * _9181 / 997 != _9181:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9309 + 18 len 14]:
                                if mem[_9309 + 50 len 14] and 1000 > -1 / mem[_9309 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9309 + 50 len 14] / 1000 != mem[_9309 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9309 + 50 len 14] > (-997 * _9181) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9309 + 50 len 14]) + (997 * _9181) < 1000 * mem[_9309 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9309 + 50 len 14]) + (997 * _9181):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10965 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10965] == mem[_10965 + 18 len 14]
                                require mem[_10965 + 32] == mem[_10965 + 50 len 14]
                                require mem[_10965 + 64] == mem[_10965 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10965 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10965 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) / 997 != 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10965 + 18 len 14]:
                                    if mem[_10965 + 50 len 14] and 1000 > -1 / mem[_10965 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10965 + 50 len 14] / 1000 != mem[_10965 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10965 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) < 1000 * mem[_10965 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) and mem[_10965 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                        revert with 'NH{q', 17
                                    if not mem[_10965 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) * mem[_10965 + 18 len 14] / mem[_10965 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10965 + 50 len 14] and 1000 > -1 / mem[_10965 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10965 + 50 len 14] / 1000 != mem[_10965 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10965 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) < 1000 * mem[_10965 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181) * mem[_10965 + 18 len 14] / (1000 * mem[_10965 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9433)) + (997 * _9181))
                            else:
                                if 997 * _9181 and mem[_9309 + 18 len 14] > -1 / 997 * _9181:
                                    revert with 'NH{q', 17
                                if not mem[_9309 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9181 * mem[_9309 + 18 len 14] / mem[_9309 + 18 len 14] != 997 * _9181:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9309 + 50 len 14] and 1000 > -1 / mem[_9309 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9309 + 50 len 14] / 1000 != mem[_9309 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9309 + 50 len 14] > (-997 * _9181) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9309 + 50 len 14]) + (997 * _9181) < 1000 * mem[_9309 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9309 + 50 len 14]) + (997 * _9181):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11399 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11399] == mem[_11399 + 18 len 14]
                                require mem[_11399 + 32] == mem[_11399 + 50 len 14]
                                require mem[_11399 + 64] == mem[_11399 + 92 len 4]
                                if 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11399 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11399 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) and 997 > -1 / 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) / 997 != 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11399 + 18 len 14]:
                                    if mem[_11399 + 50 len 14] and 1000 > -1 / mem[_11399 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11399 + 50 len 14] / 1000 != mem[_11399 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11399 + 50 len 14] > (-997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) < 1000 * mem[_11399 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181))
                                else:
                                    if 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) and mem[_11399 + 18 len 14] > -1 / 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                        revert with 'NH{q', 17
                                    if not mem[_11399 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) * mem[_11399 + 18 len 14] / mem[_11399 + 18 len 14] != 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11399 + 50 len 14] and 1000 > -1 / mem[_11399 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11399 + 50 len 14] / 1000 != mem[_11399 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11399 + 50 len 14] > (-997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)) < 1000 * mem[_11399 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181) * mem[_11399 + 18 len 14] / (1000 * mem[_11399 + 50 len 14]) + (997 * 997 * _9181 * Mask(112, 0, _9374) / (1000 * Mask(112, 0, _9433)) + (997 * _9181))
                        else:
                            if 997 * _8127 and mem[_8163 + 18 len 14] > -1 / 997 * _8127:
                                revert with 'NH{q', 17
                            if not mem[_8163 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8127 * mem[_8163 + 18 len 14] / mem[_8163 + 18 len 14] != 997 * _8127:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8163 + 50 len 14] and 1000 > -1 / mem[_8163 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8163 + 50 len 14] / 1000 != mem[_8163 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8163 + 50 len 14] > (-997 * _8127) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8163 + 50 len 14]) + (997 * _8127) < 1000 * mem[_8163 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8163 + 50 len 14]) + (997 * _8127):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _8127 * mem[_8163 + 18 len 14] / (1000 * mem[_8163 + 50 len 14]) + (997 * _8127)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _8127 * Mask(112, 0, _8195) / (1000 * Mask(112, 0, _8227)) + (997 * _8127))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9375 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9419 = mem[_9375]
                            require mem[_9375] == mem[_9375]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9523 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9583 = mem[_9523]
                            require mem[_9523] == mem[_9523 + 18 len 14]
                            _9657 = mem[_9523 + 32]
                            require mem[_9523 + 32] == mem[_9523 + 50 len 14]
                            require mem[_9523 + 64] == mem[_9523 + 92 len 4]
                            if _9419 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9523 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9523 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9419 and 997 > -1 / _9419:
                                revert with 'NH{q', 17
                            if 997 * _9419 / 997 != _9419:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9523 + 18 len 14]:
                                if mem[_9523 + 50 len 14] and 1000 > -1 / mem[_9523 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9523 + 50 len 14] / 1000 != mem[_9523 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9523 + 50 len 14] > (-997 * _9419) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9523 + 50 len 14]) + (997 * _9419) < 1000 * mem[_9523 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9523 + 50 len 14]) + (997 * _9419):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11400 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11400] == mem[_11400 + 18 len 14]
                                require mem[_11400 + 32] == mem[_11400 + 50 len 14]
                                require mem[_11400 + 64] == mem[_11400 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11400 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11400 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) / 997 != 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11400 + 18 len 14]:
                                    if mem[_11400 + 50 len 14] and 1000 > -1 / mem[_11400 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11400 + 50 len 14] / 1000 != mem[_11400 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11400 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) < 1000 * mem[_11400 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) and mem[_11400 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                        revert with 'NH{q', 17
                                    if not mem[_11400 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) * mem[_11400 + 18 len 14] / mem[_11400 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11400 + 50 len 14] and 1000 > -1 / mem[_11400 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11400 + 50 len 14] / 1000 != mem[_11400 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11400 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) < 1000 * mem[_11400 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419) * mem[_11400 + 18 len 14] / (1000 * mem[_11400 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9657)) + (997 * _9419))
                            else:
                                if 997 * _9419 and mem[_9523 + 18 len 14] > -1 / 997 * _9419:
                                    revert with 'NH{q', 17
                                if not mem[_9523 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9419 * mem[_9523 + 18 len 14] / mem[_9523 + 18 len 14] != 997 * _9419:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9523 + 50 len 14] and 1000 > -1 / mem[_9523 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9523 + 50 len 14] / 1000 != mem[_9523 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9523 + 50 len 14] > (-997 * _9419) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9523 + 50 len 14]) + (997 * _9419) < 1000 * mem[_9523 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9523 + 50 len 14]) + (997 * _9419):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11803 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11803] == mem[_11803 + 18 len 14]
                                require mem[_11803 + 32] == mem[_11803 + 50 len 14]
                                require mem[_11803 + 64] == mem[_11803 + 92 len 4]
                                if 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11803 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11803 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) and 997 > -1 / 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) / 997 != 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11803 + 18 len 14]:
                                    if mem[_11803 + 50 len 14] and 1000 > -1 / mem[_11803 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11803 + 50 len 14] / 1000 != mem[_11803 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11803 + 50 len 14] > (-997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) < 1000 * mem[_11803 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419))
                                else:
                                    if 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) and mem[_11803 + 18 len 14] > -1 / 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                        revert with 'NH{q', 17
                                    if not mem[_11803 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) * mem[_11803 + 18 len 14] / mem[_11803 + 18 len 14] != 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11803 + 50 len 14] and 1000 > -1 / mem[_11803 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11803 + 50 len 14] / 1000 != mem[_11803 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11803 + 50 len 14] > (-997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)) < 1000 * mem[_11803 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419) * mem[_11803 + 18 len 14] / (1000 * mem[_11803 + 50 len 14]) + (997 * 997 * _9419 * Mask(112, 0, _9583) / (1000 * Mask(112, 0, _9657)) + (997 * _9419))
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        _7064 = mem[64]
        mem[mem[64]] = 64
        _7080 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 64] = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 96 len 32 * _7080] = mem[(32 * ('cd', 4).length) + 160 len 32 * _7080]
        mem[mem[64] + 32] = (32 * _7080) + 96
        _7407 = mem[(64 * ('cd', 4).length) + 160]
        mem[_7064 + (32 * _7080) + 96] = mem[(64 * ('cd', 4).length) + 160]
        mem[_7064 + (32 * _7080) + 128 len 32 * _7407] = mem[(64 * ('cd', 4).length) + 192 len 32 * _7407]
        return memory
          from mem[64]
           len _7064 + (32 * _7080) + (32 * _7407) + -mem[64] + 128
    mem[(32 * ('cd', 4).length) + 160 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    mem[(64 * ('cd', 4).length) + 160] = ('cd', 4).length
    mem[64] = (98 * ('cd', 4).length) + 192
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 'NH{q', 50
            _7067 = mem[(32 * idx) + 128]
            require ext_code.size(stor13)
            staticcall stor13.getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7083 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _7088 = mem[_7083]
            require mem[_7083] == mem[_7083 + 18 len 14]
            _7099 = mem[_7083 + 32]
            require mem[_7083 + 32] == mem[_7083 + 50 len 14]
            require mem[_7083 + 64] == mem[_7083 + 92 len 4]
            if _7067 <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
            if mem[_7083 + 18 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if mem[_7083 + 50 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if _7067 and 997 > -1 / _7067:
                revert with 'NH{q', 17
            if 997 * _7067 / 997 != _7067:
                revert with 0, 'ds-math-mul-overflow'
            if not mem[_7083 + 50 len 14]:
                if mem[_7083 + 18 len 14] and 1000 > -1 / mem[_7083 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7083 + 18 len 14] / 1000 != mem[_7083 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7083 + 18 len 14] > (-997 * _7067) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7083 + 18 len 14]) + (997 * _7067) < 1000 * mem[_7083 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7083 + 18 len 14]) + (997 * _7067):
                    revert with 'NH{q', 18
                require ext_code.size(stor14)
                staticcall stor14.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7186 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7192 = mem[_7186]
                require mem[_7186] == mem[_7186 + 18 len 14]
                _7202 = mem[_7186 + 32]
                require mem[_7186 + 32] == mem[_7186 + 50 len 14]
                require mem[_7186 + 64] == mem[_7186 + 92 len 4]
                if 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7186 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7186 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) and 997 > -1 / 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                    revert with 'NH{q', 17
                if 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) / 997 != 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7186 + 50 len 14]:
                    if mem[_7186 + 18 len 14] and 1000 > -1 / mem[_7186 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7186 + 18 len 14] / 1000 != mem[_7186 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7186 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) < 1000 * mem[_7186 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 0 / (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (0 / (1000 * Mask(112, 0, _7192)) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7370 = mem[_7364]
                    require mem[_7364] == mem[_7364]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7412 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7412] == mem[_7412 + 18 len 14]
                    require mem[_7412 + 32] == mem[_7412 + 50 len 14]
                    require mem[_7412 + 64] == mem[_7412 + 92 len 4]
                    if _7370 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7412 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7412 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7370 and 997 > -1 / _7370:
                        revert with 'NH{q', 17
                    if 997 * _7370 / 997 != _7370:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7412 + 50 len 14]:
                        if mem[_7412 + 18 len 14] and 1000 > -1 / mem[_7412 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7412 + 18 len 14] / 1000 != mem[_7412 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7412 + 18 len 14] > (-997 * _7370) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7412 + 18 len 14]) + (997 * _7370) < 1000 * mem[_7412 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7412 + 18 len 14]) + (997 * _7370):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7412 + 18 len 14]) + (997 * _7370)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7756 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7774 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7788 = mem[_7774]
                        require mem[_7774] == mem[_7774 + 18 len 14]
                        _7826 = mem[_7774 + 32]
                        require mem[_7774 + 32] == mem[_7774 + 50 len 14]
                        require mem[_7774 + 64] == mem[_7774 + 92 len 4]
                        if _7756 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7774 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7774 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7756 and 997 > -1 / _7756:
                            revert with 'NH{q', 17
                        if 997 * _7756 / 997 != _7756:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7774 + 18 len 14]:
                            if mem[_7774 + 50 len 14] and 1000 > -1 / mem[_7774 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7774 + 50 len 14] / 1000 != mem[_7774 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7774 + 50 len 14] > (-997 * _7756) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7774 + 50 len 14]) + (997 * _7756) < 1000 * mem[_7774 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7774 + 50 len 14]) + (997 * _7756):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7774 + 50 len 14]) + (997 * _7756)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7826)) + (997 * _7756))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8500 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8520 = mem[_8500]
                            require mem[_8500] == mem[_8500]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8620 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8676 = mem[_8620]
                            require mem[_8620] == mem[_8620 + 18 len 14]
                            _8760 = mem[_8620 + 32]
                            require mem[_8620 + 32] == mem[_8620 + 50 len 14]
                            require mem[_8620 + 64] == mem[_8620 + 92 len 4]
                            if _8520 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8620 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8620 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8520 and 997 > -1 / _8520:
                                revert with 'NH{q', 17
                            if 997 * _8520 / 997 != _8520:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8620 + 18 len 14]:
                                if mem[_8620 + 50 len 14] and 1000 > -1 / mem[_8620 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8620 + 50 len 14] / 1000 != mem[_8620 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8620 + 50 len 14] > (-997 * _8520) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8620 + 50 len 14]) + (997 * _8520) < 1000 * mem[_8620 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8620 + 50 len 14]) + (997 * _8520):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _9910 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_9910] == mem[_9910 + 18 len 14]
                                require mem[_9910 + 32] == mem[_9910 + 50 len 14]
                                require mem[_9910 + 64] == mem[_9910 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_9910 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_9910 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) / 997 != 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_9910 + 18 len 14]:
                                    if mem[_9910 + 50 len 14] and 1000 > -1 / mem[_9910 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9910 + 50 len 14] / 1000 != mem[_9910 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9910 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) < 1000 * mem[_9910 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) and mem[_9910 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                        revert with 'NH{q', 17
                                    if not mem[_9910 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) * mem[_9910 + 18 len 14] / mem[_9910 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_9910 + 50 len 14] and 1000 > -1 / mem[_9910 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_9910 + 50 len 14] / 1000 != mem[_9910 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_9910 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) < 1000 * mem[_9910 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520) * mem[_9910 + 18 len 14] / (1000 * mem[_9910 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8760)) + (997 * _8520))
                            else:
                                if 997 * _8520 and mem[_8620 + 18 len 14] > -1 / 997 * _8520:
                                    revert with 'NH{q', 17
                                if not mem[_8620 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8520 * mem[_8620 + 18 len 14] / mem[_8620 + 18 len 14] != 997 * _8520:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8620 + 50 len 14] and 1000 > -1 / mem[_8620 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8620 + 50 len 14] / 1000 != mem[_8620 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8620 + 50 len 14] > (-997 * _8520) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8620 + 50 len 14]) + (997 * _8520) < 1000 * mem[_8620 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8620 + 50 len 14]) + (997 * _8520):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10172 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10172] == mem[_10172 + 18 len 14]
                                require mem[_10172 + 32] == mem[_10172 + 50 len 14]
                                require mem[_10172 + 64] == mem[_10172 + 92 len 4]
                                if 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10172 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10172 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) and 997 > -1 / 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) / 997 != 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10172 + 18 len 14]:
                                    if mem[_10172 + 50 len 14] and 1000 > -1 / mem[_10172 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10172 + 50 len 14] / 1000 != mem[_10172 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10172 + 50 len 14] > (-997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) < 1000 * mem[_10172 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520))
                                else:
                                    if 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) and mem[_10172 + 18 len 14] > -1 / 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                        revert with 'NH{q', 17
                                    if not mem[_10172 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) * mem[_10172 + 18 len 14] / mem[_10172 + 18 len 14] != 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10172 + 50 len 14] and 1000 > -1 / mem[_10172 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10172 + 50 len 14] / 1000 != mem[_10172 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10172 + 50 len 14] > (-997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)) < 1000 * mem[_10172 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520) * mem[_10172 + 18 len 14] / (1000 * mem[_10172 + 50 len 14]) + (997 * 997 * _8520 * Mask(112, 0, _8676) / (1000 * Mask(112, 0, _8760)) + (997 * _8520))
                        else:
                            if 997 * _7756 and mem[_7774 + 18 len 14] > -1 / 997 * _7756:
                                revert with 'NH{q', 17
                            if not mem[_7774 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7756 * mem[_7774 + 18 len 14] / mem[_7774 + 18 len 14] != 997 * _7756:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7774 + 50 len 14] and 1000 > -1 / mem[_7774 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7774 + 50 len 14] / 1000 != mem[_7774 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7774 + 50 len 14] > (-997 * _7756) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7774 + 50 len 14]) + (997 * _7756) < 1000 * mem[_7774 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7774 + 50 len 14]) + (997 * _7756):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7756 * mem[_7774 + 18 len 14] / (1000 * mem[_7774 + 50 len 14]) + (997 * _7756)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7756 * Mask(112, 0, _7788) / (1000 * Mask(112, 0, _7826)) + (997 * _7756))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8677 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8702 = mem[_8677]
                            require mem[_8677] == mem[_8677]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8830 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8902 = mem[_8830]
                            require mem[_8830] == mem[_8830 + 18 len 14]
                            _8982 = mem[_8830 + 32]
                            require mem[_8830 + 32] == mem[_8830 + 50 len 14]
                            require mem[_8830 + 64] == mem[_8830 + 92 len 4]
                            if _8702 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8830 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8830 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8702 and 997 > -1 / _8702:
                                revert with 'NH{q', 17
                            if 997 * _8702 / 997 != _8702:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8830 + 18 len 14]:
                                if mem[_8830 + 50 len 14] and 1000 > -1 / mem[_8830 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8830 + 50 len 14] / 1000 != mem[_8830 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8830 + 50 len 14] > (-997 * _8702) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8830 + 50 len 14]) + (997 * _8702) < 1000 * mem[_8830 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8830 + 50 len 14]) + (997 * _8702):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10173 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10173] == mem[_10173 + 18 len 14]
                                require mem[_10173 + 32] == mem[_10173 + 50 len 14]
                                require mem[_10173 + 64] == mem[_10173 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10173 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10173 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) / 997 != 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10173 + 18 len 14]:
                                    if mem[_10173 + 50 len 14] and 1000 > -1 / mem[_10173 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10173 + 50 len 14] / 1000 != mem[_10173 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10173 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) < 1000 * mem[_10173 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) and mem[_10173 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                        revert with 'NH{q', 17
                                    if not mem[_10173 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) * mem[_10173 + 18 len 14] / mem[_10173 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10173 + 50 len 14] and 1000 > -1 / mem[_10173 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10173 + 50 len 14] / 1000 != mem[_10173 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10173 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) < 1000 * mem[_10173 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702) * mem[_10173 + 18 len 14] / (1000 * mem[_10173 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8982)) + (997 * _8702))
                            else:
                                if 997 * _8702 and mem[_8830 + 18 len 14] > -1 / 997 * _8702:
                                    revert with 'NH{q', 17
                                if not mem[_8830 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8702 * mem[_8830 + 18 len 14] / mem[_8830 + 18 len 14] != 997 * _8702:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8830 + 50 len 14] and 1000 > -1 / mem[_8830 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8830 + 50 len 14] / 1000 != mem[_8830 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8830 + 50 len 14] > (-997 * _8702) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8830 + 50 len 14]) + (997 * _8702) < 1000 * mem[_8830 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8830 + 50 len 14]) + (997 * _8702):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10538 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10538] == mem[_10538 + 18 len 14]
                                require mem[_10538 + 32] == mem[_10538 + 50 len 14]
                                require mem[_10538 + 64] == mem[_10538 + 92 len 4]
                                if 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10538 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10538 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) and 997 > -1 / 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) / 997 != 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10538 + 18 len 14]:
                                    if mem[_10538 + 50 len 14] and 1000 > -1 / mem[_10538 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10538 + 50 len 14] / 1000 != mem[_10538 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10538 + 50 len 14] > (-997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) < 1000 * mem[_10538 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702))
                                else:
                                    if 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) and mem[_10538 + 18 len 14] > -1 / 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                        revert with 'NH{q', 17
                                    if not mem[_10538 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) * mem[_10538 + 18 len 14] / mem[_10538 + 18 len 14] != 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10538 + 50 len 14] and 1000 > -1 / mem[_10538 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10538 + 50 len 14] / 1000 != mem[_10538 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10538 + 50 len 14] > (-997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)) < 1000 * mem[_10538 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702) * mem[_10538 + 18 len 14] / (1000 * mem[_10538 + 50 len 14]) + (997 * 997 * _8702 * Mask(112, 0, _8902) / (1000 * Mask(112, 0, _8982)) + (997 * _8702))
                    else:
                        if 997 * _7370 and mem[_7412 + 50 len 14] > -1 / 997 * _7370:
                            revert with 'NH{q', 17
                        if not mem[_7412 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7370 * mem[_7412 + 50 len 14] / mem[_7412 + 50 len 14] != 997 * _7370:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7412 + 18 len 14] and 1000 > -1 / mem[_7412 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7412 + 18 len 14] / 1000 != mem[_7412 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7412 + 18 len 14] > (-997 * _7370) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7412 + 18 len 14]) + (997 * _7370) < 1000 * mem[_7412 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7412 + 18 len 14]) + (997 * _7370):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7370 * mem[_7412 + 50 len 14] / (1000 * mem[_7412 + 18 len 14]) + (997 * _7370)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7864 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7906 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7928 = mem[_7906]
                        require mem[_7906] == mem[_7906 + 18 len 14]
                        _7962 = mem[_7906 + 32]
                        require mem[_7906 + 32] == mem[_7906 + 50 len 14]
                        require mem[_7906 + 64] == mem[_7906 + 92 len 4]
                        if _7864 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7906 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7906 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7864 and 997 > -1 / _7864:
                            revert with 'NH{q', 17
                        if 997 * _7864 / 997 != _7864:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7906 + 18 len 14]:
                            if mem[_7906 + 50 len 14] and 1000 > -1 / mem[_7906 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7906 + 50 len 14] / 1000 != mem[_7906 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7906 + 50 len 14] > (-997 * _7864) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7906 + 50 len 14]) + (997 * _7864) < 1000 * mem[_7906 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7906 + 50 len 14]) + (997 * _7864):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7906 + 50 len 14]) + (997 * _7864)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7962)) + (997 * _7864))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8678 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8703 = mem[_8678]
                            require mem[_8678] == mem[_8678]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8831 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8903 = mem[_8831]
                            require mem[_8831] == mem[_8831 + 18 len 14]
                            _8983 = mem[_8831 + 32]
                            require mem[_8831 + 32] == mem[_8831 + 50 len 14]
                            require mem[_8831 + 64] == mem[_8831 + 92 len 4]
                            if _8703 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8831 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8831 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8703 and 997 > -1 / _8703:
                                revert with 'NH{q', 17
                            if 997 * _8703 / 997 != _8703:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8831 + 18 len 14]:
                                if mem[_8831 + 50 len 14] and 1000 > -1 / mem[_8831 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8831 + 50 len 14] / 1000 != mem[_8831 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8831 + 50 len 14] > (-997 * _8703) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8831 + 50 len 14]) + (997 * _8703) < 1000 * mem[_8831 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8831 + 50 len 14]) + (997 * _8703):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10175 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10175] == mem[_10175 + 18 len 14]
                                require mem[_10175 + 32] == mem[_10175 + 50 len 14]
                                require mem[_10175 + 64] == mem[_10175 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10175 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10175 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) / 997 != 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10175 + 18 len 14]:
                                    if mem[_10175 + 50 len 14] and 1000 > -1 / mem[_10175 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10175 + 50 len 14] / 1000 != mem[_10175 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10175 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) < 1000 * mem[_10175 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) and mem[_10175 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                        revert with 'NH{q', 17
                                    if not mem[_10175 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) * mem[_10175 + 18 len 14] / mem[_10175 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10175 + 50 len 14] and 1000 > -1 / mem[_10175 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10175 + 50 len 14] / 1000 != mem[_10175 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10175 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) < 1000 * mem[_10175 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703) * mem[_10175 + 18 len 14] / (1000 * mem[_10175 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8983)) + (997 * _8703))
                            else:
                                if 997 * _8703 and mem[_8831 + 18 len 14] > -1 / 997 * _8703:
                                    revert with 'NH{q', 17
                                if not mem[_8831 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8703 * mem[_8831 + 18 len 14] / mem[_8831 + 18 len 14] != 997 * _8703:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8831 + 50 len 14] and 1000 > -1 / mem[_8831 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8831 + 50 len 14] / 1000 != mem[_8831 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8831 + 50 len 14] > (-997 * _8703) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8831 + 50 len 14]) + (997 * _8703) < 1000 * mem[_8831 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8831 + 50 len 14]) + (997 * _8703):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10539 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10539] == mem[_10539 + 18 len 14]
                                require mem[_10539 + 32] == mem[_10539 + 50 len 14]
                                require mem[_10539 + 64] == mem[_10539 + 92 len 4]
                                if 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10539 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10539 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) and 997 > -1 / 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) / 997 != 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10539 + 18 len 14]:
                                    if mem[_10539 + 50 len 14] and 1000 > -1 / mem[_10539 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10539 + 50 len 14] / 1000 != mem[_10539 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10539 + 50 len 14] > (-997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) < 1000 * mem[_10539 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703))
                                else:
                                    if 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) and mem[_10539 + 18 len 14] > -1 / 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                        revert with 'NH{q', 17
                                    if not mem[_10539 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) * mem[_10539 + 18 len 14] / mem[_10539 + 18 len 14] != 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10539 + 50 len 14] and 1000 > -1 / mem[_10539 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10539 + 50 len 14] / 1000 != mem[_10539 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10539 + 50 len 14] > (-997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)) < 1000 * mem[_10539 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703) * mem[_10539 + 18 len 14] / (1000 * mem[_10539 + 50 len 14]) + (997 * 997 * _8703 * Mask(112, 0, _8903) / (1000 * Mask(112, 0, _8983)) + (997 * _8703))
                        else:
                            if 997 * _7864 and mem[_7906 + 18 len 14] > -1 / 997 * _7864:
                                revert with 'NH{q', 17
                            if not mem[_7906 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7864 * mem[_7906 + 18 len 14] / mem[_7906 + 18 len 14] != 997 * _7864:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7906 + 50 len 14] and 1000 > -1 / mem[_7906 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7906 + 50 len 14] / 1000 != mem[_7906 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7906 + 50 len 14] > (-997 * _7864) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7906 + 50 len 14]) + (997 * _7864) < 1000 * mem[_7906 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7906 + 50 len 14]) + (997 * _7864):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7864 * mem[_7906 + 18 len 14] / (1000 * mem[_7906 + 50 len 14]) + (997 * _7864)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7864 * Mask(112, 0, _7928) / (1000 * Mask(112, 0, _7962)) + (997 * _7864))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8904 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8936 = mem[_8904]
                            require mem[_8904] == mem[_8904]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9074 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9146 = mem[_9074]
                            require mem[_9074] == mem[_9074 + 18 len 14]
                            _9208 = mem[_9074 + 32]
                            require mem[_9074 + 32] == mem[_9074 + 50 len 14]
                            require mem[_9074 + 64] == mem[_9074 + 92 len 4]
                            if _8936 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9074 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9074 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8936 and 997 > -1 / _8936:
                                revert with 'NH{q', 17
                            if 997 * _8936 / 997 != _8936:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9074 + 18 len 14]:
                                if mem[_9074 + 50 len 14] and 1000 > -1 / mem[_9074 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9074 + 50 len 14] / 1000 != mem[_9074 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9074 + 50 len 14] > (-997 * _8936) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9074 + 50 len 14]) + (997 * _8936) < 1000 * mem[_9074 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9074 + 50 len 14]) + (997 * _8936):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10540 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10540] == mem[_10540 + 18 len 14]
                                require mem[_10540 + 32] == mem[_10540 + 50 len 14]
                                require mem[_10540 + 64] == mem[_10540 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10540 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10540 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) / 997 != 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10540 + 18 len 14]:
                                    if mem[_10540 + 50 len 14] and 1000 > -1 / mem[_10540 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10540 + 50 len 14] / 1000 != mem[_10540 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10540 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) < 1000 * mem[_10540 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) and mem[_10540 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                        revert with 'NH{q', 17
                                    if not mem[_10540 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) * mem[_10540 + 18 len 14] / mem[_10540 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10540 + 50 len 14] and 1000 > -1 / mem[_10540 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10540 + 50 len 14] / 1000 != mem[_10540 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10540 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) < 1000 * mem[_10540 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936) * mem[_10540 + 18 len 14] / (1000 * mem[_10540 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9208)) + (997 * _8936))
                            else:
                                if 997 * _8936 and mem[_9074 + 18 len 14] > -1 / 997 * _8936:
                                    revert with 'NH{q', 17
                                if not mem[_9074 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8936 * mem[_9074 + 18 len 14] / mem[_9074 + 18 len 14] != 997 * _8936:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9074 + 50 len 14] and 1000 > -1 / mem[_9074 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9074 + 50 len 14] / 1000 != mem[_9074 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9074 + 50 len 14] > (-997 * _8936) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9074 + 50 len 14]) + (997 * _8936) < 1000 * mem[_9074 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9074 + 50 len 14]) + (997 * _8936):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10968 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10968] == mem[_10968 + 18 len 14]
                                require mem[_10968 + 32] == mem[_10968 + 50 len 14]
                                require mem[_10968 + 64] == mem[_10968 + 92 len 4]
                                if 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10968 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10968 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) and 997 > -1 / 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) / 997 != 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10968 + 18 len 14]:
                                    if mem[_10968 + 50 len 14] and 1000 > -1 / mem[_10968 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10968 + 50 len 14] / 1000 != mem[_10968 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10968 + 50 len 14] > (-997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) < 1000 * mem[_10968 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936))
                                else:
                                    if 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) and mem[_10968 + 18 len 14] > -1 / 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                        revert with 'NH{q', 17
                                    if not mem[_10968 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) * mem[_10968 + 18 len 14] / mem[_10968 + 18 len 14] != 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10968 + 50 len 14] and 1000 > -1 / mem[_10968 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10968 + 50 len 14] / 1000 != mem[_10968 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10968 + 50 len 14] > (-997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)) < 1000 * mem[_10968 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936) * mem[_10968 + 18 len 14] / (1000 * mem[_10968 + 50 len 14]) + (997 * 997 * _8936 * Mask(112, 0, _9146) / (1000 * Mask(112, 0, _9208)) + (997 * _8936))
                else:
                    if 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) and mem[_7186 + 50 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                        revert with 'NH{q', 17
                    if not mem[_7186 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * mem[_7186 + 50 len 14] / mem[_7186 + 50 len 14] != 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7186 + 18 len 14] and 1000 > -1 / mem[_7186 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7186 + 18 len 14] / 1000 != mem[_7186 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7186 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) < 1000 * mem[_7186 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * mem[_7186 + 50 len 14] / (1000 * mem[_7186 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * Mask(112, 0, _7202) / (1000 * Mask(112, 0, _7192)) + (997 * 0 / (1000 * Mask(112, 0, _7088)) + (997 * _7067)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7433 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7445 = mem[_7433]
                    require mem[_7433] == mem[_7433]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7486 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7486] == mem[_7486 + 18 len 14]
                    require mem[_7486 + 32] == mem[_7486 + 50 len 14]
                    require mem[_7486 + 64] == mem[_7486 + 92 len 4]
                    if _7445 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7486 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7486 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7445 and 997 > -1 / _7445:
                        revert with 'NH{q', 17
                    if 997 * _7445 / 997 != _7445:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7486 + 50 len 14]:
                        if mem[_7486 + 18 len 14] and 1000 > -1 / mem[_7486 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7486 + 18 len 14] / 1000 != mem[_7486 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7486 + 18 len 14] > (-997 * _7445) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7486 + 18 len 14]) + (997 * _7445) < 1000 * mem[_7486 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7486 + 18 len 14]) + (997 * _7445):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7486 + 18 len 14]) + (997 * _7445)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7865 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7907 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7929 = mem[_7907]
                        require mem[_7907] == mem[_7907 + 18 len 14]
                        _7963 = mem[_7907 + 32]
                        require mem[_7907 + 32] == mem[_7907 + 50 len 14]
                        require mem[_7907 + 64] == mem[_7907 + 92 len 4]
                        if _7865 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7907 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7907 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7865 and 997 > -1 / _7865:
                            revert with 'NH{q', 17
                        if 997 * _7865 / 997 != _7865:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7907 + 18 len 14]:
                            if mem[_7907 + 50 len 14] and 1000 > -1 / mem[_7907 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7907 + 50 len 14] / 1000 != mem[_7907 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7907 + 50 len 14] > (-997 * _7865) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7907 + 50 len 14]) + (997 * _7865) < 1000 * mem[_7907 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7907 + 50 len 14]) + (997 * _7865):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7907 + 50 len 14]) + (997 * _7865)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7963)) + (997 * _7865))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8679 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8704 = mem[_8679]
                            require mem[_8679] == mem[_8679]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8832 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8905 = mem[_8832]
                            require mem[_8832] == mem[_8832 + 18 len 14]
                            _8984 = mem[_8832 + 32]
                            require mem[_8832 + 32] == mem[_8832 + 50 len 14]
                            require mem[_8832 + 64] == mem[_8832 + 92 len 4]
                            if _8704 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8832 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8832 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8704 and 997 > -1 / _8704:
                                revert with 'NH{q', 17
                            if 997 * _8704 / 997 != _8704:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8832 + 18 len 14]:
                                if mem[_8832 + 50 len 14] and 1000 > -1 / mem[_8832 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8832 + 50 len 14] / 1000 != mem[_8832 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8832 + 50 len 14] > (-997 * _8704) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8832 + 50 len 14]) + (997 * _8704) < 1000 * mem[_8832 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8832 + 50 len 14]) + (997 * _8704):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10178 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10178] == mem[_10178 + 18 len 14]
                                require mem[_10178 + 32] == mem[_10178 + 50 len 14]
                                require mem[_10178 + 64] == mem[_10178 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10178 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10178 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) / 997 != 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10178 + 18 len 14]:
                                    if mem[_10178 + 50 len 14] and 1000 > -1 / mem[_10178 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10178 + 50 len 14] / 1000 != mem[_10178 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10178 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) < 1000 * mem[_10178 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) and mem[_10178 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                        revert with 'NH{q', 17
                                    if not mem[_10178 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) * mem[_10178 + 18 len 14] / mem[_10178 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10178 + 50 len 14] and 1000 > -1 / mem[_10178 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10178 + 50 len 14] / 1000 != mem[_10178 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10178 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) < 1000 * mem[_10178 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704) * mem[_10178 + 18 len 14] / (1000 * mem[_10178 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8984)) + (997 * _8704))
                            else:
                                if 997 * _8704 and mem[_8832 + 18 len 14] > -1 / 997 * _8704:
                                    revert with 'NH{q', 17
                                if not mem[_8832 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8704 * mem[_8832 + 18 len 14] / mem[_8832 + 18 len 14] != 997 * _8704:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8832 + 50 len 14] and 1000 > -1 / mem[_8832 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8832 + 50 len 14] / 1000 != mem[_8832 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8832 + 50 len 14] > (-997 * _8704) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8832 + 50 len 14]) + (997 * _8704) < 1000 * mem[_8832 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8832 + 50 len 14]) + (997 * _8704):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10542 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10542] == mem[_10542 + 18 len 14]
                                require mem[_10542 + 32] == mem[_10542 + 50 len 14]
                                require mem[_10542 + 64] == mem[_10542 + 92 len 4]
                                if 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10542 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10542 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) and 997 > -1 / 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) / 997 != 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10542 + 18 len 14]:
                                    if mem[_10542 + 50 len 14] and 1000 > -1 / mem[_10542 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10542 + 50 len 14] / 1000 != mem[_10542 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10542 + 50 len 14] > (-997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) < 1000 * mem[_10542 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704))
                                else:
                                    if 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) and mem[_10542 + 18 len 14] > -1 / 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                        revert with 'NH{q', 17
                                    if not mem[_10542 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) * mem[_10542 + 18 len 14] / mem[_10542 + 18 len 14] != 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10542 + 50 len 14] and 1000 > -1 / mem[_10542 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10542 + 50 len 14] / 1000 != mem[_10542 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10542 + 50 len 14] > (-997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)) < 1000 * mem[_10542 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704) * mem[_10542 + 18 len 14] / (1000 * mem[_10542 + 50 len 14]) + (997 * 997 * _8704 * Mask(112, 0, _8905) / (1000 * Mask(112, 0, _8984)) + (997 * _8704))
                        else:
                            if 997 * _7865 and mem[_7907 + 18 len 14] > -1 / 997 * _7865:
                                revert with 'NH{q', 17
                            if not mem[_7907 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7865 * mem[_7907 + 18 len 14] / mem[_7907 + 18 len 14] != 997 * _7865:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7907 + 50 len 14] and 1000 > -1 / mem[_7907 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7907 + 50 len 14] / 1000 != mem[_7907 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7907 + 50 len 14] > (-997 * _7865) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7907 + 50 len 14]) + (997 * _7865) < 1000 * mem[_7907 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7907 + 50 len 14]) + (997 * _7865):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7865 * mem[_7907 + 18 len 14] / (1000 * mem[_7907 + 50 len 14]) + (997 * _7865)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7865 * Mask(112, 0, _7929) / (1000 * Mask(112, 0, _7963)) + (997 * _7865))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8906 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8937 = mem[_8906]
                            require mem[_8906] == mem[_8906]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9075 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9147 = mem[_9075]
                            require mem[_9075] == mem[_9075 + 18 len 14]
                            _9209 = mem[_9075 + 32]
                            require mem[_9075 + 32] == mem[_9075 + 50 len 14]
                            require mem[_9075 + 64] == mem[_9075 + 92 len 4]
                            if _8937 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9075 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9075 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8937 and 997 > -1 / _8937:
                                revert with 'NH{q', 17
                            if 997 * _8937 / 997 != _8937:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9075 + 18 len 14]:
                                if mem[_9075 + 50 len 14] and 1000 > -1 / mem[_9075 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9075 + 50 len 14] / 1000 != mem[_9075 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9075 + 50 len 14] > (-997 * _8937) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9075 + 50 len 14]) + (997 * _8937) < 1000 * mem[_9075 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9075 + 50 len 14]) + (997 * _8937):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10543 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10543] == mem[_10543 + 18 len 14]
                                require mem[_10543 + 32] == mem[_10543 + 50 len 14]
                                require mem[_10543 + 64] == mem[_10543 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10543 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10543 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) / 997 != 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10543 + 18 len 14]:
                                    if mem[_10543 + 50 len 14] and 1000 > -1 / mem[_10543 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10543 + 50 len 14] / 1000 != mem[_10543 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10543 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) < 1000 * mem[_10543 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) and mem[_10543 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                        revert with 'NH{q', 17
                                    if not mem[_10543 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) * mem[_10543 + 18 len 14] / mem[_10543 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10543 + 50 len 14] and 1000 > -1 / mem[_10543 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10543 + 50 len 14] / 1000 != mem[_10543 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10543 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) < 1000 * mem[_10543 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937) * mem[_10543 + 18 len 14] / (1000 * mem[_10543 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9209)) + (997 * _8937))
                            else:
                                if 997 * _8937 and mem[_9075 + 18 len 14] > -1 / 997 * _8937:
                                    revert with 'NH{q', 17
                                if not mem[_9075 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8937 * mem[_9075 + 18 len 14] / mem[_9075 + 18 len 14] != 997 * _8937:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9075 + 50 len 14] and 1000 > -1 / mem[_9075 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9075 + 50 len 14] / 1000 != mem[_9075 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9075 + 50 len 14] > (-997 * _8937) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9075 + 50 len 14]) + (997 * _8937) < 1000 * mem[_9075 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9075 + 50 len 14]) + (997 * _8937):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10969 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10969] == mem[_10969 + 18 len 14]
                                require mem[_10969 + 32] == mem[_10969 + 50 len 14]
                                require mem[_10969 + 64] == mem[_10969 + 92 len 4]
                                if 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10969 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10969 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) and 997 > -1 / 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) / 997 != 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10969 + 18 len 14]:
                                    if mem[_10969 + 50 len 14] and 1000 > -1 / mem[_10969 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10969 + 50 len 14] / 1000 != mem[_10969 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10969 + 50 len 14] > (-997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) < 1000 * mem[_10969 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937))
                                else:
                                    if 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) and mem[_10969 + 18 len 14] > -1 / 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                        revert with 'NH{q', 17
                                    if not mem[_10969 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) * mem[_10969 + 18 len 14] / mem[_10969 + 18 len 14] != 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10969 + 50 len 14] and 1000 > -1 / mem[_10969 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10969 + 50 len 14] / 1000 != mem[_10969 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10969 + 50 len 14] > (-997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)) < 1000 * mem[_10969 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937) * mem[_10969 + 18 len 14] / (1000 * mem[_10969 + 50 len 14]) + (997 * 997 * _8937 * Mask(112, 0, _9147) / (1000 * Mask(112, 0, _9209)) + (997 * _8937))
                    else:
                        if 997 * _7445 and mem[_7486 + 50 len 14] > -1 / 997 * _7445:
                            revert with 'NH{q', 17
                        if not mem[_7486 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7445 * mem[_7486 + 50 len 14] / mem[_7486 + 50 len 14] != 997 * _7445:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7486 + 18 len 14] and 1000 > -1 / mem[_7486 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7486 + 18 len 14] / 1000 != mem[_7486 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7486 + 18 len 14] > (-997 * _7445) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7486 + 18 len 14]) + (997 * _7445) < 1000 * mem[_7486 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7486 + 18 len 14]) + (997 * _7445):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7445 * mem[_7486 + 50 len 14] / (1000 * mem[_7486 + 18 len 14]) + (997 * _7445)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _8000 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8046 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8076 = mem[_8046]
                        require mem[_8046] == mem[_8046 + 18 len 14]
                        _8102 = mem[_8046 + 32]
                        require mem[_8046 + 32] == mem[_8046 + 50 len 14]
                        require mem[_8046 + 64] == mem[_8046 + 92 len 4]
                        if _8000 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8046 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8046 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8000 and 997 > -1 / _8000:
                            revert with 'NH{q', 17
                        if 997 * _8000 / 997 != _8000:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8046 + 18 len 14]:
                            if mem[_8046 + 50 len 14] and 1000 > -1 / mem[_8046 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8046 + 50 len 14] / 1000 != mem[_8046 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8046 + 50 len 14] > (-997 * _8000) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8046 + 50 len 14]) + (997 * _8000) < 1000 * mem[_8046 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8046 + 50 len 14]) + (997 * _8000):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8046 + 50 len 14]) + (997 * _8000)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8102)) + (997 * _8000))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8907 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8938 = mem[_8907]
                            require mem[_8907] == mem[_8907]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9076 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9148 = mem[_9076]
                            require mem[_9076] == mem[_9076 + 18 len 14]
                            _9210 = mem[_9076 + 32]
                            require mem[_9076 + 32] == mem[_9076 + 50 len 14]
                            require mem[_9076 + 64] == mem[_9076 + 92 len 4]
                            if _8938 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9076 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9076 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8938 and 997 > -1 / _8938:
                                revert with 'NH{q', 17
                            if 997 * _8938 / 997 != _8938:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9076 + 18 len 14]:
                                if mem[_9076 + 50 len 14] and 1000 > -1 / mem[_9076 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9076 + 50 len 14] / 1000 != mem[_9076 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9076 + 50 len 14] > (-997 * _8938) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9076 + 50 len 14]) + (997 * _8938) < 1000 * mem[_9076 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9076 + 50 len 14]) + (997 * _8938):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10545 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10545] == mem[_10545 + 18 len 14]
                                require mem[_10545 + 32] == mem[_10545 + 50 len 14]
                                require mem[_10545 + 64] == mem[_10545 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10545 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10545 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) / 997 != 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10545 + 18 len 14]:
                                    if mem[_10545 + 50 len 14] and 1000 > -1 / mem[_10545 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10545 + 50 len 14] / 1000 != mem[_10545 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10545 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) < 1000 * mem[_10545 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) and mem[_10545 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                        revert with 'NH{q', 17
                                    if not mem[_10545 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) * mem[_10545 + 18 len 14] / mem[_10545 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10545 + 50 len 14] and 1000 > -1 / mem[_10545 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10545 + 50 len 14] / 1000 != mem[_10545 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10545 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) < 1000 * mem[_10545 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938) * mem[_10545 + 18 len 14] / (1000 * mem[_10545 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9210)) + (997 * _8938))
                            else:
                                if 997 * _8938 and mem[_9076 + 18 len 14] > -1 / 997 * _8938:
                                    revert with 'NH{q', 17
                                if not mem[_9076 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8938 * mem[_9076 + 18 len 14] / mem[_9076 + 18 len 14] != 997 * _8938:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9076 + 50 len 14] and 1000 > -1 / mem[_9076 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9076 + 50 len 14] / 1000 != mem[_9076 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9076 + 50 len 14] > (-997 * _8938) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9076 + 50 len 14]) + (997 * _8938) < 1000 * mem[_9076 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9076 + 50 len 14]) + (997 * _8938):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10970 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10970] == mem[_10970 + 18 len 14]
                                require mem[_10970 + 32] == mem[_10970 + 50 len 14]
                                require mem[_10970 + 64] == mem[_10970 + 92 len 4]
                                if 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10970 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10970 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) and 997 > -1 / 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) / 997 != 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10970 + 18 len 14]:
                                    if mem[_10970 + 50 len 14] and 1000 > -1 / mem[_10970 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10970 + 50 len 14] / 1000 != mem[_10970 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10970 + 50 len 14] > (-997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) < 1000 * mem[_10970 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938))
                                else:
                                    if 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) and mem[_10970 + 18 len 14] > -1 / 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                        revert with 'NH{q', 17
                                    if not mem[_10970 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) * mem[_10970 + 18 len 14] / mem[_10970 + 18 len 14] != 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10970 + 50 len 14] and 1000 > -1 / mem[_10970 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10970 + 50 len 14] / 1000 != mem[_10970 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10970 + 50 len 14] > (-997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)) < 1000 * mem[_10970 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938) * mem[_10970 + 18 len 14] / (1000 * mem[_10970 + 50 len 14]) + (997 * 997 * _8938 * Mask(112, 0, _9148) / (1000 * Mask(112, 0, _9210)) + (997 * _8938))
                        else:
                            if 997 * _8000 and mem[_8046 + 18 len 14] > -1 / 997 * _8000:
                                revert with 'NH{q', 17
                            if not mem[_8046 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8000 * mem[_8046 + 18 len 14] / mem[_8046 + 18 len 14] != 997 * _8000:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8046 + 50 len 14] and 1000 > -1 / mem[_8046 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8046 + 50 len 14] / 1000 != mem[_8046 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8046 + 50 len 14] > (-997 * _8000) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8046 + 50 len 14]) + (997 * _8000) < 1000 * mem[_8046 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8046 + 50 len 14]) + (997 * _8000):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _8000 * mem[_8046 + 18 len 14] / (1000 * mem[_8046 + 50 len 14]) + (997 * _8000)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _8000 * Mask(112, 0, _8076) / (1000 * Mask(112, 0, _8102)) + (997 * _8000))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9149 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9182 = mem[_9149]
                            require mem[_9149] == mem[_9149]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9310 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9376 = mem[_9310]
                            require mem[_9310] == mem[_9310 + 18 len 14]
                            _9434 = mem[_9310 + 32]
                            require mem[_9310 + 32] == mem[_9310 + 50 len 14]
                            require mem[_9310 + 64] == mem[_9310 + 92 len 4]
                            if _9182 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9310 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9310 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9182 and 997 > -1 / _9182:
                                revert with 'NH{q', 17
                            if 997 * _9182 / 997 != _9182:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9310 + 18 len 14]:
                                if mem[_9310 + 50 len 14] and 1000 > -1 / mem[_9310 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9310 + 50 len 14] / 1000 != mem[_9310 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9310 + 50 len 14] > (-997 * _9182) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9310 + 50 len 14]) + (997 * _9182) < 1000 * mem[_9310 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9310 + 50 len 14]) + (997 * _9182):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10971 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10971] == mem[_10971 + 18 len 14]
                                require mem[_10971 + 32] == mem[_10971 + 50 len 14]
                                require mem[_10971 + 64] == mem[_10971 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10971 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10971 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) / 997 != 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10971 + 18 len 14]:
                                    if mem[_10971 + 50 len 14] and 1000 > -1 / mem[_10971 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10971 + 50 len 14] / 1000 != mem[_10971 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10971 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) < 1000 * mem[_10971 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) and mem[_10971 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                        revert with 'NH{q', 17
                                    if not mem[_10971 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) * mem[_10971 + 18 len 14] / mem[_10971 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10971 + 50 len 14] and 1000 > -1 / mem[_10971 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10971 + 50 len 14] / 1000 != mem[_10971 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10971 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) < 1000 * mem[_10971 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182) * mem[_10971 + 18 len 14] / (1000 * mem[_10971 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9434)) + (997 * _9182))
                            else:
                                if 997 * _9182 and mem[_9310 + 18 len 14] > -1 / 997 * _9182:
                                    revert with 'NH{q', 17
                                if not mem[_9310 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9182 * mem[_9310 + 18 len 14] / mem[_9310 + 18 len 14] != 997 * _9182:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9310 + 50 len 14] and 1000 > -1 / mem[_9310 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9310 + 50 len 14] / 1000 != mem[_9310 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9310 + 50 len 14] > (-997 * _9182) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9310 + 50 len 14]) + (997 * _9182) < 1000 * mem[_9310 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9310 + 50 len 14]) + (997 * _9182):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11402 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11402] == mem[_11402 + 18 len 14]
                                require mem[_11402 + 32] == mem[_11402 + 50 len 14]
                                require mem[_11402 + 64] == mem[_11402 + 92 len 4]
                                if 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11402 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11402 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) and 997 > -1 / 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) / 997 != 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11402 + 18 len 14]:
                                    if mem[_11402 + 50 len 14] and 1000 > -1 / mem[_11402 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11402 + 50 len 14] / 1000 != mem[_11402 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11402 + 50 len 14] > (-997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) < 1000 * mem[_11402 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182))
                                else:
                                    if 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) and mem[_11402 + 18 len 14] > -1 / 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                        revert with 'NH{q', 17
                                    if not mem[_11402 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) * mem[_11402 + 18 len 14] / mem[_11402 + 18 len 14] != 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11402 + 50 len 14] and 1000 > -1 / mem[_11402 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11402 + 50 len 14] / 1000 != mem[_11402 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11402 + 50 len 14] > (-997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)) < 1000 * mem[_11402 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182) * mem[_11402 + 18 len 14] / (1000 * mem[_11402 + 50 len 14]) + (997 * 997 * _9182 * Mask(112, 0, _9376) / (1000 * Mask(112, 0, _9434)) + (997 * _9182))
            else:
                if 997 * _7067 and mem[_7083 + 50 len 14] > -1 / 997 * _7067:
                    revert with 'NH{q', 17
                if not mem[_7083 + 50 len 14]:
                    revert with 'NH{q', 18
                if 997 * _7067 * mem[_7083 + 50 len 14] / mem[_7083 + 50 len 14] != 997 * _7067:
                    revert with 0, 'ds-math-mul-overflow'
                if mem[_7083 + 18 len 14] and 1000 > -1 / mem[_7083 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7083 + 18 len 14] / 1000 != mem[_7083 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7083 + 18 len 14] > (-997 * _7067) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7083 + 18 len 14]) + (997 * _7067) < 1000 * mem[_7083 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7083 + 18 len 14]) + (997 * _7067):
                    revert with 'NH{q', 18
                require ext_code.size(stor14)
                staticcall stor14.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7216 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7224 = mem[_7216]
                require mem[_7216] == mem[_7216 + 18 len 14]
                _7228 = mem[_7216 + 32]
                require mem[_7216 + 32] == mem[_7216 + 50 len 14]
                require mem[_7216 + 64] == mem[_7216 + 92 len 4]
                if 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7216 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7216 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) and 997 > -1 / 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                    revert with 'NH{q', 17
                if 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) / 997 != 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7216 + 50 len 14]:
                    if mem[_7216 + 18 len 14] and 1000 > -1 / mem[_7216 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7216 + 18 len 14] / 1000 != mem[_7216 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7216 + 18 len 14] > (-997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) < 1000 * mem[_7216 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 0 / (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (0 / (1000 * Mask(112, 0, _7224)) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7434 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7446 = mem[_7434]
                    require mem[_7434] == mem[_7434]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7487 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7487] == mem[_7487 + 18 len 14]
                    require mem[_7487 + 32] == mem[_7487 + 50 len 14]
                    require mem[_7487 + 64] == mem[_7487 + 92 len 4]
                    if _7446 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7487 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7487 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7446 and 997 > -1 / _7446:
                        revert with 'NH{q', 17
                    if 997 * _7446 / 997 != _7446:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7487 + 50 len 14]:
                        if mem[_7487 + 18 len 14] and 1000 > -1 / mem[_7487 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7487 + 18 len 14] / 1000 != mem[_7487 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7487 + 18 len 14] > (-997 * _7446) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7487 + 18 len 14]) + (997 * _7446) < 1000 * mem[_7487 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7487 + 18 len 14]) + (997 * _7446):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7487 + 18 len 14]) + (997 * _7446)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _7866 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7909 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7930 = mem[_7909]
                        require mem[_7909] == mem[_7909 + 18 len 14]
                        _7965 = mem[_7909 + 32]
                        require mem[_7909 + 32] == mem[_7909 + 50 len 14]
                        require mem[_7909 + 64] == mem[_7909 + 92 len 4]
                        if _7866 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_7909 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_7909 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _7866 and 997 > -1 / _7866:
                            revert with 'NH{q', 17
                        if 997 * _7866 / 997 != _7866:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_7909 + 18 len 14]:
                            if mem[_7909 + 50 len 14] and 1000 > -1 / mem[_7909 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7909 + 50 len 14] / 1000 != mem[_7909 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7909 + 50 len 14] > (-997 * _7866) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7909 + 50 len 14]) + (997 * _7866) < 1000 * mem[_7909 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7909 + 50 len 14]) + (997 * _7866):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_7909 + 50 len 14]) + (997 * _7866)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _7965)) + (997 * _7866))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8680 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8706 = mem[_8680]
                            require mem[_8680] == mem[_8680]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8833 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _8908 = mem[_8833]
                            require mem[_8833] == mem[_8833 + 18 len 14]
                            _8986 = mem[_8833 + 32]
                            require mem[_8833 + 32] == mem[_8833 + 50 len 14]
                            require mem[_8833 + 64] == mem[_8833 + 92 len 4]
                            if _8706 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_8833 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_8833 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8706 and 997 > -1 / _8706:
                                revert with 'NH{q', 17
                            if 997 * _8706 / 997 != _8706:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_8833 + 18 len 14]:
                                if mem[_8833 + 50 len 14] and 1000 > -1 / mem[_8833 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8833 + 50 len 14] / 1000 != mem[_8833 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8833 + 50 len 14] > (-997 * _8706) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8833 + 50 len 14]) + (997 * _8706) < 1000 * mem[_8833 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8833 + 50 len 14]) + (997 * _8706):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10182 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10182] == mem[_10182 + 18 len 14]
                                require mem[_10182 + 32] == mem[_10182 + 50 len 14]
                                require mem[_10182 + 64] == mem[_10182 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10182 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10182 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) / 997 != 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10182 + 18 len 14]:
                                    if mem[_10182 + 50 len 14] and 1000 > -1 / mem[_10182 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10182 + 50 len 14] / 1000 != mem[_10182 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10182 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) < 1000 * mem[_10182 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) and mem[_10182 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                        revert with 'NH{q', 17
                                    if not mem[_10182 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) * mem[_10182 + 18 len 14] / mem[_10182 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10182 + 50 len 14] and 1000 > -1 / mem[_10182 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10182 + 50 len 14] / 1000 != mem[_10182 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10182 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) < 1000 * mem[_10182 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706) * mem[_10182 + 18 len 14] / (1000 * mem[_10182 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8986)) + (997 * _8706))
                            else:
                                if 997 * _8706 and mem[_8833 + 18 len 14] > -1 / 997 * _8706:
                                    revert with 'NH{q', 17
                                if not mem[_8833 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8706 * mem[_8833 + 18 len 14] / mem[_8833 + 18 len 14] != 997 * _8706:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_8833 + 50 len 14] and 1000 > -1 / mem[_8833 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_8833 + 50 len 14] / 1000 != mem[_8833 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_8833 + 50 len 14] > (-997 * _8706) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_8833 + 50 len 14]) + (997 * _8706) < 1000 * mem[_8833 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_8833 + 50 len 14]) + (997 * _8706):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10548 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10548] == mem[_10548 + 18 len 14]
                                require mem[_10548 + 32] == mem[_10548 + 50 len 14]
                                require mem[_10548 + 64] == mem[_10548 + 92 len 4]
                                if 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10548 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10548 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) and 997 > -1 / 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) / 997 != 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10548 + 18 len 14]:
                                    if mem[_10548 + 50 len 14] and 1000 > -1 / mem[_10548 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10548 + 50 len 14] / 1000 != mem[_10548 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10548 + 50 len 14] > (-997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) < 1000 * mem[_10548 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706))
                                else:
                                    if 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) and mem[_10548 + 18 len 14] > -1 / 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                        revert with 'NH{q', 17
                                    if not mem[_10548 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) * mem[_10548 + 18 len 14] / mem[_10548 + 18 len 14] != 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10548 + 50 len 14] and 1000 > -1 / mem[_10548 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10548 + 50 len 14] / 1000 != mem[_10548 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10548 + 50 len 14] > (-997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)) < 1000 * mem[_10548 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706) * mem[_10548 + 18 len 14] / (1000 * mem[_10548 + 50 len 14]) + (997 * 997 * _8706 * Mask(112, 0, _8908) / (1000 * Mask(112, 0, _8986)) + (997 * _8706))
                        else:
                            if 997 * _7866 and mem[_7909 + 18 len 14] > -1 / 997 * _7866:
                                revert with 'NH{q', 17
                            if not mem[_7909 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _7866 * mem[_7909 + 18 len 14] / mem[_7909 + 18 len 14] != 997 * _7866:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_7909 + 50 len 14] and 1000 > -1 / mem[_7909 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_7909 + 50 len 14] / 1000 != mem[_7909 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_7909 + 50 len 14] > (-997 * _7866) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_7909 + 50 len 14]) + (997 * _7866) < 1000 * mem[_7909 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_7909 + 50 len 14]) + (997 * _7866):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _7866 * mem[_7909 + 18 len 14] / (1000 * mem[_7909 + 50 len 14]) + (997 * _7866)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _7866 * Mask(112, 0, _7930) / (1000 * Mask(112, 0, _7965)) + (997 * _7866))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8909 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8939 = mem[_8909]
                            require mem[_8909] == mem[_8909]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9077 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9150 = mem[_9077]
                            require mem[_9077] == mem[_9077 + 18 len 14]
                            _9211 = mem[_9077 + 32]
                            require mem[_9077 + 32] == mem[_9077 + 50 len 14]
                            require mem[_9077 + 64] == mem[_9077 + 92 len 4]
                            if _8939 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9077 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9077 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8939 and 997 > -1 / _8939:
                                revert with 'NH{q', 17
                            if 997 * _8939 / 997 != _8939:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9077 + 18 len 14]:
                                if mem[_9077 + 50 len 14] and 1000 > -1 / mem[_9077 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9077 + 50 len 14] / 1000 != mem[_9077 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9077 + 50 len 14] > (-997 * _8939) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9077 + 50 len 14]) + (997 * _8939) < 1000 * mem[_9077 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9077 + 50 len 14]) + (997 * _8939):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10549 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10549] == mem[_10549 + 18 len 14]
                                require mem[_10549 + 32] == mem[_10549 + 50 len 14]
                                require mem[_10549 + 64] == mem[_10549 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10549 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10549 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) / 997 != 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10549 + 18 len 14]:
                                    if mem[_10549 + 50 len 14] and 1000 > -1 / mem[_10549 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10549 + 50 len 14] / 1000 != mem[_10549 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10549 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) < 1000 * mem[_10549 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) and mem[_10549 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                        revert with 'NH{q', 17
                                    if not mem[_10549 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) * mem[_10549 + 18 len 14] / mem[_10549 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10549 + 50 len 14] and 1000 > -1 / mem[_10549 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10549 + 50 len 14] / 1000 != mem[_10549 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10549 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) < 1000 * mem[_10549 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939) * mem[_10549 + 18 len 14] / (1000 * mem[_10549 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9211)) + (997 * _8939))
                            else:
                                if 997 * _8939 and mem[_9077 + 18 len 14] > -1 / 997 * _8939:
                                    revert with 'NH{q', 17
                                if not mem[_9077 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8939 * mem[_9077 + 18 len 14] / mem[_9077 + 18 len 14] != 997 * _8939:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9077 + 50 len 14] and 1000 > -1 / mem[_9077 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9077 + 50 len 14] / 1000 != mem[_9077 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9077 + 50 len 14] > (-997 * _8939) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9077 + 50 len 14]) + (997 * _8939) < 1000 * mem[_9077 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9077 + 50 len 14]) + (997 * _8939):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10973 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10973] == mem[_10973 + 18 len 14]
                                require mem[_10973 + 32] == mem[_10973 + 50 len 14]
                                require mem[_10973 + 64] == mem[_10973 + 92 len 4]
                                if 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10973 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10973 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) and 997 > -1 / 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) / 997 != 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10973 + 18 len 14]:
                                    if mem[_10973 + 50 len 14] and 1000 > -1 / mem[_10973 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10973 + 50 len 14] / 1000 != mem[_10973 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10973 + 50 len 14] > (-997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) < 1000 * mem[_10973 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939))
                                else:
                                    if 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) and mem[_10973 + 18 len 14] > -1 / 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                        revert with 'NH{q', 17
                                    if not mem[_10973 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) * mem[_10973 + 18 len 14] / mem[_10973 + 18 len 14] != 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10973 + 50 len 14] and 1000 > -1 / mem[_10973 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10973 + 50 len 14] / 1000 != mem[_10973 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10973 + 50 len 14] > (-997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)) < 1000 * mem[_10973 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939) * mem[_10973 + 18 len 14] / (1000 * mem[_10973 + 50 len 14]) + (997 * 997 * _8939 * Mask(112, 0, _9150) / (1000 * Mask(112, 0, _9211)) + (997 * _8939))
                    else:
                        if 997 * _7446 and mem[_7487 + 50 len 14] > -1 / 997 * _7446:
                            revert with 'NH{q', 17
                        if not mem[_7487 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7446 * mem[_7487 + 50 len 14] / mem[_7487 + 50 len 14] != 997 * _7446:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7487 + 18 len 14] and 1000 > -1 / mem[_7487 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7487 + 18 len 14] / 1000 != mem[_7487 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7487 + 18 len 14] > (-997 * _7446) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7487 + 18 len 14]) + (997 * _7446) < 1000 * mem[_7487 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7487 + 18 len 14]) + (997 * _7446):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7446 * mem[_7487 + 50 len 14] / (1000 * mem[_7487 + 18 len 14]) + (997 * _7446)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _8001 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8047 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8077 = mem[_8047]
                        require mem[_8047] == mem[_8047 + 18 len 14]
                        _8103 = mem[_8047 + 32]
                        require mem[_8047 + 32] == mem[_8047 + 50 len 14]
                        require mem[_8047 + 64] == mem[_8047 + 92 len 4]
                        if _8001 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8047 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8047 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8001 and 997 > -1 / _8001:
                            revert with 'NH{q', 17
                        if 997 * _8001 / 997 != _8001:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8047 + 18 len 14]:
                            if mem[_8047 + 50 len 14] and 1000 > -1 / mem[_8047 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8047 + 50 len 14] / 1000 != mem[_8047 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8047 + 50 len 14] > (-997 * _8001) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8047 + 50 len 14]) + (997 * _8001) < 1000 * mem[_8047 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8047 + 50 len 14]) + (997 * _8001):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8047 + 50 len 14]) + (997 * _8001)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8103)) + (997 * _8001))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8910 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8940 = mem[_8910]
                            require mem[_8910] == mem[_8910]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9078 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9151 = mem[_9078]
                            require mem[_9078] == mem[_9078 + 18 len 14]
                            _9212 = mem[_9078 + 32]
                            require mem[_9078 + 32] == mem[_9078 + 50 len 14]
                            require mem[_9078 + 64] == mem[_9078 + 92 len 4]
                            if _8940 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9078 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9078 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8940 and 997 > -1 / _8940:
                                revert with 'NH{q', 17
                            if 997 * _8940 / 997 != _8940:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9078 + 18 len 14]:
                                if mem[_9078 + 50 len 14] and 1000 > -1 / mem[_9078 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9078 + 50 len 14] / 1000 != mem[_9078 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9078 + 50 len 14] > (-997 * _8940) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9078 + 50 len 14]) + (997 * _8940) < 1000 * mem[_9078 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9078 + 50 len 14]) + (997 * _8940):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10551 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10551] == mem[_10551 + 18 len 14]
                                require mem[_10551 + 32] == mem[_10551 + 50 len 14]
                                require mem[_10551 + 64] == mem[_10551 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10551 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10551 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) / 997 != 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10551 + 18 len 14]:
                                    if mem[_10551 + 50 len 14] and 1000 > -1 / mem[_10551 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10551 + 50 len 14] / 1000 != mem[_10551 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10551 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) < 1000 * mem[_10551 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) and mem[_10551 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                        revert with 'NH{q', 17
                                    if not mem[_10551 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) * mem[_10551 + 18 len 14] / mem[_10551 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10551 + 50 len 14] and 1000 > -1 / mem[_10551 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10551 + 50 len 14] / 1000 != mem[_10551 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10551 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) < 1000 * mem[_10551 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940) * mem[_10551 + 18 len 14] / (1000 * mem[_10551 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9212)) + (997 * _8940))
                            else:
                                if 997 * _8940 and mem[_9078 + 18 len 14] > -1 / 997 * _8940:
                                    revert with 'NH{q', 17
                                if not mem[_9078 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8940 * mem[_9078 + 18 len 14] / mem[_9078 + 18 len 14] != 997 * _8940:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9078 + 50 len 14] and 1000 > -1 / mem[_9078 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9078 + 50 len 14] / 1000 != mem[_9078 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9078 + 50 len 14] > (-997 * _8940) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9078 + 50 len 14]) + (997 * _8940) < 1000 * mem[_9078 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9078 + 50 len 14]) + (997 * _8940):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10974 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10974] == mem[_10974 + 18 len 14]
                                require mem[_10974 + 32] == mem[_10974 + 50 len 14]
                                require mem[_10974 + 64] == mem[_10974 + 92 len 4]
                                if 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10974 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10974 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) and 997 > -1 / 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) / 997 != 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10974 + 18 len 14]:
                                    if mem[_10974 + 50 len 14] and 1000 > -1 / mem[_10974 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10974 + 50 len 14] / 1000 != mem[_10974 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10974 + 50 len 14] > (-997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) < 1000 * mem[_10974 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940))
                                else:
                                    if 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) and mem[_10974 + 18 len 14] > -1 / 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                        revert with 'NH{q', 17
                                    if not mem[_10974 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) * mem[_10974 + 18 len 14] / mem[_10974 + 18 len 14] != 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10974 + 50 len 14] and 1000 > -1 / mem[_10974 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10974 + 50 len 14] / 1000 != mem[_10974 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10974 + 50 len 14] > (-997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)) < 1000 * mem[_10974 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940) * mem[_10974 + 18 len 14] / (1000 * mem[_10974 + 50 len 14]) + (997 * 997 * _8940 * Mask(112, 0, _9151) / (1000 * Mask(112, 0, _9212)) + (997 * _8940))
                        else:
                            if 997 * _8001 and mem[_8047 + 18 len 14] > -1 / 997 * _8001:
                                revert with 'NH{q', 17
                            if not mem[_8047 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8001 * mem[_8047 + 18 len 14] / mem[_8047 + 18 len 14] != 997 * _8001:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8047 + 50 len 14] and 1000 > -1 / mem[_8047 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8047 + 50 len 14] / 1000 != mem[_8047 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8047 + 50 len 14] > (-997 * _8001) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8047 + 50 len 14]) + (997 * _8001) < 1000 * mem[_8047 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8047 + 50 len 14]) + (997 * _8001):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _8001 * mem[_8047 + 18 len 14] / (1000 * mem[_8047 + 50 len 14]) + (997 * _8001)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _8001 * Mask(112, 0, _8077) / (1000 * Mask(112, 0, _8103)) + (997 * _8001))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9152 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9183 = mem[_9152]
                            require mem[_9152] == mem[_9152]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9311 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9377 = mem[_9311]
                            require mem[_9311] == mem[_9311 + 18 len 14]
                            _9435 = mem[_9311 + 32]
                            require mem[_9311 + 32] == mem[_9311 + 50 len 14]
                            require mem[_9311 + 64] == mem[_9311 + 92 len 4]
                            if _9183 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9311 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9311 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9183 and 997 > -1 / _9183:
                                revert with 'NH{q', 17
                            if 997 * _9183 / 997 != _9183:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9311 + 18 len 14]:
                                if mem[_9311 + 50 len 14] and 1000 > -1 / mem[_9311 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9311 + 50 len 14] / 1000 != mem[_9311 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9311 + 50 len 14] > (-997 * _9183) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9311 + 50 len 14]) + (997 * _9183) < 1000 * mem[_9311 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9311 + 50 len 14]) + (997 * _9183):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10975 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10975] == mem[_10975 + 18 len 14]
                                require mem[_10975 + 32] == mem[_10975 + 50 len 14]
                                require mem[_10975 + 64] == mem[_10975 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10975 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10975 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) / 997 != 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10975 + 18 len 14]:
                                    if mem[_10975 + 50 len 14] and 1000 > -1 / mem[_10975 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10975 + 50 len 14] / 1000 != mem[_10975 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10975 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) < 1000 * mem[_10975 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) and mem[_10975 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                        revert with 'NH{q', 17
                                    if not mem[_10975 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) * mem[_10975 + 18 len 14] / mem[_10975 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10975 + 50 len 14] and 1000 > -1 / mem[_10975 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10975 + 50 len 14] / 1000 != mem[_10975 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10975 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) < 1000 * mem[_10975 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183) * mem[_10975 + 18 len 14] / (1000 * mem[_10975 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9435)) + (997 * _9183))
                            else:
                                if 997 * _9183 and mem[_9311 + 18 len 14] > -1 / 997 * _9183:
                                    revert with 'NH{q', 17
                                if not mem[_9311 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9183 * mem[_9311 + 18 len 14] / mem[_9311 + 18 len 14] != 997 * _9183:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9311 + 50 len 14] and 1000 > -1 / mem[_9311 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9311 + 50 len 14] / 1000 != mem[_9311 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9311 + 50 len 14] > (-997 * _9183) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9311 + 50 len 14]) + (997 * _9183) < 1000 * mem[_9311 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9311 + 50 len 14]) + (997 * _9183):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11403 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11403] == mem[_11403 + 18 len 14]
                                require mem[_11403 + 32] == mem[_11403 + 50 len 14]
                                require mem[_11403 + 64] == mem[_11403 + 92 len 4]
                                if 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11403 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11403 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) and 997 > -1 / 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) / 997 != 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11403 + 18 len 14]:
                                    if mem[_11403 + 50 len 14] and 1000 > -1 / mem[_11403 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11403 + 50 len 14] / 1000 != mem[_11403 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11403 + 50 len 14] > (-997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) < 1000 * mem[_11403 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183))
                                else:
                                    if 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) and mem[_11403 + 18 len 14] > -1 / 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                        revert with 'NH{q', 17
                                    if not mem[_11403 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) * mem[_11403 + 18 len 14] / mem[_11403 + 18 len 14] != 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11403 + 50 len 14] and 1000 > -1 / mem[_11403 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11403 + 50 len 14] / 1000 != mem[_11403 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11403 + 50 len 14] > (-997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)) < 1000 * mem[_11403 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183) * mem[_11403 + 18 len 14] / (1000 * mem[_11403 + 50 len 14]) + (997 * 997 * _9183 * Mask(112, 0, _9377) / (1000 * Mask(112, 0, _9435)) + (997 * _9183))
                else:
                    if 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) and mem[_7216 + 50 len 14] > -1 / 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                        revert with 'NH{q', 17
                    if not mem[_7216 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * mem[_7216 + 50 len 14] / mem[_7216 + 50 len 14] != 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067):
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7216 + 18 len 14] and 1000 > -1 / mem[_7216 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7216 + 18 len 14] / 1000 != mem[_7216 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7216 + 18 len 14] > (-997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)) < 1000 * mem[_7216 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)):
                        revert with 'NH{q', 18
                    mem[mem[64] + 4] = 997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * mem[_7216 + 50 len 14] / (1000 * mem[_7216 + 18 len 14]) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067))
                    require ext_code.size(stor6)
                    staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                            gas gas_remaining wei
                           args (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067) * Mask(112, 0, _7228) / (1000 * Mask(112, 0, _7224)) + (997 * 997 * _7067 * Mask(112, 0, _7099) / (1000 * Mask(112, 0, _7088)) + (997 * _7067)))
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7506 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7512 = mem[_7506]
                    require mem[_7506] == mem[_7506]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7544 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    require mem[_7544] == mem[_7544 + 18 len 14]
                    require mem[_7544 + 32] == mem[_7544 + 50 len 14]
                    require mem[_7544 + 64] == mem[_7544 + 92 len 4]
                    if _7512 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7544 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7544 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7512 and 997 > -1 / _7512:
                        revert with 'NH{q', 17
                    if 997 * _7512 / 997 != _7512:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7544 + 50 len 14]:
                        if mem[_7544 + 18 len 14] and 1000 > -1 / mem[_7544 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7544 + 18 len 14] / 1000 != mem[_7544 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7544 + 18 len 14] > (-997 * _7512) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7544 + 18 len 14]) + (997 * _7512) < 1000 * mem[_7544 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7544 + 18 len 14]) + (997 * _7512):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7544 + 18 len 14]) + (997 * _7512)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _8002 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8048 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8078 = mem[_8048]
                        require mem[_8048] == mem[_8048 + 18 len 14]
                        _8104 = mem[_8048 + 32]
                        require mem[_8048 + 32] == mem[_8048 + 50 len 14]
                        require mem[_8048 + 64] == mem[_8048 + 92 len 4]
                        if _8002 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8048 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8048 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8002 and 997 > -1 / _8002:
                            revert with 'NH{q', 17
                        if 997 * _8002 / 997 != _8002:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8048 + 18 len 14]:
                            if mem[_8048 + 50 len 14] and 1000 > -1 / mem[_8048 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8048 + 50 len 14] / 1000 != mem[_8048 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8048 + 50 len 14] > (-997 * _8002) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8048 + 50 len 14]) + (997 * _8002) < 1000 * mem[_8048 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8048 + 50 len 14]) + (997 * _8002):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8048 + 50 len 14]) + (997 * _8002)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8104)) + (997 * _8002))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8911 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8941 = mem[_8911]
                            require mem[_8911] == mem[_8911]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9079 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9153 = mem[_9079]
                            require mem[_9079] == mem[_9079 + 18 len 14]
                            _9213 = mem[_9079 + 32]
                            require mem[_9079 + 32] == mem[_9079 + 50 len 14]
                            require mem[_9079 + 64] == mem[_9079 + 92 len 4]
                            if _8941 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9079 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9079 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _8941 and 997 > -1 / _8941:
                                revert with 'NH{q', 17
                            if 997 * _8941 / 997 != _8941:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9079 + 18 len 14]:
                                if mem[_9079 + 50 len 14] and 1000 > -1 / mem[_9079 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9079 + 50 len 14] / 1000 != mem[_9079 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9079 + 50 len 14] > (-997 * _8941) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9079 + 50 len 14]) + (997 * _8941) < 1000 * mem[_9079 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9079 + 50 len 14]) + (997 * _8941):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10554 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10554] == mem[_10554 + 18 len 14]
                                require mem[_10554 + 32] == mem[_10554 + 50 len 14]
                                require mem[_10554 + 64] == mem[_10554 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10554 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10554 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) / 997 != 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10554 + 18 len 14]:
                                    if mem[_10554 + 50 len 14] and 1000 > -1 / mem[_10554 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10554 + 50 len 14] / 1000 != mem[_10554 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10554 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) < 1000 * mem[_10554 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) and mem[_10554 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                        revert with 'NH{q', 17
                                    if not mem[_10554 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) * mem[_10554 + 18 len 14] / mem[_10554 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10554 + 50 len 14] and 1000 > -1 / mem[_10554 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10554 + 50 len 14] / 1000 != mem[_10554 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10554 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) < 1000 * mem[_10554 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941) * mem[_10554 + 18 len 14] / (1000 * mem[_10554 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9213)) + (997 * _8941))
                            else:
                                if 997 * _8941 and mem[_9079 + 18 len 14] > -1 / 997 * _8941:
                                    revert with 'NH{q', 17
                                if not mem[_9079 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _8941 * mem[_9079 + 18 len 14] / mem[_9079 + 18 len 14] != 997 * _8941:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9079 + 50 len 14] and 1000 > -1 / mem[_9079 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9079 + 50 len 14] / 1000 != mem[_9079 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9079 + 50 len 14] > (-997 * _8941) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9079 + 50 len 14]) + (997 * _8941) < 1000 * mem[_9079 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9079 + 50 len 14]) + (997 * _8941):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10977 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10977] == mem[_10977 + 18 len 14]
                                require mem[_10977 + 32] == mem[_10977 + 50 len 14]
                                require mem[_10977 + 64] == mem[_10977 + 92 len 4]
                                if 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10977 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10977 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) and 997 > -1 / 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) / 997 != 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10977 + 18 len 14]:
                                    if mem[_10977 + 50 len 14] and 1000 > -1 / mem[_10977 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10977 + 50 len 14] / 1000 != mem[_10977 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10977 + 50 len 14] > (-997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) < 1000 * mem[_10977 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941))
                                else:
                                    if 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) and mem[_10977 + 18 len 14] > -1 / 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                        revert with 'NH{q', 17
                                    if not mem[_10977 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) * mem[_10977 + 18 len 14] / mem[_10977 + 18 len 14] != 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10977 + 50 len 14] and 1000 > -1 / mem[_10977 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10977 + 50 len 14] / 1000 != mem[_10977 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10977 + 50 len 14] > (-997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)) < 1000 * mem[_10977 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941) * mem[_10977 + 18 len 14] / (1000 * mem[_10977 + 50 len 14]) + (997 * 997 * _8941 * Mask(112, 0, _9153) / (1000 * Mask(112, 0, _9213)) + (997 * _8941))
                        else:
                            if 997 * _8002 and mem[_8048 + 18 len 14] > -1 / 997 * _8002:
                                revert with 'NH{q', 17
                            if not mem[_8048 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8002 * mem[_8048 + 18 len 14] / mem[_8048 + 18 len 14] != 997 * _8002:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8048 + 50 len 14] and 1000 > -1 / mem[_8048 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8048 + 50 len 14] / 1000 != mem[_8048 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8048 + 50 len 14] > (-997 * _8002) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8048 + 50 len 14]) + (997 * _8002) < 1000 * mem[_8048 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8048 + 50 len 14]) + (997 * _8002):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _8002 * mem[_8048 + 18 len 14] / (1000 * mem[_8048 + 50 len 14]) + (997 * _8002)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _8002 * Mask(112, 0, _8078) / (1000 * Mask(112, 0, _8104)) + (997 * _8002))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9154 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9184 = mem[_9154]
                            require mem[_9154] == mem[_9154]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9312 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9378 = mem[_9312]
                            require mem[_9312] == mem[_9312 + 18 len 14]
                            _9436 = mem[_9312 + 32]
                            require mem[_9312 + 32] == mem[_9312 + 50 len 14]
                            require mem[_9312 + 64] == mem[_9312 + 92 len 4]
                            if _9184 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9312 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9312 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9184 and 997 > -1 / _9184:
                                revert with 'NH{q', 17
                            if 997 * _9184 / 997 != _9184:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9312 + 18 len 14]:
                                if mem[_9312 + 50 len 14] and 1000 > -1 / mem[_9312 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9312 + 50 len 14] / 1000 != mem[_9312 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9312 + 50 len 14] > (-997 * _9184) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9312 + 50 len 14]) + (997 * _9184) < 1000 * mem[_9312 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9312 + 50 len 14]) + (997 * _9184):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10978 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10978] == mem[_10978 + 18 len 14]
                                require mem[_10978 + 32] == mem[_10978 + 50 len 14]
                                require mem[_10978 + 64] == mem[_10978 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10978 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10978 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) / 997 != 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10978 + 18 len 14]:
                                    if mem[_10978 + 50 len 14] and 1000 > -1 / mem[_10978 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10978 + 50 len 14] / 1000 != mem[_10978 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10978 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) < 1000 * mem[_10978 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) and mem[_10978 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                        revert with 'NH{q', 17
                                    if not mem[_10978 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) * mem[_10978 + 18 len 14] / mem[_10978 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10978 + 50 len 14] and 1000 > -1 / mem[_10978 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10978 + 50 len 14] / 1000 != mem[_10978 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10978 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) < 1000 * mem[_10978 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184) * mem[_10978 + 18 len 14] / (1000 * mem[_10978 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9436)) + (997 * _9184))
                            else:
                                if 997 * _9184 and mem[_9312 + 18 len 14] > -1 / 997 * _9184:
                                    revert with 'NH{q', 17
                                if not mem[_9312 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9184 * mem[_9312 + 18 len 14] / mem[_9312 + 18 len 14] != 997 * _9184:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9312 + 50 len 14] and 1000 > -1 / mem[_9312 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9312 + 50 len 14] / 1000 != mem[_9312 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9312 + 50 len 14] > (-997 * _9184) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9312 + 50 len 14]) + (997 * _9184) < 1000 * mem[_9312 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9312 + 50 len 14]) + (997 * _9184):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11404 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11404] == mem[_11404 + 18 len 14]
                                require mem[_11404 + 32] == mem[_11404 + 50 len 14]
                                require mem[_11404 + 64] == mem[_11404 + 92 len 4]
                                if 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11404 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11404 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) and 997 > -1 / 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) / 997 != 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11404 + 18 len 14]:
                                    if mem[_11404 + 50 len 14] and 1000 > -1 / mem[_11404 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11404 + 50 len 14] / 1000 != mem[_11404 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11404 + 50 len 14] > (-997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) < 1000 * mem[_11404 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184))
                                else:
                                    if 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) and mem[_11404 + 18 len 14] > -1 / 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                        revert with 'NH{q', 17
                                    if not mem[_11404 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) * mem[_11404 + 18 len 14] / mem[_11404 + 18 len 14] != 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11404 + 50 len 14] and 1000 > -1 / mem[_11404 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11404 + 50 len 14] / 1000 != mem[_11404 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11404 + 50 len 14] > (-997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)) < 1000 * mem[_11404 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184) * mem[_11404 + 18 len 14] / (1000 * mem[_11404 + 50 len 14]) + (997 * 997 * _9184 * Mask(112, 0, _9378) / (1000 * Mask(112, 0, _9436)) + (997 * _9184))
                    else:
                        if 997 * _7512 and mem[_7544 + 50 len 14] > -1 / 997 * _7512:
                            revert with 'NH{q', 17
                        if not mem[_7544 + 50 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7512 * mem[_7544 + 50 len 14] / mem[_7544 + 50 len 14] != 997 * _7512:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7544 + 18 len 14] and 1000 > -1 / mem[_7544 + 18 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7544 + 18 len 14] / 1000 != mem[_7544 + 18 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7544 + 18 len 14] > (-997 * _7512) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7544 + 18 len 14]) + (997 * _7512) < 1000 * mem[_7544 + 18 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7544 + 18 len 14]) + (997 * _7512):
                            revert with 'NH{q', 18
                        if idx >= mem[(32 * ('cd', 4).length) + 128]:
                            revert with 'NH{q', 50
                        mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7512 * mem[_7544 + 50 len 14] / (1000 * mem[_7544 + 18 len 14]) + (997 * _7512)
                        if idx >= mem[96]:
                            revert with 'NH{q', 50
                        _8128 = mem[(32 * idx) + 128]
                        require ext_code.size(stor12)
                        staticcall stor12.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8164 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8196 = mem[_8164]
                        require mem[_8164] == mem[_8164 + 18 len 14]
                        _8228 = mem[_8164 + 32]
                        require mem[_8164 + 32] == mem[_8164 + 50 len 14]
                        require mem[_8164 + 64] == mem[_8164 + 92 len 4]
                        if _8128 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8164 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8164 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8128 and 997 > -1 / _8128:
                            revert with 'NH{q', 17
                        if 997 * _8128 / 997 != _8128:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8164 + 18 len 14]:
                            if mem[_8164 + 50 len 14] and 1000 > -1 / mem[_8164 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8164 + 50 len 14] / 1000 != mem[_8164 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8164 + 50 len 14] > (-997 * _8128) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8164 + 50 len 14]) + (997 * _8128) < 1000 * mem[_8164 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8164 + 50 len 14]) + (997 * _8128):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 0 / (1000 * mem[_8164 + 50 len 14]) + (997 * _8128)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (0 / (1000 * Mask(112, 0, _8228)) + (997 * _8128))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9155 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9185 = mem[_9155]
                            require mem[_9155] == mem[_9155]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9313 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9379 = mem[_9313]
                            require mem[_9313] == mem[_9313 + 18 len 14]
                            _9437 = mem[_9313 + 32]
                            require mem[_9313 + 32] == mem[_9313 + 50 len 14]
                            require mem[_9313 + 64] == mem[_9313 + 92 len 4]
                            if _9185 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9313 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9313 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9185 and 997 > -1 / _9185:
                                revert with 'NH{q', 17
                            if 997 * _9185 / 997 != _9185:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9313 + 18 len 14]:
                                if mem[_9313 + 50 len 14] and 1000 > -1 / mem[_9313 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9313 + 50 len 14] / 1000 != mem[_9313 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9313 + 50 len 14] > (-997 * _9185) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9313 + 50 len 14]) + (997 * _9185) < 1000 * mem[_9313 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9313 + 50 len 14]) + (997 * _9185):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _10980 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_10980] == mem[_10980 + 18 len 14]
                                require mem[_10980 + 32] == mem[_10980 + 50 len 14]
                                require mem[_10980 + 64] == mem[_10980 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_10980 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_10980 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) / 997 != 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_10980 + 18 len 14]:
                                    if mem[_10980 + 50 len 14] and 1000 > -1 / mem[_10980 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10980 + 50 len 14] / 1000 != mem[_10980 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10980 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) < 1000 * mem[_10980 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) and mem[_10980 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                        revert with 'NH{q', 17
                                    if not mem[_10980 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) * mem[_10980 + 18 len 14] / mem[_10980 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_10980 + 50 len 14] and 1000 > -1 / mem[_10980 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_10980 + 50 len 14] / 1000 != mem[_10980 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_10980 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) < 1000 * mem[_10980 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185) * mem[_10980 + 18 len 14] / (1000 * mem[_10980 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9437)) + (997 * _9185))
                            else:
                                if 997 * _9185 and mem[_9313 + 18 len 14] > -1 / 997 * _9185:
                                    revert with 'NH{q', 17
                                if not mem[_9313 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9185 * mem[_9313 + 18 len 14] / mem[_9313 + 18 len 14] != 997 * _9185:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9313 + 50 len 14] and 1000 > -1 / mem[_9313 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9313 + 50 len 14] / 1000 != mem[_9313 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9313 + 50 len 14] > (-997 * _9185) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9313 + 50 len 14]) + (997 * _9185) < 1000 * mem[_9313 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9313 + 50 len 14]) + (997 * _9185):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11405 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11405] == mem[_11405 + 18 len 14]
                                require mem[_11405 + 32] == mem[_11405 + 50 len 14]
                                require mem[_11405 + 64] == mem[_11405 + 92 len 4]
                                if 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11405 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11405 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) and 997 > -1 / 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) / 997 != 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11405 + 18 len 14]:
                                    if mem[_11405 + 50 len 14] and 1000 > -1 / mem[_11405 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11405 + 50 len 14] / 1000 != mem[_11405 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11405 + 50 len 14] > (-997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) < 1000 * mem[_11405 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185))
                                else:
                                    if 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) and mem[_11405 + 18 len 14] > -1 / 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                        revert with 'NH{q', 17
                                    if not mem[_11405 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) * mem[_11405 + 18 len 14] / mem[_11405 + 18 len 14] != 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11405 + 50 len 14] and 1000 > -1 / mem[_11405 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11405 + 50 len 14] / 1000 != mem[_11405 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11405 + 50 len 14] > (-997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)) < 1000 * mem[_11405 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185) * mem[_11405 + 18 len 14] / (1000 * mem[_11405 + 50 len 14]) + (997 * 997 * _9185 * Mask(112, 0, _9379) / (1000 * Mask(112, 0, _9437)) + (997 * _9185))
                        else:
                            if 997 * _8128 and mem[_8164 + 18 len 14] > -1 / 997 * _8128:
                                revert with 'NH{q', 17
                            if not mem[_8164 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8128 * mem[_8164 + 18 len 14] / mem[_8164 + 18 len 14] != 997 * _8128:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8164 + 50 len 14] and 1000 > -1 / mem[_8164 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8164 + 50 len 14] / 1000 != mem[_8164 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8164 + 50 len 14] > (-997 * _8128) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8164 + 50 len 14]) + (997 * _8128) < 1000 * mem[_8164 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8164 + 50 len 14]) + (997 * _8128):
                                revert with 'NH{q', 18
                            mem[mem[64] + 4] = 997 * _8128 * mem[_8164 + 18 len 14] / (1000 * mem[_8164 + 50 len 14]) + (997 * _8128)
                            require ext_code.size(stor6)
                            staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                    gas gas_remaining wei
                                   args (997 * _8128 * Mask(112, 0, _8196) / (1000 * Mask(112, 0, _8228)) + (997 * _8128))
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9380 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _9420 = mem[_9380]
                            require mem[_9380] == mem[_9380]
                            require ext_code.size(stor14)
                            staticcall stor14.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9524 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _9584 = mem[_9524]
                            require mem[_9524] == mem[_9524 + 18 len 14]
                            _9659 = mem[_9524 + 32]
                            require mem[_9524 + 32] == mem[_9524 + 50 len 14]
                            require mem[_9524 + 64] == mem[_9524 + 92 len 4]
                            if _9420 <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9524 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9524 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if _9420 and 997 > -1 / _9420:
                                revert with 'NH{q', 17
                            if 997 * _9420 / 997 != _9420:
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9524 + 18 len 14]:
                                if mem[_9524 + 50 len 14] and 1000 > -1 / mem[_9524 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9524 + 50 len 14] / 1000 != mem[_9524 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9524 + 50 len 14] > (-997 * _9420) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9524 + 50 len 14]) + (997 * _9420) < 1000 * mem[_9524 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9524 + 50 len 14]) + (997 * _9420):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11406 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11406] == mem[_11406 + 18 len 14]
                                require mem[_11406 + 32] == mem[_11406 + 50 len 14]
                                require mem[_11406 + 64] == mem[_11406 + 92 len 4]
                                if 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11406 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11406 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                    revert with 'NH{q', 17
                                if 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) / 997 != 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11406 + 18 len 14]:
                                    if mem[_11406 + 50 len 14] and 1000 > -1 / mem[_11406 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11406 + 50 len 14] / 1000 != mem[_11406 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11406 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) < 1000 * mem[_11406 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420))
                                else:
                                    if 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) and mem[_11406 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                        revert with 'NH{q', 17
                                    if not mem[_11406 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) * mem[_11406 + 18 len 14] / mem[_11406 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11406 + 50 len 14] and 1000 > -1 / mem[_11406 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11406 + 50 len 14] / 1000 != mem[_11406 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11406 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) < 1000 * mem[_11406 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420) * mem[_11406 + 18 len 14] / (1000 * mem[_11406 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9659)) + (997 * _9420))
                            else:
                                if 997 * _9420 and mem[_9524 + 18 len 14] > -1 / 997 * _9420:
                                    revert with 'NH{q', 17
                                if not mem[_9524 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * _9420 * mem[_9524 + 18 len 14] / mem[_9524 + 18 len 14] != 997 * _9420:
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9524 + 50 len 14] and 1000 > -1 / mem[_9524 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9524 + 50 len 14] / 1000 != mem[_9524 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9524 + 50 len 14] > (-997 * _9420) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9524 + 50 len 14]) + (997 * _9420) < 1000 * mem[_9524 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9524 + 50 len 14]) + (997 * _9420):
                                    revert with 'NH{q', 18
                                require ext_code.size(stor13)
                                staticcall stor13.getReserves() with:
                                        gas gas_remaining wei
                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11804 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 96
                                require mem[_11804] == mem[_11804 + 18 len 14]
                                require mem[_11804 + 32] == mem[_11804 + 50 len 14]
                                require mem[_11804 + 64] == mem[_11804 + 92 len 4]
                                if 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                                if mem[_11804 + 50 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if mem[_11804 + 18 len 14] <= 0:
                                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                                if 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) and 997 > -1 / 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                    revert with 'NH{q', 17
                                if 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) / 997 != 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                    revert with 0, 'ds-math-mul-overflow'
                                if not mem[_11804 + 18 len 14]:
                                    if mem[_11804 + 50 len 14] and 1000 > -1 / mem[_11804 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11804 + 50 len 14] / 1000 != mem[_11804 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11804 + 50 len 14] > (-997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) < 1000 * mem[_11804 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420))
                                else:
                                    if 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) and mem[_11804 + 18 len 14] > -1 / 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                        revert with 'NH{q', 17
                                    if not mem[_11804 + 18 len 14]:
                                        revert with 'NH{q', 18
                                    if 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) * mem[_11804 + 18 len 14] / mem[_11804 + 18 len 14] != 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420):
                                        revert with 0, 'ds-math-mul-overflow'
                                    if mem[_11804 + 50 len 14] and 1000 > -1 / mem[_11804 + 50 len 14]:
                                        revert with 'NH{q', 17
                                    if 1000 * mem[_11804 + 50 len 14] / 1000 != mem[_11804 + 50 len 14]:
                                        revert with 0, 'ds-math-mul-overflow'
                                    if 1000 * mem[_11804 + 50 len 14] > (-997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) - 1:
                                        revert with 'NH{q', 17
                                    if (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)) < 1000 * mem[_11804 + 50 len 14]:
                                        revert with 0, 'ds-math-add-overflow'
                                    if not (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420)):
                                        revert with 'NH{q', 18
                                    if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                        revert with 'NH{q', 50
                                    mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420) * mem[_11804 + 18 len 14] / (1000 * mem[_11804 + 50 len 14]) + (997 * 997 * _9420 * Mask(112, 0, _9584) / (1000 * Mask(112, 0, _9659)) + (997 * _9420))
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        _7066 = mem[64]
        mem[mem[64]] = 64
        _7082 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 64] = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 96 len 32 * _7082] = mem[(32 * ('cd', 4).length) + 160 len 32 * _7082]
        mem[mem[64] + 32] = (32 * _7082) + 96
        _7408 = mem[(64 * ('cd', 4).length) + 160]
        mem[_7066 + (32 * _7082) + 96] = mem[(64 * ('cd', 4).length) + 160]
        mem[_7066 + (32 * _7082) + 128 len 32 * _7408] = mem[(64 * ('cd', 4).length) + 192 len 32 * _7408]
        return memory
          from mem[64]
           len _7066 + (32 * _7082) + (32 * _7408) + -mem[64] + 128
    mem[(64 * ('cd', 4).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 'NH{q', 50
        _7069 = mem[(32 * idx) + 128]
        require ext_code.size(stor13)
        staticcall stor13.getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _7085 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _7089 = mem[_7085]
        require mem[_7085] == mem[_7085 + 18 len 14]
        _7101 = mem[_7085 + 32]
        require mem[_7085 + 32] == mem[_7085 + 50 len 14]
        require mem[_7085 + 64] == mem[_7085 + 92 len 4]
        if _7069 <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
        if mem[_7085 + 18 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if mem[_7085 + 50 len 14] <= 0:
            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
        if _7069 and 997 > -1 / _7069:
            revert with 'NH{q', 17
        if 997 * _7069 / 997 != _7069:
            revert with 0, 'ds-math-mul-overflow'
        if not mem[_7085 + 50 len 14]:
            if mem[_7085 + 18 len 14] and 1000 > -1 / mem[_7085 + 18 len 14]:
                revert with 'NH{q', 17
            if 1000 * mem[_7085 + 18 len 14] / 1000 != mem[_7085 + 18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * mem[_7085 + 18 len 14] > (-997 * _7069) - 1:
                revert with 'NH{q', 17
            if (1000 * mem[_7085 + 18 len 14]) + (997 * _7069) < 1000 * mem[_7085 + 18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * mem[_7085 + 18 len 14]) + (997 * _7069):
                revert with 'NH{q', 18
            require ext_code.size(stor14)
            staticcall stor14.getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7188 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _7193 = mem[_7188]
            require mem[_7188] == mem[_7188 + 18 len 14]
            _7204 = mem[_7188 + 32]
            require mem[_7188 + 32] == mem[_7188 + 50 len 14]
            require mem[_7188 + 64] == mem[_7188 + 92 len 4]
            if 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
            if mem[_7188 + 18 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if mem[_7188 + 50 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) and 997 > -1 / 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                revert with 'NH{q', 17
            if 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) / 997 != 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                revert with 0, 'ds-math-mul-overflow'
            if not mem[_7188 + 50 len 14]:
                if mem[_7188 + 18 len 14] and 1000 > -1 / mem[_7188 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7188 + 18 len 14] / 1000 != mem[_7188 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7188 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) < 1000 * mem[_7188 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)):
                    revert with 'NH{q', 18
                mem[mem[64] + 4] = 0 / (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069))
                require ext_code.size(stor6)
                staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                        gas gas_remaining wei
                       args (0 / (1000 * Mask(112, 0, _7193)) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7365 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7372 = mem[_7365]
                require mem[_7365] == mem[_7365]
                require ext_code.size(stor12)
                staticcall stor12.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7413 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_7413] == mem[_7413 + 18 len 14]
                require mem[_7413 + 32] == mem[_7413 + 50 len 14]
                require mem[_7413 + 64] == mem[_7413 + 92 len 4]
                if _7372 <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7413 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7413 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if _7372 and 997 > -1 / _7372:
                    revert with 'NH{q', 17
                if 997 * _7372 / 997 != _7372:
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7413 + 50 len 14]:
                    if mem[_7413 + 18 len 14] and 1000 > -1 / mem[_7413 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7413 + 18 len 14] / 1000 != mem[_7413 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7413 + 18 len 14] > (-997 * _7372) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7413 + 18 len 14]) + (997 * _7372) < 1000 * mem[_7413 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7413 + 18 len 14]) + (997 * _7372):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7413 + 18 len 14]) + (997 * _7372)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _7757 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7778 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7789 = mem[_7778]
                    require mem[_7778] == mem[_7778 + 18 len 14]
                    _7830 = mem[_7778 + 32]
                    require mem[_7778 + 32] == mem[_7778 + 50 len 14]
                    require mem[_7778 + 64] == mem[_7778 + 92 len 4]
                    if _7757 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7778 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7778 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7757 and 997 > -1 / _7757:
                        revert with 'NH{q', 17
                    if 997 * _7757 / 997 != _7757:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7778 + 18 len 14]:
                        if mem[_7778 + 50 len 14] and 1000 > -1 / mem[_7778 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7778 + 50 len 14] / 1000 != mem[_7778 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7778 + 50 len 14] > (-997 * _7757) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7778 + 50 len 14]) + (997 * _7757) < 1000 * mem[_7778 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7778 + 50 len 14]) + (997 * _7757):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7778 + 50 len 14]) + (997 * _7757)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7830)) + (997 * _7757))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8501 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8527 = mem[_8501]
                        require mem[_8501] == mem[_8501]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8681 = mem[_8621]
                        require mem[_8621] == mem[_8621 + 18 len 14]
                        _8767 = mem[_8621 + 32]
                        require mem[_8621 + 32] == mem[_8621 + 50 len 14]
                        require mem[_8621 + 64] == mem[_8621 + 92 len 4]
                        if _8527 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8621 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8621 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8527 and 997 > -1 / _8527:
                            revert with 'NH{q', 17
                        if 997 * _8527 / 997 != _8527:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8621 + 18 len 14]:
                            if mem[_8621 + 50 len 14] and 1000 > -1 / mem[_8621 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8621 + 50 len 14] / 1000 != mem[_8621 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8621 + 50 len 14] > (-997 * _8527) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8621 + 50 len 14]) + (997 * _8527) < 1000 * mem[_8621 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8621 + 50 len 14]) + (997 * _8527):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9916 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_9916] == mem[_9916 + 18 len 14]
                            require mem[_9916 + 32] == mem[_9916 + 50 len 14]
                            require mem[_9916 + 64] == mem[_9916 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_9916 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_9916 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) / 997 != 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_9916 + 18 len 14]:
                                if mem[_9916 + 50 len 14] and 1000 > -1 / mem[_9916 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9916 + 50 len 14] / 1000 != mem[_9916 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9916 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) < 1000 * mem[_9916 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) and mem[_9916 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                    revert with 'NH{q', 17
                                if not mem[_9916 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) * mem[_9916 + 18 len 14] / mem[_9916 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_9916 + 50 len 14] and 1000 > -1 / mem[_9916 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_9916 + 50 len 14] / 1000 != mem[_9916 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_9916 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) < 1000 * mem[_9916 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527) * mem[_9916 + 18 len 14] / (1000 * mem[_9916 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8767)) + (997 * _8527))
                        else:
                            if 997 * _8527 and mem[_8621 + 18 len 14] > -1 / 997 * _8527:
                                revert with 'NH{q', 17
                            if not mem[_8621 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8527 * mem[_8621 + 18 len 14] / mem[_8621 + 18 len 14] != 997 * _8527:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8621 + 50 len 14] and 1000 > -1 / mem[_8621 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8621 + 50 len 14] / 1000 != mem[_8621 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8621 + 50 len 14] > (-997 * _8527) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8621 + 50 len 14]) + (997 * _8527) < 1000 * mem[_8621 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8621 + 50 len 14]) + (997 * _8527):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10187 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10187] == mem[_10187 + 18 len 14]
                            require mem[_10187 + 32] == mem[_10187 + 50 len 14]
                            require mem[_10187 + 64] == mem[_10187 + 92 len 4]
                            if 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10187 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10187 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) and 997 > -1 / 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) / 997 != 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10187 + 18 len 14]:
                                if mem[_10187 + 50 len 14] and 1000 > -1 / mem[_10187 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10187 + 50 len 14] / 1000 != mem[_10187 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10187 + 50 len 14] > (-997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) < 1000 * mem[_10187 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527))
                            else:
                                if 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) and mem[_10187 + 18 len 14] > -1 / 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                    revert with 'NH{q', 17
                                if not mem[_10187 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) * mem[_10187 + 18 len 14] / mem[_10187 + 18 len 14] != 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10187 + 50 len 14] and 1000 > -1 / mem[_10187 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10187 + 50 len 14] / 1000 != mem[_10187 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10187 + 50 len 14] > (-997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)) < 1000 * mem[_10187 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527) * mem[_10187 + 18 len 14] / (1000 * mem[_10187 + 50 len 14]) + (997 * 997 * _8527 * Mask(112, 0, _8681) / (1000 * Mask(112, 0, _8767)) + (997 * _8527))
                    else:
                        if 997 * _7757 and mem[_7778 + 18 len 14] > -1 / 997 * _7757:
                            revert with 'NH{q', 17
                        if not mem[_7778 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7757 * mem[_7778 + 18 len 14] / mem[_7778 + 18 len 14] != 997 * _7757:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7778 + 50 len 14] and 1000 > -1 / mem[_7778 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7778 + 50 len 14] / 1000 != mem[_7778 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7778 + 50 len 14] > (-997 * _7757) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7778 + 50 len 14]) + (997 * _7757) < 1000 * mem[_7778 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7778 + 50 len 14]) + (997 * _7757):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _7757 * mem[_7778 + 18 len 14] / (1000 * mem[_7778 + 50 len 14]) + (997 * _7757)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _7757 * Mask(112, 0, _7789) / (1000 * Mask(112, 0, _7830)) + (997 * _7757))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8682 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8710 = mem[_8682]
                        require mem[_8682] == mem[_8682]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8834 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8912 = mem[_8834]
                        require mem[_8834] == mem[_8834 + 18 len 14]
                        _8990 = mem[_8834 + 32]
                        require mem[_8834 + 32] == mem[_8834 + 50 len 14]
                        require mem[_8834 + 64] == mem[_8834 + 92 len 4]
                        if _8710 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8834 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8834 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8710 and 997 > -1 / _8710:
                            revert with 'NH{q', 17
                        if 997 * _8710 / 997 != _8710:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8834 + 18 len 14]:
                            if mem[_8834 + 50 len 14] and 1000 > -1 / mem[_8834 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8834 + 50 len 14] / 1000 != mem[_8834 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8834 + 50 len 14] > (-997 * _8710) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8834 + 50 len 14]) + (997 * _8710) < 1000 * mem[_8834 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8834 + 50 len 14]) + (997 * _8710):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10188] == mem[_10188 + 18 len 14]
                            require mem[_10188 + 32] == mem[_10188 + 50 len 14]
                            require mem[_10188 + 64] == mem[_10188 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10188 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10188 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) / 997 != 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10188 + 18 len 14]:
                                if mem[_10188 + 50 len 14] and 1000 > -1 / mem[_10188 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10188 + 50 len 14] / 1000 != mem[_10188 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10188 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) < 1000 * mem[_10188 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) and mem[_10188 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                    revert with 'NH{q', 17
                                if not mem[_10188 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) * mem[_10188 + 18 len 14] / mem[_10188 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10188 + 50 len 14] and 1000 > -1 / mem[_10188 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10188 + 50 len 14] / 1000 != mem[_10188 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10188 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) < 1000 * mem[_10188 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710) * mem[_10188 + 18 len 14] / (1000 * mem[_10188 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8990)) + (997 * _8710))
                        else:
                            if 997 * _8710 and mem[_8834 + 18 len 14] > -1 / 997 * _8710:
                                revert with 'NH{q', 17
                            if not mem[_8834 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8710 * mem[_8834 + 18 len 14] / mem[_8834 + 18 len 14] != 997 * _8710:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8834 + 50 len 14] and 1000 > -1 / mem[_8834 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8834 + 50 len 14] / 1000 != mem[_8834 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8834 + 50 len 14] > (-997 * _8710) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8834 + 50 len 14]) + (997 * _8710) < 1000 * mem[_8834 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8834 + 50 len 14]) + (997 * _8710):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10558 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10558] == mem[_10558 + 18 len 14]
                            require mem[_10558 + 32] == mem[_10558 + 50 len 14]
                            require mem[_10558 + 64] == mem[_10558 + 92 len 4]
                            if 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10558 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10558 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) and 997 > -1 / 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) / 997 != 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10558 + 18 len 14]:
                                if mem[_10558 + 50 len 14] and 1000 > -1 / mem[_10558 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10558 + 50 len 14] / 1000 != mem[_10558 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10558 + 50 len 14] > (-997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) < 1000 * mem[_10558 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710))
                            else:
                                if 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) and mem[_10558 + 18 len 14] > -1 / 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                    revert with 'NH{q', 17
                                if not mem[_10558 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) * mem[_10558 + 18 len 14] / mem[_10558 + 18 len 14] != 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10558 + 50 len 14] and 1000 > -1 / mem[_10558 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10558 + 50 len 14] / 1000 != mem[_10558 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10558 + 50 len 14] > (-997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)) < 1000 * mem[_10558 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710) * mem[_10558 + 18 len 14] / (1000 * mem[_10558 + 50 len 14]) + (997 * 997 * _8710 * Mask(112, 0, _8912) / (1000 * Mask(112, 0, _8990)) + (997 * _8710))
                else:
                    if 997 * _7372 and mem[_7413 + 50 len 14] > -1 / 997 * _7372:
                        revert with 'NH{q', 17
                    if not mem[_7413 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * _7372 * mem[_7413 + 50 len 14] / mem[_7413 + 50 len 14] != 997 * _7372:
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7413 + 18 len 14] and 1000 > -1 / mem[_7413 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7413 + 18 len 14] / 1000 != mem[_7413 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7413 + 18 len 14] > (-997 * _7372) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7413 + 18 len 14]) + (997 * _7372) < 1000 * mem[_7413 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7413 + 18 len 14]) + (997 * _7372):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7372 * mem[_7413 + 50 len 14] / (1000 * mem[_7413 + 18 len 14]) + (997 * _7372)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _7867 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7912 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7931 = mem[_7912]
                    require mem[_7912] == mem[_7912 + 18 len 14]
                    _7968 = mem[_7912 + 32]
                    require mem[_7912 + 32] == mem[_7912 + 50 len 14]
                    require mem[_7912 + 64] == mem[_7912 + 92 len 4]
                    if _7867 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7912 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7912 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7867 and 997 > -1 / _7867:
                        revert with 'NH{q', 17
                    if 997 * _7867 / 997 != _7867:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7912 + 18 len 14]:
                        if mem[_7912 + 50 len 14] and 1000 > -1 / mem[_7912 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7912 + 50 len 14] / 1000 != mem[_7912 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7912 + 50 len 14] > (-997 * _7867) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7912 + 50 len 14]) + (997 * _7867) < 1000 * mem[_7912 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7912 + 50 len 14]) + (997 * _7867):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7912 + 50 len 14]) + (997 * _7867)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7968)) + (997 * _7867))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8683 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8711 = mem[_8683]
                        require mem[_8683] == mem[_8683]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8835 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8913 = mem[_8835]
                        require mem[_8835] == mem[_8835 + 18 len 14]
                        _8991 = mem[_8835 + 32]
                        require mem[_8835 + 32] == mem[_8835 + 50 len 14]
                        require mem[_8835 + 64] == mem[_8835 + 92 len 4]
                        if _8711 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8835 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8835 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8711 and 997 > -1 / _8711:
                            revert with 'NH{q', 17
                        if 997 * _8711 / 997 != _8711:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8835 + 18 len 14]:
                            if mem[_8835 + 50 len 14] and 1000 > -1 / mem[_8835 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8835 + 50 len 14] / 1000 != mem[_8835 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8835 + 50 len 14] > (-997 * _8711) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8835 + 50 len 14]) + (997 * _8711) < 1000 * mem[_8835 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8835 + 50 len 14]) + (997 * _8711):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10190 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10190] == mem[_10190 + 18 len 14]
                            require mem[_10190 + 32] == mem[_10190 + 50 len 14]
                            require mem[_10190 + 64] == mem[_10190 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10190 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10190 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) / 997 != 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10190 + 18 len 14]:
                                if mem[_10190 + 50 len 14] and 1000 > -1 / mem[_10190 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10190 + 50 len 14] / 1000 != mem[_10190 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10190 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) < 1000 * mem[_10190 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) and mem[_10190 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                    revert with 'NH{q', 17
                                if not mem[_10190 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) * mem[_10190 + 18 len 14] / mem[_10190 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10190 + 50 len 14] and 1000 > -1 / mem[_10190 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10190 + 50 len 14] / 1000 != mem[_10190 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10190 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) < 1000 * mem[_10190 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711) * mem[_10190 + 18 len 14] / (1000 * mem[_10190 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8991)) + (997 * _8711))
                        else:
                            if 997 * _8711 and mem[_8835 + 18 len 14] > -1 / 997 * _8711:
                                revert with 'NH{q', 17
                            if not mem[_8835 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8711 * mem[_8835 + 18 len 14] / mem[_8835 + 18 len 14] != 997 * _8711:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8835 + 50 len 14] and 1000 > -1 / mem[_8835 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8835 + 50 len 14] / 1000 != mem[_8835 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8835 + 50 len 14] > (-997 * _8711) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8835 + 50 len 14]) + (997 * _8711) < 1000 * mem[_8835 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8835 + 50 len 14]) + (997 * _8711):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10559 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10559] == mem[_10559 + 18 len 14]
                            require mem[_10559 + 32] == mem[_10559 + 50 len 14]
                            require mem[_10559 + 64] == mem[_10559 + 92 len 4]
                            if 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10559 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10559 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) and 997 > -1 / 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) / 997 != 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10559 + 18 len 14]:
                                if mem[_10559 + 50 len 14] and 1000 > -1 / mem[_10559 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10559 + 50 len 14] / 1000 != mem[_10559 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10559 + 50 len 14] > (-997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) < 1000 * mem[_10559 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711))
                            else:
                                if 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) and mem[_10559 + 18 len 14] > -1 / 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                    revert with 'NH{q', 17
                                if not mem[_10559 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) * mem[_10559 + 18 len 14] / mem[_10559 + 18 len 14] != 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10559 + 50 len 14] and 1000 > -1 / mem[_10559 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10559 + 50 len 14] / 1000 != mem[_10559 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10559 + 50 len 14] > (-997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)) < 1000 * mem[_10559 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711) * mem[_10559 + 18 len 14] / (1000 * mem[_10559 + 50 len 14]) + (997 * 997 * _8711 * Mask(112, 0, _8913) / (1000 * Mask(112, 0, _8991)) + (997 * _8711))
                    else:
                        if 997 * _7867 and mem[_7912 + 18 len 14] > -1 / 997 * _7867:
                            revert with 'NH{q', 17
                        if not mem[_7912 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7867 * mem[_7912 + 18 len 14] / mem[_7912 + 18 len 14] != 997 * _7867:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7912 + 50 len 14] and 1000 > -1 / mem[_7912 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7912 + 50 len 14] / 1000 != mem[_7912 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7912 + 50 len 14] > (-997 * _7867) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7912 + 50 len 14]) + (997 * _7867) < 1000 * mem[_7912 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7912 + 50 len 14]) + (997 * _7867):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _7867 * mem[_7912 + 18 len 14] / (1000 * mem[_7912 + 50 len 14]) + (997 * _7867)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _7867 * Mask(112, 0, _7931) / (1000 * Mask(112, 0, _7968)) + (997 * _7867))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8914 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8943 = mem[_8914]
                        require mem[_8914] == mem[_8914]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9080 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9156 = mem[_9080]
                        require mem[_9080] == mem[_9080 + 18 len 14]
                        _9215 = mem[_9080 + 32]
                        require mem[_9080 + 32] == mem[_9080 + 50 len 14]
                        require mem[_9080 + 64] == mem[_9080 + 92 len 4]
                        if _8943 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9080 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9080 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8943 and 997 > -1 / _8943:
                            revert with 'NH{q', 17
                        if 997 * _8943 / 997 != _8943:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9080 + 18 len 14]:
                            if mem[_9080 + 50 len 14] and 1000 > -1 / mem[_9080 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9080 + 50 len 14] / 1000 != mem[_9080 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9080 + 50 len 14] > (-997 * _8943) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9080 + 50 len 14]) + (997 * _8943) < 1000 * mem[_9080 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9080 + 50 len 14]) + (997 * _8943):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10560 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10560] == mem[_10560 + 18 len 14]
                            require mem[_10560 + 32] == mem[_10560 + 50 len 14]
                            require mem[_10560 + 64] == mem[_10560 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10560 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10560 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) / 997 != 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10560 + 18 len 14]:
                                if mem[_10560 + 50 len 14] and 1000 > -1 / mem[_10560 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10560 + 50 len 14] / 1000 != mem[_10560 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10560 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) < 1000 * mem[_10560 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) and mem[_10560 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                    revert with 'NH{q', 17
                                if not mem[_10560 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) * mem[_10560 + 18 len 14] / mem[_10560 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10560 + 50 len 14] and 1000 > -1 / mem[_10560 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10560 + 50 len 14] / 1000 != mem[_10560 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10560 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) < 1000 * mem[_10560 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943) * mem[_10560 + 18 len 14] / (1000 * mem[_10560 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9215)) + (997 * _8943))
                        else:
                            if 997 * _8943 and mem[_9080 + 18 len 14] > -1 / 997 * _8943:
                                revert with 'NH{q', 17
                            if not mem[_9080 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8943 * mem[_9080 + 18 len 14] / mem[_9080 + 18 len 14] != 997 * _8943:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9080 + 50 len 14] and 1000 > -1 / mem[_9080 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9080 + 50 len 14] / 1000 != mem[_9080 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9080 + 50 len 14] > (-997 * _8943) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9080 + 50 len 14]) + (997 * _8943) < 1000 * mem[_9080 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9080 + 50 len 14]) + (997 * _8943):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10983 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10983] == mem[_10983 + 18 len 14]
                            require mem[_10983 + 32] == mem[_10983 + 50 len 14]
                            require mem[_10983 + 64] == mem[_10983 + 92 len 4]
                            if 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10983 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10983 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) and 997 > -1 / 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) / 997 != 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10983 + 18 len 14]:
                                if mem[_10983 + 50 len 14] and 1000 > -1 / mem[_10983 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10983 + 50 len 14] / 1000 != mem[_10983 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10983 + 50 len 14] > (-997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) < 1000 * mem[_10983 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943))
                            else:
                                if 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) and mem[_10983 + 18 len 14] > -1 / 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                    revert with 'NH{q', 17
                                if not mem[_10983 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) * mem[_10983 + 18 len 14] / mem[_10983 + 18 len 14] != 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10983 + 50 len 14] and 1000 > -1 / mem[_10983 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10983 + 50 len 14] / 1000 != mem[_10983 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10983 + 50 len 14] > (-997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)) < 1000 * mem[_10983 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943) * mem[_10983 + 18 len 14] / (1000 * mem[_10983 + 50 len 14]) + (997 * 997 * _8943 * Mask(112, 0, _9156) / (1000 * Mask(112, 0, _9215)) + (997 * _8943))
            else:
                if 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) and mem[_7188 + 50 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                    revert with 'NH{q', 17
                if not mem[_7188 + 50 len 14]:
                    revert with 'NH{q', 18
                if 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * mem[_7188 + 50 len 14] / mem[_7188 + 50 len 14] != 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                    revert with 0, 'ds-math-mul-overflow'
                if mem[_7188 + 18 len 14] and 1000 > -1 / mem[_7188 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7188 + 18 len 14] / 1000 != mem[_7188 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7188 + 18 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) < 1000 * mem[_7188 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)):
                    revert with 'NH{q', 18
                mem[mem[64] + 4] = 997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * mem[_7188 + 50 len 14] / (1000 * mem[_7188 + 18 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069))
                require ext_code.size(stor6)
                staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                        gas gas_remaining wei
                       args (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * Mask(112, 0, _7204) / (1000 * Mask(112, 0, _7193)) + (997 * 0 / (1000 * Mask(112, 0, _7089)) + (997 * _7069)))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7436 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7448 = mem[_7436]
                require mem[_7436] == mem[_7436]
                require ext_code.size(stor12)
                staticcall stor12.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7488 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_7488] == mem[_7488 + 18 len 14]
                require mem[_7488 + 32] == mem[_7488 + 50 len 14]
                require mem[_7488 + 64] == mem[_7488 + 92 len 4]
                if _7448 <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7488 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7488 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if _7448 and 997 > -1 / _7448:
                    revert with 'NH{q', 17
                if 997 * _7448 / 997 != _7448:
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7488 + 50 len 14]:
                    if mem[_7488 + 18 len 14] and 1000 > -1 / mem[_7488 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7488 + 18 len 14] / 1000 != mem[_7488 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7488 + 18 len 14] > (-997 * _7448) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7488 + 18 len 14]) + (997 * _7448) < 1000 * mem[_7488 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7488 + 18 len 14]) + (997 * _7448):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7488 + 18 len 14]) + (997 * _7448)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _7868 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7913 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7932 = mem[_7913]
                    require mem[_7913] == mem[_7913 + 18 len 14]
                    _7969 = mem[_7913 + 32]
                    require mem[_7913 + 32] == mem[_7913 + 50 len 14]
                    require mem[_7913 + 64] == mem[_7913 + 92 len 4]
                    if _7868 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7913 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7913 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7868 and 997 > -1 / _7868:
                        revert with 'NH{q', 17
                    if 997 * _7868 / 997 != _7868:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7913 + 18 len 14]:
                        if mem[_7913 + 50 len 14] and 1000 > -1 / mem[_7913 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7913 + 50 len 14] / 1000 != mem[_7913 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7913 + 50 len 14] > (-997 * _7868) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7913 + 50 len 14]) + (997 * _7868) < 1000 * mem[_7913 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7913 + 50 len 14]) + (997 * _7868):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7913 + 50 len 14]) + (997 * _7868)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7969)) + (997 * _7868))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8684 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8712 = mem[_8684]
                        require mem[_8684] == mem[_8684]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8836 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8915 = mem[_8836]
                        require mem[_8836] == mem[_8836 + 18 len 14]
                        _8992 = mem[_8836 + 32]
                        require mem[_8836 + 32] == mem[_8836 + 50 len 14]
                        require mem[_8836 + 64] == mem[_8836 + 92 len 4]
                        if _8712 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8836 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8836 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8712 and 997 > -1 / _8712:
                            revert with 'NH{q', 17
                        if 997 * _8712 / 997 != _8712:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8836 + 18 len 14]:
                            if mem[_8836 + 50 len 14] and 1000 > -1 / mem[_8836 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8836 + 50 len 14] / 1000 != mem[_8836 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8836 + 50 len 14] > (-997 * _8712) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8836 + 50 len 14]) + (997 * _8712) < 1000 * mem[_8836 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8836 + 50 len 14]) + (997 * _8712):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10193 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10193] == mem[_10193 + 18 len 14]
                            require mem[_10193 + 32] == mem[_10193 + 50 len 14]
                            require mem[_10193 + 64] == mem[_10193 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10193 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10193 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) / 997 != 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10193 + 18 len 14]:
                                if mem[_10193 + 50 len 14] and 1000 > -1 / mem[_10193 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10193 + 50 len 14] / 1000 != mem[_10193 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10193 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) < 1000 * mem[_10193 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) and mem[_10193 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                    revert with 'NH{q', 17
                                if not mem[_10193 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) * mem[_10193 + 18 len 14] / mem[_10193 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10193 + 50 len 14] and 1000 > -1 / mem[_10193 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10193 + 50 len 14] / 1000 != mem[_10193 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10193 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) < 1000 * mem[_10193 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712) * mem[_10193 + 18 len 14] / (1000 * mem[_10193 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8992)) + (997 * _8712))
                        else:
                            if 997 * _8712 and mem[_8836 + 18 len 14] > -1 / 997 * _8712:
                                revert with 'NH{q', 17
                            if not mem[_8836 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8712 * mem[_8836 + 18 len 14] / mem[_8836 + 18 len 14] != 997 * _8712:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8836 + 50 len 14] and 1000 > -1 / mem[_8836 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8836 + 50 len 14] / 1000 != mem[_8836 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8836 + 50 len 14] > (-997 * _8712) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8836 + 50 len 14]) + (997 * _8712) < 1000 * mem[_8836 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8836 + 50 len 14]) + (997 * _8712):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10562 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10562] == mem[_10562 + 18 len 14]
                            require mem[_10562 + 32] == mem[_10562 + 50 len 14]
                            require mem[_10562 + 64] == mem[_10562 + 92 len 4]
                            if 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10562 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10562 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) and 997 > -1 / 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) / 997 != 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10562 + 18 len 14]:
                                if mem[_10562 + 50 len 14] and 1000 > -1 / mem[_10562 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10562 + 50 len 14] / 1000 != mem[_10562 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10562 + 50 len 14] > (-997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) < 1000 * mem[_10562 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712))
                            else:
                                if 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) and mem[_10562 + 18 len 14] > -1 / 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                    revert with 'NH{q', 17
                                if not mem[_10562 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) * mem[_10562 + 18 len 14] / mem[_10562 + 18 len 14] != 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10562 + 50 len 14] and 1000 > -1 / mem[_10562 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10562 + 50 len 14] / 1000 != mem[_10562 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10562 + 50 len 14] > (-997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)) < 1000 * mem[_10562 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712) * mem[_10562 + 18 len 14] / (1000 * mem[_10562 + 50 len 14]) + (997 * 997 * _8712 * Mask(112, 0, _8915) / (1000 * Mask(112, 0, _8992)) + (997 * _8712))
                    else:
                        if 997 * _7868 and mem[_7913 + 18 len 14] > -1 / 997 * _7868:
                            revert with 'NH{q', 17
                        if not mem[_7913 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7868 * mem[_7913 + 18 len 14] / mem[_7913 + 18 len 14] != 997 * _7868:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7913 + 50 len 14] and 1000 > -1 / mem[_7913 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7913 + 50 len 14] / 1000 != mem[_7913 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7913 + 50 len 14] > (-997 * _7868) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7913 + 50 len 14]) + (997 * _7868) < 1000 * mem[_7913 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7913 + 50 len 14]) + (997 * _7868):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _7868 * mem[_7913 + 18 len 14] / (1000 * mem[_7913 + 50 len 14]) + (997 * _7868)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _7868 * Mask(112, 0, _7932) / (1000 * Mask(112, 0, _7969)) + (997 * _7868))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8916 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8944 = mem[_8916]
                        require mem[_8916] == mem[_8916]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9081 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9157 = mem[_9081]
                        require mem[_9081] == mem[_9081 + 18 len 14]
                        _9216 = mem[_9081 + 32]
                        require mem[_9081 + 32] == mem[_9081 + 50 len 14]
                        require mem[_9081 + 64] == mem[_9081 + 92 len 4]
                        if _8944 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9081 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9081 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8944 and 997 > -1 / _8944:
                            revert with 'NH{q', 17
                        if 997 * _8944 / 997 != _8944:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9081 + 18 len 14]:
                            if mem[_9081 + 50 len 14] and 1000 > -1 / mem[_9081 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9081 + 50 len 14] / 1000 != mem[_9081 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9081 + 50 len 14] > (-997 * _8944) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9081 + 50 len 14]) + (997 * _8944) < 1000 * mem[_9081 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9081 + 50 len 14]) + (997 * _8944):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10563 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10563] == mem[_10563 + 18 len 14]
                            require mem[_10563 + 32] == mem[_10563 + 50 len 14]
                            require mem[_10563 + 64] == mem[_10563 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10563 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10563 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) / 997 != 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10563 + 18 len 14]:
                                if mem[_10563 + 50 len 14] and 1000 > -1 / mem[_10563 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10563 + 50 len 14] / 1000 != mem[_10563 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10563 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) < 1000 * mem[_10563 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) and mem[_10563 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                    revert with 'NH{q', 17
                                if not mem[_10563 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) * mem[_10563 + 18 len 14] / mem[_10563 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10563 + 50 len 14] and 1000 > -1 / mem[_10563 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10563 + 50 len 14] / 1000 != mem[_10563 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10563 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) < 1000 * mem[_10563 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944) * mem[_10563 + 18 len 14] / (1000 * mem[_10563 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9216)) + (997 * _8944))
                        else:
                            if 997 * _8944 and mem[_9081 + 18 len 14] > -1 / 997 * _8944:
                                revert with 'NH{q', 17
                            if not mem[_9081 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8944 * mem[_9081 + 18 len 14] / mem[_9081 + 18 len 14] != 997 * _8944:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9081 + 50 len 14] and 1000 > -1 / mem[_9081 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9081 + 50 len 14] / 1000 != mem[_9081 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9081 + 50 len 14] > (-997 * _8944) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9081 + 50 len 14]) + (997 * _8944) < 1000 * mem[_9081 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9081 + 50 len 14]) + (997 * _8944):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10984 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10984] == mem[_10984 + 18 len 14]
                            require mem[_10984 + 32] == mem[_10984 + 50 len 14]
                            require mem[_10984 + 64] == mem[_10984 + 92 len 4]
                            if 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10984 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10984 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) and 997 > -1 / 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) / 997 != 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10984 + 18 len 14]:
                                if mem[_10984 + 50 len 14] and 1000 > -1 / mem[_10984 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10984 + 50 len 14] / 1000 != mem[_10984 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10984 + 50 len 14] > (-997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) < 1000 * mem[_10984 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944))
                            else:
                                if 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) and mem[_10984 + 18 len 14] > -1 / 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                    revert with 'NH{q', 17
                                if not mem[_10984 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) * mem[_10984 + 18 len 14] / mem[_10984 + 18 len 14] != 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10984 + 50 len 14] and 1000 > -1 / mem[_10984 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10984 + 50 len 14] / 1000 != mem[_10984 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10984 + 50 len 14] > (-997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)) < 1000 * mem[_10984 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944) * mem[_10984 + 18 len 14] / (1000 * mem[_10984 + 50 len 14]) + (997 * 997 * _8944 * Mask(112, 0, _9157) / (1000 * Mask(112, 0, _9216)) + (997 * _8944))
                else:
                    if 997 * _7448 and mem[_7488 + 50 len 14] > -1 / 997 * _7448:
                        revert with 'NH{q', 17
                    if not mem[_7488 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * _7448 * mem[_7488 + 50 len 14] / mem[_7488 + 50 len 14] != 997 * _7448:
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7488 + 18 len 14] and 1000 > -1 / mem[_7488 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7488 + 18 len 14] / 1000 != mem[_7488 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7488 + 18 len 14] > (-997 * _7448) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7488 + 18 len 14]) + (997 * _7448) < 1000 * mem[_7488 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7488 + 18 len 14]) + (997 * _7448):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7448 * mem[_7488 + 50 len 14] / (1000 * mem[_7488 + 18 len 14]) + (997 * _7448)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _8003 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8050 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _8079 = mem[_8050]
                    require mem[_8050] == mem[_8050 + 18 len 14]
                    _8106 = mem[_8050 + 32]
                    require mem[_8050 + 32] == mem[_8050 + 50 len 14]
                    require mem[_8050 + 64] == mem[_8050 + 92 len 4]
                    if _8003 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_8050 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_8050 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _8003 and 997 > -1 / _8003:
                        revert with 'NH{q', 17
                    if 997 * _8003 / 997 != _8003:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_8050 + 18 len 14]:
                        if mem[_8050 + 50 len 14] and 1000 > -1 / mem[_8050 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8050 + 50 len 14] / 1000 != mem[_8050 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8050 + 50 len 14] > (-997 * _8003) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8050 + 50 len 14]) + (997 * _8003) < 1000 * mem[_8050 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8050 + 50 len 14]) + (997 * _8003):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_8050 + 50 len 14]) + (997 * _8003)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _8106)) + (997 * _8003))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8917 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8945 = mem[_8917]
                        require mem[_8917] == mem[_8917]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9082 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9158 = mem[_9082]
                        require mem[_9082] == mem[_9082 + 18 len 14]
                        _9217 = mem[_9082 + 32]
                        require mem[_9082 + 32] == mem[_9082 + 50 len 14]
                        require mem[_9082 + 64] == mem[_9082 + 92 len 4]
                        if _8945 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9082 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9082 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8945 and 997 > -1 / _8945:
                            revert with 'NH{q', 17
                        if 997 * _8945 / 997 != _8945:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9082 + 18 len 14]:
                            if mem[_9082 + 50 len 14] and 1000 > -1 / mem[_9082 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9082 + 50 len 14] / 1000 != mem[_9082 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9082 + 50 len 14] > (-997 * _8945) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9082 + 50 len 14]) + (997 * _8945) < 1000 * mem[_9082 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9082 + 50 len 14]) + (997 * _8945):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10565 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10565] == mem[_10565 + 18 len 14]
                            require mem[_10565 + 32] == mem[_10565 + 50 len 14]
                            require mem[_10565 + 64] == mem[_10565 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10565 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10565 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) / 997 != 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10565 + 18 len 14]:
                                if mem[_10565 + 50 len 14] and 1000 > -1 / mem[_10565 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10565 + 50 len 14] / 1000 != mem[_10565 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10565 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) < 1000 * mem[_10565 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) and mem[_10565 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                    revert with 'NH{q', 17
                                if not mem[_10565 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) * mem[_10565 + 18 len 14] / mem[_10565 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10565 + 50 len 14] and 1000 > -1 / mem[_10565 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10565 + 50 len 14] / 1000 != mem[_10565 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10565 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) < 1000 * mem[_10565 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945) * mem[_10565 + 18 len 14] / (1000 * mem[_10565 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9217)) + (997 * _8945))
                        else:
                            if 997 * _8945 and mem[_9082 + 18 len 14] > -1 / 997 * _8945:
                                revert with 'NH{q', 17
                            if not mem[_9082 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8945 * mem[_9082 + 18 len 14] / mem[_9082 + 18 len 14] != 997 * _8945:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9082 + 50 len 14] and 1000 > -1 / mem[_9082 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9082 + 50 len 14] / 1000 != mem[_9082 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9082 + 50 len 14] > (-997 * _8945) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9082 + 50 len 14]) + (997 * _8945) < 1000 * mem[_9082 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9082 + 50 len 14]) + (997 * _8945):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10985 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10985] == mem[_10985 + 18 len 14]
                            require mem[_10985 + 32] == mem[_10985 + 50 len 14]
                            require mem[_10985 + 64] == mem[_10985 + 92 len 4]
                            if 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10985 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10985 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) and 997 > -1 / 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) / 997 != 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10985 + 18 len 14]:
                                if mem[_10985 + 50 len 14] and 1000 > -1 / mem[_10985 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10985 + 50 len 14] / 1000 != mem[_10985 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10985 + 50 len 14] > (-997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) < 1000 * mem[_10985 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945))
                            else:
                                if 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) and mem[_10985 + 18 len 14] > -1 / 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                    revert with 'NH{q', 17
                                if not mem[_10985 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) * mem[_10985 + 18 len 14] / mem[_10985 + 18 len 14] != 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10985 + 50 len 14] and 1000 > -1 / mem[_10985 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10985 + 50 len 14] / 1000 != mem[_10985 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10985 + 50 len 14] > (-997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)) < 1000 * mem[_10985 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945) * mem[_10985 + 18 len 14] / (1000 * mem[_10985 + 50 len 14]) + (997 * 997 * _8945 * Mask(112, 0, _9158) / (1000 * Mask(112, 0, _9217)) + (997 * _8945))
                    else:
                        if 997 * _8003 and mem[_8050 + 18 len 14] > -1 / 997 * _8003:
                            revert with 'NH{q', 17
                        if not mem[_8050 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _8003 * mem[_8050 + 18 len 14] / mem[_8050 + 18 len 14] != 997 * _8003:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_8050 + 50 len 14] and 1000 > -1 / mem[_8050 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8050 + 50 len 14] / 1000 != mem[_8050 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8050 + 50 len 14] > (-997 * _8003) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8050 + 50 len 14]) + (997 * _8003) < 1000 * mem[_8050 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8050 + 50 len 14]) + (997 * _8003):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _8003 * mem[_8050 + 18 len 14] / (1000 * mem[_8050 + 50 len 14]) + (997 * _8003)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _8003 * Mask(112, 0, _8079) / (1000 * Mask(112, 0, _8106)) + (997 * _8003))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9159 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _9186 = mem[_9159]
                        require mem[_9159] == mem[_9159]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9314 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9381 = mem[_9314]
                        require mem[_9314] == mem[_9314 + 18 len 14]
                        _9438 = mem[_9314 + 32]
                        require mem[_9314 + 32] == mem[_9314 + 50 len 14]
                        require mem[_9314 + 64] == mem[_9314 + 92 len 4]
                        if _9186 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9314 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9314 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _9186 and 997 > -1 / _9186:
                            revert with 'NH{q', 17
                        if 997 * _9186 / 997 != _9186:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9314 + 18 len 14]:
                            if mem[_9314 + 50 len 14] and 1000 > -1 / mem[_9314 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9314 + 50 len 14] / 1000 != mem[_9314 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9314 + 50 len 14] > (-997 * _9186) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9314 + 50 len 14]) + (997 * _9186) < 1000 * mem[_9314 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9314 + 50 len 14]) + (997 * _9186):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10986 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10986] == mem[_10986 + 18 len 14]
                            require mem[_10986 + 32] == mem[_10986 + 50 len 14]
                            require mem[_10986 + 64] == mem[_10986 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10986 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10986 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) / 997 != 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10986 + 18 len 14]:
                                if mem[_10986 + 50 len 14] and 1000 > -1 / mem[_10986 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10986 + 50 len 14] / 1000 != mem[_10986 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10986 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) < 1000 * mem[_10986 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) and mem[_10986 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                    revert with 'NH{q', 17
                                if not mem[_10986 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) * mem[_10986 + 18 len 14] / mem[_10986 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10986 + 50 len 14] and 1000 > -1 / mem[_10986 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10986 + 50 len 14] / 1000 != mem[_10986 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10986 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) < 1000 * mem[_10986 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186) * mem[_10986 + 18 len 14] / (1000 * mem[_10986 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9438)) + (997 * _9186))
                        else:
                            if 997 * _9186 and mem[_9314 + 18 len 14] > -1 / 997 * _9186:
                                revert with 'NH{q', 17
                            if not mem[_9314 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _9186 * mem[_9314 + 18 len 14] / mem[_9314 + 18 len 14] != 997 * _9186:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9314 + 50 len 14] and 1000 > -1 / mem[_9314 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9314 + 50 len 14] / 1000 != mem[_9314 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9314 + 50 len 14] > (-997 * _9186) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9314 + 50 len 14]) + (997 * _9186) < 1000 * mem[_9314 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9314 + 50 len 14]) + (997 * _9186):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11408 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11408] == mem[_11408 + 18 len 14]
                            require mem[_11408 + 32] == mem[_11408 + 50 len 14]
                            require mem[_11408 + 64] == mem[_11408 + 92 len 4]
                            if 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11408 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11408 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) and 997 > -1 / 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                revert with 'NH{q', 17
                            if 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) / 997 != 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11408 + 18 len 14]:
                                if mem[_11408 + 50 len 14] and 1000 > -1 / mem[_11408 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11408 + 50 len 14] / 1000 != mem[_11408 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11408 + 50 len 14] > (-997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) < 1000 * mem[_11408 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186))
                            else:
                                if 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) and mem[_11408 + 18 len 14] > -1 / 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                    revert with 'NH{q', 17
                                if not mem[_11408 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) * mem[_11408 + 18 len 14] / mem[_11408 + 18 len 14] != 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11408 + 50 len 14] and 1000 > -1 / mem[_11408 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11408 + 50 len 14] / 1000 != mem[_11408 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11408 + 50 len 14] > (-997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)) < 1000 * mem[_11408 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186) * mem[_11408 + 18 len 14] / (1000 * mem[_11408 + 50 len 14]) + (997 * 997 * _9186 * Mask(112, 0, _9381) / (1000 * Mask(112, 0, _9438)) + (997 * _9186))
        else:
            if 997 * _7069 and mem[_7085 + 50 len 14] > -1 / 997 * _7069:
                revert with 'NH{q', 17
            if not mem[_7085 + 50 len 14]:
                revert with 'NH{q', 18
            if 997 * _7069 * mem[_7085 + 50 len 14] / mem[_7085 + 50 len 14] != 997 * _7069:
                revert with 0, 'ds-math-mul-overflow'
            if mem[_7085 + 18 len 14] and 1000 > -1 / mem[_7085 + 18 len 14]:
                revert with 'NH{q', 17
            if 1000 * mem[_7085 + 18 len 14] / 1000 != mem[_7085 + 18 len 14]:
                revert with 0, 'ds-math-mul-overflow'
            if 1000 * mem[_7085 + 18 len 14] > (-997 * _7069) - 1:
                revert with 'NH{q', 17
            if (1000 * mem[_7085 + 18 len 14]) + (997 * _7069) < 1000 * mem[_7085 + 18 len 14]:
                revert with 0, 'ds-math-add-overflow'
            if not (1000 * mem[_7085 + 18 len 14]) + (997 * _7069):
                revert with 'NH{q', 18
            require ext_code.size(stor14)
            staticcall stor14.getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7217 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _7225 = mem[_7217]
            require mem[_7217] == mem[_7217 + 18 len 14]
            _7229 = mem[_7217 + 32]
            require mem[_7217 + 32] == mem[_7217 + 50 len 14]
            require mem[_7217 + 64] == mem[_7217 + 92 len 4]
            if 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
            if mem[_7217 + 18 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if mem[_7217 + 50 len 14] <= 0:
                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
            if 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) and 997 > -1 / 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                revert with 'NH{q', 17
            if 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) / 997 != 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                revert with 0, 'ds-math-mul-overflow'
            if not mem[_7217 + 50 len 14]:
                if mem[_7217 + 18 len 14] and 1000 > -1 / mem[_7217 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7217 + 18 len 14] / 1000 != mem[_7217 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7217 + 18 len 14] > (-997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) < 1000 * mem[_7217 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)):
                    revert with 'NH{q', 18
                mem[mem[64] + 4] = 0 / (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069))
                require ext_code.size(stor6)
                staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                        gas gas_remaining wei
                       args (0 / (1000 * Mask(112, 0, _7225)) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7437 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7449 = mem[_7437]
                require mem[_7437] == mem[_7437]
                require ext_code.size(stor12)
                staticcall stor12.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7489 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_7489] == mem[_7489 + 18 len 14]
                require mem[_7489 + 32] == mem[_7489 + 50 len 14]
                require mem[_7489 + 64] == mem[_7489 + 92 len 4]
                if _7449 <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7489 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7489 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if _7449 and 997 > -1 / _7449:
                    revert with 'NH{q', 17
                if 997 * _7449 / 997 != _7449:
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7489 + 50 len 14]:
                    if mem[_7489 + 18 len 14] and 1000 > -1 / mem[_7489 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7489 + 18 len 14] / 1000 != mem[_7489 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7489 + 18 len 14] > (-997 * _7449) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7489 + 18 len 14]) + (997 * _7449) < 1000 * mem[_7489 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7489 + 18 len 14]) + (997 * _7449):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7489 + 18 len 14]) + (997 * _7449)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _7869 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7915 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7933 = mem[_7915]
                    require mem[_7915] == mem[_7915 + 18 len 14]
                    _7971 = mem[_7915 + 32]
                    require mem[_7915 + 32] == mem[_7915 + 50 len 14]
                    require mem[_7915 + 64] == mem[_7915 + 92 len 4]
                    if _7869 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_7915 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_7915 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _7869 and 997 > -1 / _7869:
                        revert with 'NH{q', 17
                    if 997 * _7869 / 997 != _7869:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_7915 + 18 len 14]:
                        if mem[_7915 + 50 len 14] and 1000 > -1 / mem[_7915 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7915 + 50 len 14] / 1000 != mem[_7915 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7915 + 50 len 14] > (-997 * _7869) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7915 + 50 len 14]) + (997 * _7869) < 1000 * mem[_7915 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7915 + 50 len 14]) + (997 * _7869):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_7915 + 50 len 14]) + (997 * _7869)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _7971)) + (997 * _7869))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8685 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8714 = mem[_8685]
                        require mem[_8685] == mem[_8685]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8837 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _8918 = mem[_8837]
                        require mem[_8837] == mem[_8837 + 18 len 14]
                        _8994 = mem[_8837 + 32]
                        require mem[_8837 + 32] == mem[_8837 + 50 len 14]
                        require mem[_8837 + 64] == mem[_8837 + 92 len 4]
                        if _8714 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_8837 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_8837 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8714 and 997 > -1 / _8714:
                            revert with 'NH{q', 17
                        if 997 * _8714 / 997 != _8714:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_8837 + 18 len 14]:
                            if mem[_8837 + 50 len 14] and 1000 > -1 / mem[_8837 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8837 + 50 len 14] / 1000 != mem[_8837 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8837 + 50 len 14] > (-997 * _8714) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8837 + 50 len 14]) + (997 * _8714) < 1000 * mem[_8837 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8837 + 50 len 14]) + (997 * _8714):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10197 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10197] == mem[_10197 + 18 len 14]
                            require mem[_10197 + 32] == mem[_10197 + 50 len 14]
                            require mem[_10197 + 64] == mem[_10197 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10197 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10197 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) and 997 > -1 / 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) / 997 != 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10197 + 18 len 14]:
                                if mem[_10197 + 50 len 14] and 1000 > -1 / mem[_10197 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10197 + 50 len 14] / 1000 != mem[_10197 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10197 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) < 1000 * mem[_10197 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) and mem[_10197 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                    revert with 'NH{q', 17
                                if not mem[_10197 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) * mem[_10197 + 18 len 14] / mem[_10197 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10197 + 50 len 14] and 1000 > -1 / mem[_10197 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10197 + 50 len 14] / 1000 != mem[_10197 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10197 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) < 1000 * mem[_10197 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714) * mem[_10197 + 18 len 14] / (1000 * mem[_10197 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _8994)) + (997 * _8714))
                        else:
                            if 997 * _8714 and mem[_8837 + 18 len 14] > -1 / 997 * _8714:
                                revert with 'NH{q', 17
                            if not mem[_8837 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8714 * mem[_8837 + 18 len 14] / mem[_8837 + 18 len 14] != 997 * _8714:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_8837 + 50 len 14] and 1000 > -1 / mem[_8837 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_8837 + 50 len 14] / 1000 != mem[_8837 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_8837 + 50 len 14] > (-997 * _8714) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_8837 + 50 len 14]) + (997 * _8714) < 1000 * mem[_8837 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_8837 + 50 len 14]) + (997 * _8714):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10568 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10568] == mem[_10568 + 18 len 14]
                            require mem[_10568 + 32] == mem[_10568 + 50 len 14]
                            require mem[_10568 + 64] == mem[_10568 + 92 len 4]
                            if 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10568 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10568 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) and 997 > -1 / 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) / 997 != 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10568 + 18 len 14]:
                                if mem[_10568 + 50 len 14] and 1000 > -1 / mem[_10568 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10568 + 50 len 14] / 1000 != mem[_10568 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10568 + 50 len 14] > (-997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) < 1000 * mem[_10568 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714))
                            else:
                                if 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) and mem[_10568 + 18 len 14] > -1 / 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                    revert with 'NH{q', 17
                                if not mem[_10568 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) * mem[_10568 + 18 len 14] / mem[_10568 + 18 len 14] != 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10568 + 50 len 14] and 1000 > -1 / mem[_10568 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10568 + 50 len 14] / 1000 != mem[_10568 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10568 + 50 len 14] > (-997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)) < 1000 * mem[_10568 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714) * mem[_10568 + 18 len 14] / (1000 * mem[_10568 + 50 len 14]) + (997 * 997 * _8714 * Mask(112, 0, _8918) / (1000 * Mask(112, 0, _8994)) + (997 * _8714))
                    else:
                        if 997 * _7869 and mem[_7915 + 18 len 14] > -1 / 997 * _7869:
                            revert with 'NH{q', 17
                        if not mem[_7915 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _7869 * mem[_7915 + 18 len 14] / mem[_7915 + 18 len 14] != 997 * _7869:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_7915 + 50 len 14] and 1000 > -1 / mem[_7915 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_7915 + 50 len 14] / 1000 != mem[_7915 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_7915 + 50 len 14] > (-997 * _7869) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_7915 + 50 len 14]) + (997 * _7869) < 1000 * mem[_7915 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_7915 + 50 len 14]) + (997 * _7869):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _7869 * mem[_7915 + 18 len 14] / (1000 * mem[_7915 + 50 len 14]) + (997 * _7869)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _7869 * Mask(112, 0, _7933) / (1000 * Mask(112, 0, _7971)) + (997 * _7869))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8919 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8946 = mem[_8919]
                        require mem[_8919] == mem[_8919]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9083 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9160 = mem[_9083]
                        require mem[_9083] == mem[_9083 + 18 len 14]
                        _9218 = mem[_9083 + 32]
                        require mem[_9083 + 32] == mem[_9083 + 50 len 14]
                        require mem[_9083 + 64] == mem[_9083 + 92 len 4]
                        if _8946 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9083 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9083 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8946 and 997 > -1 / _8946:
                            revert with 'NH{q', 17
                        if 997 * _8946 / 997 != _8946:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9083 + 18 len 14]:
                            if mem[_9083 + 50 len 14] and 1000 > -1 / mem[_9083 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9083 + 50 len 14] / 1000 != mem[_9083 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9083 + 50 len 14] > (-997 * _8946) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9083 + 50 len 14]) + (997 * _8946) < 1000 * mem[_9083 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9083 + 50 len 14]) + (997 * _8946):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10569 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10569] == mem[_10569 + 18 len 14]
                            require mem[_10569 + 32] == mem[_10569 + 50 len 14]
                            require mem[_10569 + 64] == mem[_10569 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10569 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10569 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) / 997 != 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10569 + 18 len 14]:
                                if mem[_10569 + 50 len 14] and 1000 > -1 / mem[_10569 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10569 + 50 len 14] / 1000 != mem[_10569 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10569 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) < 1000 * mem[_10569 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) and mem[_10569 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                    revert with 'NH{q', 17
                                if not mem[_10569 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) * mem[_10569 + 18 len 14] / mem[_10569 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10569 + 50 len 14] and 1000 > -1 / mem[_10569 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10569 + 50 len 14] / 1000 != mem[_10569 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10569 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) < 1000 * mem[_10569 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946) * mem[_10569 + 18 len 14] / (1000 * mem[_10569 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9218)) + (997 * _8946))
                        else:
                            if 997 * _8946 and mem[_9083 + 18 len 14] > -1 / 997 * _8946:
                                revert with 'NH{q', 17
                            if not mem[_9083 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8946 * mem[_9083 + 18 len 14] / mem[_9083 + 18 len 14] != 997 * _8946:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9083 + 50 len 14] and 1000 > -1 / mem[_9083 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9083 + 50 len 14] / 1000 != mem[_9083 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9083 + 50 len 14] > (-997 * _8946) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9083 + 50 len 14]) + (997 * _8946) < 1000 * mem[_9083 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9083 + 50 len 14]) + (997 * _8946):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10988 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10988] == mem[_10988 + 18 len 14]
                            require mem[_10988 + 32] == mem[_10988 + 50 len 14]
                            require mem[_10988 + 64] == mem[_10988 + 92 len 4]
                            if 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10988 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10988 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) and 997 > -1 / 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) / 997 != 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10988 + 18 len 14]:
                                if mem[_10988 + 50 len 14] and 1000 > -1 / mem[_10988 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10988 + 50 len 14] / 1000 != mem[_10988 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10988 + 50 len 14] > (-997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) < 1000 * mem[_10988 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946))
                            else:
                                if 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) and mem[_10988 + 18 len 14] > -1 / 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                    revert with 'NH{q', 17
                                if not mem[_10988 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) * mem[_10988 + 18 len 14] / mem[_10988 + 18 len 14] != 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10988 + 50 len 14] and 1000 > -1 / mem[_10988 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10988 + 50 len 14] / 1000 != mem[_10988 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10988 + 50 len 14] > (-997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)) < 1000 * mem[_10988 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946) * mem[_10988 + 18 len 14] / (1000 * mem[_10988 + 50 len 14]) + (997 * 997 * _8946 * Mask(112, 0, _9160) / (1000 * Mask(112, 0, _9218)) + (997 * _8946))
                else:
                    if 997 * _7449 and mem[_7489 + 50 len 14] > -1 / 997 * _7449:
                        revert with 'NH{q', 17
                    if not mem[_7489 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * _7449 * mem[_7489 + 50 len 14] / mem[_7489 + 50 len 14] != 997 * _7449:
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7489 + 18 len 14] and 1000 > -1 / mem[_7489 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7489 + 18 len 14] / 1000 != mem[_7489 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7489 + 18 len 14] > (-997 * _7449) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7489 + 18 len 14]) + (997 * _7449) < 1000 * mem[_7489 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7489 + 18 len 14]) + (997 * _7449):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7449 * mem[_7489 + 50 len 14] / (1000 * mem[_7489 + 18 len 14]) + (997 * _7449)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _8004 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8051 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _8080 = mem[_8051]
                    require mem[_8051] == mem[_8051 + 18 len 14]
                    _8107 = mem[_8051 + 32]
                    require mem[_8051 + 32] == mem[_8051 + 50 len 14]
                    require mem[_8051 + 64] == mem[_8051 + 92 len 4]
                    if _8004 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_8051 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_8051 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _8004 and 997 > -1 / _8004:
                        revert with 'NH{q', 17
                    if 997 * _8004 / 997 != _8004:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_8051 + 18 len 14]:
                        if mem[_8051 + 50 len 14] and 1000 > -1 / mem[_8051 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8051 + 50 len 14] / 1000 != mem[_8051 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8051 + 50 len 14] > (-997 * _8004) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8051 + 50 len 14]) + (997 * _8004) < 1000 * mem[_8051 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8051 + 50 len 14]) + (997 * _8004):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_8051 + 50 len 14]) + (997 * _8004)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _8107)) + (997 * _8004))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8920 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8947 = mem[_8920]
                        require mem[_8920] == mem[_8920]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9084 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9161 = mem[_9084]
                        require mem[_9084] == mem[_9084 + 18 len 14]
                        _9219 = mem[_9084 + 32]
                        require mem[_9084 + 32] == mem[_9084 + 50 len 14]
                        require mem[_9084 + 64] == mem[_9084 + 92 len 4]
                        if _8947 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9084 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9084 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8947 and 997 > -1 / _8947:
                            revert with 'NH{q', 17
                        if 997 * _8947 / 997 != _8947:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9084 + 18 len 14]:
                            if mem[_9084 + 50 len 14] and 1000 > -1 / mem[_9084 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9084 + 50 len 14] / 1000 != mem[_9084 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9084 + 50 len 14] > (-997 * _8947) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9084 + 50 len 14]) + (997 * _8947) < 1000 * mem[_9084 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9084 + 50 len 14]) + (997 * _8947):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10571 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10571] == mem[_10571 + 18 len 14]
                            require mem[_10571 + 32] == mem[_10571 + 50 len 14]
                            require mem[_10571 + 64] == mem[_10571 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10571 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10571 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) / 997 != 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10571 + 18 len 14]:
                                if mem[_10571 + 50 len 14] and 1000 > -1 / mem[_10571 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10571 + 50 len 14] / 1000 != mem[_10571 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10571 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) < 1000 * mem[_10571 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) and mem[_10571 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                    revert with 'NH{q', 17
                                if not mem[_10571 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) * mem[_10571 + 18 len 14] / mem[_10571 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10571 + 50 len 14] and 1000 > -1 / mem[_10571 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10571 + 50 len 14] / 1000 != mem[_10571 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10571 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) < 1000 * mem[_10571 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947) * mem[_10571 + 18 len 14] / (1000 * mem[_10571 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9219)) + (997 * _8947))
                        else:
                            if 997 * _8947 and mem[_9084 + 18 len 14] > -1 / 997 * _8947:
                                revert with 'NH{q', 17
                            if not mem[_9084 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8947 * mem[_9084 + 18 len 14] / mem[_9084 + 18 len 14] != 997 * _8947:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9084 + 50 len 14] and 1000 > -1 / mem[_9084 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9084 + 50 len 14] / 1000 != mem[_9084 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9084 + 50 len 14] > (-997 * _8947) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9084 + 50 len 14]) + (997 * _8947) < 1000 * mem[_9084 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9084 + 50 len 14]) + (997 * _8947):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10989 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10989] == mem[_10989 + 18 len 14]
                            require mem[_10989 + 32] == mem[_10989 + 50 len 14]
                            require mem[_10989 + 64] == mem[_10989 + 92 len 4]
                            if 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10989 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10989 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) and 997 > -1 / 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) / 997 != 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10989 + 18 len 14]:
                                if mem[_10989 + 50 len 14] and 1000 > -1 / mem[_10989 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10989 + 50 len 14] / 1000 != mem[_10989 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10989 + 50 len 14] > (-997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) < 1000 * mem[_10989 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947))
                            else:
                                if 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) and mem[_10989 + 18 len 14] > -1 / 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                    revert with 'NH{q', 17
                                if not mem[_10989 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) * mem[_10989 + 18 len 14] / mem[_10989 + 18 len 14] != 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10989 + 50 len 14] and 1000 > -1 / mem[_10989 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10989 + 50 len 14] / 1000 != mem[_10989 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10989 + 50 len 14] > (-997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)) < 1000 * mem[_10989 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947) * mem[_10989 + 18 len 14] / (1000 * mem[_10989 + 50 len 14]) + (997 * 997 * _8947 * Mask(112, 0, _9161) / (1000 * Mask(112, 0, _9219)) + (997 * _8947))
                    else:
                        if 997 * _8004 and mem[_8051 + 18 len 14] > -1 / 997 * _8004:
                            revert with 'NH{q', 17
                        if not mem[_8051 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _8004 * mem[_8051 + 18 len 14] / mem[_8051 + 18 len 14] != 997 * _8004:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_8051 + 50 len 14] and 1000 > -1 / mem[_8051 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8051 + 50 len 14] / 1000 != mem[_8051 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8051 + 50 len 14] > (-997 * _8004) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8051 + 50 len 14]) + (997 * _8004) < 1000 * mem[_8051 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8051 + 50 len 14]) + (997 * _8004):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _8004 * mem[_8051 + 18 len 14] / (1000 * mem[_8051 + 50 len 14]) + (997 * _8004)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _8004 * Mask(112, 0, _8080) / (1000 * Mask(112, 0, _8107)) + (997 * _8004))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9162 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _9187 = mem[_9162]
                        require mem[_9162] == mem[_9162]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9315 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9382 = mem[_9315]
                        require mem[_9315] == mem[_9315 + 18 len 14]
                        _9439 = mem[_9315 + 32]
                        require mem[_9315 + 32] == mem[_9315 + 50 len 14]
                        require mem[_9315 + 64] == mem[_9315 + 92 len 4]
                        if _9187 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9315 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9315 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _9187 and 997 > -1 / _9187:
                            revert with 'NH{q', 17
                        if 997 * _9187 / 997 != _9187:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9315 + 18 len 14]:
                            if mem[_9315 + 50 len 14] and 1000 > -1 / mem[_9315 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9315 + 50 len 14] / 1000 != mem[_9315 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9315 + 50 len 14] > (-997 * _9187) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9315 + 50 len 14]) + (997 * _9187) < 1000 * mem[_9315 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9315 + 50 len 14]) + (997 * _9187):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10990 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10990] == mem[_10990 + 18 len 14]
                            require mem[_10990 + 32] == mem[_10990 + 50 len 14]
                            require mem[_10990 + 64] == mem[_10990 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10990 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10990 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) / 997 != 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10990 + 18 len 14]:
                                if mem[_10990 + 50 len 14] and 1000 > -1 / mem[_10990 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10990 + 50 len 14] / 1000 != mem[_10990 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10990 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) < 1000 * mem[_10990 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) and mem[_10990 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                    revert with 'NH{q', 17
                                if not mem[_10990 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) * mem[_10990 + 18 len 14] / mem[_10990 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10990 + 50 len 14] and 1000 > -1 / mem[_10990 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10990 + 50 len 14] / 1000 != mem[_10990 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10990 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) < 1000 * mem[_10990 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187) * mem[_10990 + 18 len 14] / (1000 * mem[_10990 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9439)) + (997 * _9187))
                        else:
                            if 997 * _9187 and mem[_9315 + 18 len 14] > -1 / 997 * _9187:
                                revert with 'NH{q', 17
                            if not mem[_9315 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _9187 * mem[_9315 + 18 len 14] / mem[_9315 + 18 len 14] != 997 * _9187:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9315 + 50 len 14] and 1000 > -1 / mem[_9315 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9315 + 50 len 14] / 1000 != mem[_9315 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9315 + 50 len 14] > (-997 * _9187) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9315 + 50 len 14]) + (997 * _9187) < 1000 * mem[_9315 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9315 + 50 len 14]) + (997 * _9187):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11409 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11409] == mem[_11409 + 18 len 14]
                            require mem[_11409 + 32] == mem[_11409 + 50 len 14]
                            require mem[_11409 + 64] == mem[_11409 + 92 len 4]
                            if 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11409 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11409 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) and 997 > -1 / 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                revert with 'NH{q', 17
                            if 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) / 997 != 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11409 + 18 len 14]:
                                if mem[_11409 + 50 len 14] and 1000 > -1 / mem[_11409 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11409 + 50 len 14] / 1000 != mem[_11409 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11409 + 50 len 14] > (-997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) < 1000 * mem[_11409 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187))
                            else:
                                if 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) and mem[_11409 + 18 len 14] > -1 / 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                    revert with 'NH{q', 17
                                if not mem[_11409 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) * mem[_11409 + 18 len 14] / mem[_11409 + 18 len 14] != 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11409 + 50 len 14] and 1000 > -1 / mem[_11409 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11409 + 50 len 14] / 1000 != mem[_11409 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11409 + 50 len 14] > (-997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)) < 1000 * mem[_11409 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187) * mem[_11409 + 18 len 14] / (1000 * mem[_11409 + 50 len 14]) + (997 * 997 * _9187 * Mask(112, 0, _9382) / (1000 * Mask(112, 0, _9439)) + (997 * _9187))
            else:
                if 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) and mem[_7217 + 50 len 14] > -1 / 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                    revert with 'NH{q', 17
                if not mem[_7217 + 50 len 14]:
                    revert with 'NH{q', 18
                if 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * mem[_7217 + 50 len 14] / mem[_7217 + 50 len 14] != 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069):
                    revert with 0, 'ds-math-mul-overflow'
                if mem[_7217 + 18 len 14] and 1000 > -1 / mem[_7217 + 18 len 14]:
                    revert with 'NH{q', 17
                if 1000 * mem[_7217 + 18 len 14] / 1000 != mem[_7217 + 18 len 14]:
                    revert with 0, 'ds-math-mul-overflow'
                if 1000 * mem[_7217 + 18 len 14] > (-997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) - 1:
                    revert with 'NH{q', 17
                if (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)) < 1000 * mem[_7217 + 18 len 14]:
                    revert with 0, 'ds-math-add-overflow'
                if not (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)):
                    revert with 'NH{q', 18
                mem[mem[64] + 4] = 997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * mem[_7217 + 50 len 14] / (1000 * mem[_7217 + 18 len 14]) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069))
                require ext_code.size(stor6)
                staticcall stor6.MEMOTowMEMO(uint256 arg1) with:
                        gas gas_remaining wei
                       args (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069) * Mask(112, 0, _7229) / (1000 * Mask(112, 0, _7225)) + (997 * 997 * _7069 * Mask(112, 0, _7101) / (1000 * Mask(112, 0, _7089)) + (997 * _7069)))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7509 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7513 = mem[_7509]
                require mem[_7509] == mem[_7509]
                require ext_code.size(stor12)
                staticcall stor12.getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7545 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_7545] == mem[_7545 + 18 len 14]
                require mem[_7545 + 32] == mem[_7545 + 50 len 14]
                require mem[_7545 + 64] == mem[_7545 + 92 len 4]
                if _7513 <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                if mem[_7545 + 18 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if mem[_7545 + 50 len 14] <= 0:
                    revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                if _7513 and 997 > -1 / _7513:
                    revert with 'NH{q', 17
                if 997 * _7513 / 997 != _7513:
                    revert with 0, 'ds-math-mul-overflow'
                if not mem[_7545 + 50 len 14]:
                    if mem[_7545 + 18 len 14] and 1000 > -1 / mem[_7545 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7545 + 18 len 14] / 1000 != mem[_7545 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7545 + 18 len 14] > (-997 * _7513) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7545 + 18 len 14]) + (997 * _7513) < 1000 * mem[_7545 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7545 + 18 len 14]) + (997 * _7513):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 0 / (1000 * mem[_7545 + 18 len 14]) + (997 * _7513)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _8005 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8052 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _8081 = mem[_8052]
                    require mem[_8052] == mem[_8052 + 18 len 14]
                    _8108 = mem[_8052 + 32]
                    require mem[_8052 + 32] == mem[_8052 + 50 len 14]
                    require mem[_8052 + 64] == mem[_8052 + 92 len 4]
                    if _8005 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_8052 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_8052 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _8005 and 997 > -1 / _8005:
                        revert with 'NH{q', 17
                    if 997 * _8005 / 997 != _8005:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_8052 + 18 len 14]:
                        if mem[_8052 + 50 len 14] and 1000 > -1 / mem[_8052 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8052 + 50 len 14] / 1000 != mem[_8052 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8052 + 50 len 14] > (-997 * _8005) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8052 + 50 len 14]) + (997 * _8005) < 1000 * mem[_8052 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8052 + 50 len 14]) + (997 * _8005):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_8052 + 50 len 14]) + (997 * _8005)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _8108)) + (997 * _8005))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8921 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _8948 = mem[_8921]
                        require mem[_8921] == mem[_8921]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9085 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9163 = mem[_9085]
                        require mem[_9085] == mem[_9085 + 18 len 14]
                        _9220 = mem[_9085 + 32]
                        require mem[_9085 + 32] == mem[_9085 + 50 len 14]
                        require mem[_9085 + 64] == mem[_9085 + 92 len 4]
                        if _8948 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9085 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9085 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _8948 and 997 > -1 / _8948:
                            revert with 'NH{q', 17
                        if 997 * _8948 / 997 != _8948:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9085 + 18 len 14]:
                            if mem[_9085 + 50 len 14] and 1000 > -1 / mem[_9085 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9085 + 50 len 14] / 1000 != mem[_9085 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9085 + 50 len 14] > (-997 * _8948) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9085 + 50 len 14]) + (997 * _8948) < 1000 * mem[_9085 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9085 + 50 len 14]) + (997 * _8948):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10574 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10574] == mem[_10574 + 18 len 14]
                            require mem[_10574 + 32] == mem[_10574 + 50 len 14]
                            require mem[_10574 + 64] == mem[_10574 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10574 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10574 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) / 997 != 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10574 + 18 len 14]:
                                if mem[_10574 + 50 len 14] and 1000 > -1 / mem[_10574 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10574 + 50 len 14] / 1000 != mem[_10574 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10574 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) < 1000 * mem[_10574 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) and mem[_10574 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                    revert with 'NH{q', 17
                                if not mem[_10574 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) * mem[_10574 + 18 len 14] / mem[_10574 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10574 + 50 len 14] and 1000 > -1 / mem[_10574 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10574 + 50 len 14] / 1000 != mem[_10574 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10574 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) < 1000 * mem[_10574 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948) * mem[_10574 + 18 len 14] / (1000 * mem[_10574 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9220)) + (997 * _8948))
                        else:
                            if 997 * _8948 and mem[_9085 + 18 len 14] > -1 / 997 * _8948:
                                revert with 'NH{q', 17
                            if not mem[_9085 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _8948 * mem[_9085 + 18 len 14] / mem[_9085 + 18 len 14] != 997 * _8948:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9085 + 50 len 14] and 1000 > -1 / mem[_9085 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9085 + 50 len 14] / 1000 != mem[_9085 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9085 + 50 len 14] > (-997 * _8948) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9085 + 50 len 14]) + (997 * _8948) < 1000 * mem[_9085 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9085 + 50 len 14]) + (997 * _8948):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10992 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10992] == mem[_10992 + 18 len 14]
                            require mem[_10992 + 32] == mem[_10992 + 50 len 14]
                            require mem[_10992 + 64] == mem[_10992 + 92 len 4]
                            if 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10992 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10992 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) and 997 > -1 / 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                revert with 'NH{q', 17
                            if 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) / 997 != 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10992 + 18 len 14]:
                                if mem[_10992 + 50 len 14] and 1000 > -1 / mem[_10992 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10992 + 50 len 14] / 1000 != mem[_10992 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10992 + 50 len 14] > (-997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) < 1000 * mem[_10992 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948))
                            else:
                                if 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) and mem[_10992 + 18 len 14] > -1 / 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                    revert with 'NH{q', 17
                                if not mem[_10992 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) * mem[_10992 + 18 len 14] / mem[_10992 + 18 len 14] != 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10992 + 50 len 14] and 1000 > -1 / mem[_10992 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10992 + 50 len 14] / 1000 != mem[_10992 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10992 + 50 len 14] > (-997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)) < 1000 * mem[_10992 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948) * mem[_10992 + 18 len 14] / (1000 * mem[_10992 + 50 len 14]) + (997 * 997 * _8948 * Mask(112, 0, _9163) / (1000 * Mask(112, 0, _9220)) + (997 * _8948))
                    else:
                        if 997 * _8005 and mem[_8052 + 18 len 14] > -1 / 997 * _8005:
                            revert with 'NH{q', 17
                        if not mem[_8052 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _8005 * mem[_8052 + 18 len 14] / mem[_8052 + 18 len 14] != 997 * _8005:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_8052 + 50 len 14] and 1000 > -1 / mem[_8052 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8052 + 50 len 14] / 1000 != mem[_8052 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8052 + 50 len 14] > (-997 * _8005) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8052 + 50 len 14]) + (997 * _8005) < 1000 * mem[_8052 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8052 + 50 len 14]) + (997 * _8005):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _8005 * mem[_8052 + 18 len 14] / (1000 * mem[_8052 + 50 len 14]) + (997 * _8005)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _8005 * Mask(112, 0, _8081) / (1000 * Mask(112, 0, _8108)) + (997 * _8005))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9164 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _9188 = mem[_9164]
                        require mem[_9164] == mem[_9164]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9316 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9383 = mem[_9316]
                        require mem[_9316] == mem[_9316 + 18 len 14]
                        _9440 = mem[_9316 + 32]
                        require mem[_9316 + 32] == mem[_9316 + 50 len 14]
                        require mem[_9316 + 64] == mem[_9316 + 92 len 4]
                        if _9188 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9316 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9316 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _9188 and 997 > -1 / _9188:
                            revert with 'NH{q', 17
                        if 997 * _9188 / 997 != _9188:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9316 + 18 len 14]:
                            if mem[_9316 + 50 len 14] and 1000 > -1 / mem[_9316 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9316 + 50 len 14] / 1000 != mem[_9316 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9316 + 50 len 14] > (-997 * _9188) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9316 + 50 len 14]) + (997 * _9188) < 1000 * mem[_9316 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9316 + 50 len 14]) + (997 * _9188):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10993 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10993] == mem[_10993 + 18 len 14]
                            require mem[_10993 + 32] == mem[_10993 + 50 len 14]
                            require mem[_10993 + 64] == mem[_10993 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10993 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10993 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) / 997 != 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10993 + 18 len 14]:
                                if mem[_10993 + 50 len 14] and 1000 > -1 / mem[_10993 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10993 + 50 len 14] / 1000 != mem[_10993 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10993 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) < 1000 * mem[_10993 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) and mem[_10993 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                    revert with 'NH{q', 17
                                if not mem[_10993 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) * mem[_10993 + 18 len 14] / mem[_10993 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10993 + 50 len 14] and 1000 > -1 / mem[_10993 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10993 + 50 len 14] / 1000 != mem[_10993 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10993 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) < 1000 * mem[_10993 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188) * mem[_10993 + 18 len 14] / (1000 * mem[_10993 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9440)) + (997 * _9188))
                        else:
                            if 997 * _9188 and mem[_9316 + 18 len 14] > -1 / 997 * _9188:
                                revert with 'NH{q', 17
                            if not mem[_9316 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _9188 * mem[_9316 + 18 len 14] / mem[_9316 + 18 len 14] != 997 * _9188:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9316 + 50 len 14] and 1000 > -1 / mem[_9316 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9316 + 50 len 14] / 1000 != mem[_9316 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9316 + 50 len 14] > (-997 * _9188) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9316 + 50 len 14]) + (997 * _9188) < 1000 * mem[_9316 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9316 + 50 len 14]) + (997 * _9188):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11410 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11410] == mem[_11410 + 18 len 14]
                            require mem[_11410 + 32] == mem[_11410 + 50 len 14]
                            require mem[_11410 + 64] == mem[_11410 + 92 len 4]
                            if 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11410 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11410 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) and 997 > -1 / 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                revert with 'NH{q', 17
                            if 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) / 997 != 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11410 + 18 len 14]:
                                if mem[_11410 + 50 len 14] and 1000 > -1 / mem[_11410 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11410 + 50 len 14] / 1000 != mem[_11410 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11410 + 50 len 14] > (-997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) < 1000 * mem[_11410 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188))
                            else:
                                if 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) and mem[_11410 + 18 len 14] > -1 / 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                    revert with 'NH{q', 17
                                if not mem[_11410 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) * mem[_11410 + 18 len 14] / mem[_11410 + 18 len 14] != 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11410 + 50 len 14] and 1000 > -1 / mem[_11410 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11410 + 50 len 14] / 1000 != mem[_11410 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11410 + 50 len 14] > (-997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)) < 1000 * mem[_11410 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188) * mem[_11410 + 18 len 14] / (1000 * mem[_11410 + 50 len 14]) + (997 * 997 * _9188 * Mask(112, 0, _9383) / (1000 * Mask(112, 0, _9440)) + (997 * _9188))
                else:
                    if 997 * _7513 and mem[_7545 + 50 len 14] > -1 / 997 * _7513:
                        revert with 'NH{q', 17
                    if not mem[_7545 + 50 len 14]:
                        revert with 'NH{q', 18
                    if 997 * _7513 * mem[_7545 + 50 len 14] / mem[_7545 + 50 len 14] != 997 * _7513:
                        revert with 0, 'ds-math-mul-overflow'
                    if mem[_7545 + 18 len 14] and 1000 > -1 / mem[_7545 + 18 len 14]:
                        revert with 'NH{q', 17
                    if 1000 * mem[_7545 + 18 len 14] / 1000 != mem[_7545 + 18 len 14]:
                        revert with 0, 'ds-math-mul-overflow'
                    if 1000 * mem[_7545 + 18 len 14] > (-997 * _7513) - 1:
                        revert with 'NH{q', 17
                    if (1000 * mem[_7545 + 18 len 14]) + (997 * _7513) < 1000 * mem[_7545 + 18 len 14]:
                        revert with 0, 'ds-math-add-overflow'
                    if not (1000 * mem[_7545 + 18 len 14]) + (997 * _7513):
                        revert with 'NH{q', 18
                    if idx >= mem[(32 * ('cd', 4).length) + 128]:
                        revert with 'NH{q', 50
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = 997 * _7513 * mem[_7545 + 50 len 14] / (1000 * mem[_7545 + 18 len 14]) + (997 * _7513)
                    if idx >= mem[96]:
                        revert with 'NH{q', 50
                    _8129 = mem[(32 * idx) + 128]
                    require ext_code.size(stor12)
                    staticcall stor12.getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _8165 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _8197 = mem[_8165]
                    require mem[_8165] == mem[_8165 + 18 len 14]
                    _8229 = mem[_8165 + 32]
                    require mem[_8165 + 32] == mem[_8165 + 50 len 14]
                    require mem[_8165 + 64] == mem[_8165 + 92 len 4]
                    if _8129 <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_8165 + 50 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if mem[_8165 + 18 len 14] <= 0:
                        revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                    if _8129 and 997 > -1 / _8129:
                        revert with 'NH{q', 17
                    if 997 * _8129 / 997 != _8129:
                        revert with 0, 'ds-math-mul-overflow'
                    if not mem[_8165 + 18 len 14]:
                        if mem[_8165 + 50 len 14] and 1000 > -1 / mem[_8165 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8165 + 50 len 14] / 1000 != mem[_8165 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8165 + 50 len 14] > (-997 * _8129) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8165 + 50 len 14]) + (997 * _8129) < 1000 * mem[_8165 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8165 + 50 len 14]) + (997 * _8129):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 0 / (1000 * mem[_8165 + 50 len 14]) + (997 * _8129)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (0 / (1000 * Mask(112, 0, _8229)) + (997 * _8129))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9165 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _9189 = mem[_9165]
                        require mem[_9165] == mem[_9165]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9317 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9384 = mem[_9317]
                        require mem[_9317] == mem[_9317 + 18 len 14]
                        _9441 = mem[_9317 + 32]
                        require mem[_9317 + 32] == mem[_9317 + 50 len 14]
                        require mem[_9317 + 64] == mem[_9317 + 92 len 4]
                        if _9189 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9317 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9317 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _9189 and 997 > -1 / _9189:
                            revert with 'NH{q', 17
                        if 997 * _9189 / 997 != _9189:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9317 + 18 len 14]:
                            if mem[_9317 + 50 len 14] and 1000 > -1 / mem[_9317 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9317 + 50 len 14] / 1000 != mem[_9317 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9317 + 50 len 14] > (-997 * _9189) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9317 + 50 len 14]) + (997 * _9189) < 1000 * mem[_9317 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9317 + 50 len 14]) + (997 * _9189):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _10995 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_10995] == mem[_10995 + 18 len 14]
                            require mem[_10995 + 32] == mem[_10995 + 50 len 14]
                            require mem[_10995 + 64] == mem[_10995 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_10995 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_10995 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) / 997 != 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_10995 + 18 len 14]:
                                if mem[_10995 + 50 len 14] and 1000 > -1 / mem[_10995 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10995 + 50 len 14] / 1000 != mem[_10995 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10995 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) < 1000 * mem[_10995 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) and mem[_10995 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                    revert with 'NH{q', 17
                                if not mem[_10995 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) * mem[_10995 + 18 len 14] / mem[_10995 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_10995 + 50 len 14] and 1000 > -1 / mem[_10995 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_10995 + 50 len 14] / 1000 != mem[_10995 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_10995 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) < 1000 * mem[_10995 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189) * mem[_10995 + 18 len 14] / (1000 * mem[_10995 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9441)) + (997 * _9189))
                        else:
                            if 997 * _9189 and mem[_9317 + 18 len 14] > -1 / 997 * _9189:
                                revert with 'NH{q', 17
                            if not mem[_9317 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _9189 * mem[_9317 + 18 len 14] / mem[_9317 + 18 len 14] != 997 * _9189:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9317 + 50 len 14] and 1000 > -1 / mem[_9317 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9317 + 50 len 14] / 1000 != mem[_9317 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9317 + 50 len 14] > (-997 * _9189) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9317 + 50 len 14]) + (997 * _9189) < 1000 * mem[_9317 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9317 + 50 len 14]) + (997 * _9189):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11411 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11411] == mem[_11411 + 18 len 14]
                            require mem[_11411 + 32] == mem[_11411 + 50 len 14]
                            require mem[_11411 + 64] == mem[_11411 + 92 len 4]
                            if 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11411 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11411 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) and 997 > -1 / 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                revert with 'NH{q', 17
                            if 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) / 997 != 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11411 + 18 len 14]:
                                if mem[_11411 + 50 len 14] and 1000 > -1 / mem[_11411 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11411 + 50 len 14] / 1000 != mem[_11411 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11411 + 50 len 14] > (-997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) < 1000 * mem[_11411 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189))
                            else:
                                if 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) and mem[_11411 + 18 len 14] > -1 / 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                    revert with 'NH{q', 17
                                if not mem[_11411 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) * mem[_11411 + 18 len 14] / mem[_11411 + 18 len 14] != 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11411 + 50 len 14] and 1000 > -1 / mem[_11411 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11411 + 50 len 14] / 1000 != mem[_11411 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11411 + 50 len 14] > (-997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)) < 1000 * mem[_11411 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189) * mem[_11411 + 18 len 14] / (1000 * mem[_11411 + 50 len 14]) + (997 * 997 * _9189 * Mask(112, 0, _9384) / (1000 * Mask(112, 0, _9441)) + (997 * _9189))
                    else:
                        if 997 * _8129 and mem[_8165 + 18 len 14] > -1 / 997 * _8129:
                            revert with 'NH{q', 17
                        if not mem[_8165 + 18 len 14]:
                            revert with 'NH{q', 18
                        if 997 * _8129 * mem[_8165 + 18 len 14] / mem[_8165 + 18 len 14] != 997 * _8129:
                            revert with 0, 'ds-math-mul-overflow'
                        if mem[_8165 + 50 len 14] and 1000 > -1 / mem[_8165 + 50 len 14]:
                            revert with 'NH{q', 17
                        if 1000 * mem[_8165 + 50 len 14] / 1000 != mem[_8165 + 50 len 14]:
                            revert with 0, 'ds-math-mul-overflow'
                        if 1000 * mem[_8165 + 50 len 14] > (-997 * _8129) - 1:
                            revert with 'NH{q', 17
                        if (1000 * mem[_8165 + 50 len 14]) + (997 * _8129) < 1000 * mem[_8165 + 50 len 14]:
                            revert with 0, 'ds-math-add-overflow'
                        if not (1000 * mem[_8165 + 50 len 14]) + (997 * _8129):
                            revert with 'NH{q', 18
                        mem[mem[64] + 4] = 997 * _8129 * mem[_8165 + 18 len 14] / (1000 * mem[_8165 + 50 len 14]) + (997 * _8129)
                        require ext_code.size(stor6)
                        staticcall stor6.wMEMOToMEMO(uint256 arg1) with:
                                gas gas_remaining wei
                               args (997 * _8129 * Mask(112, 0, _8197) / (1000 * Mask(112, 0, _8229)) + (997 * _8129))
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9385 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _9421 = mem[_9385]
                        require mem[_9385] == mem[_9385]
                        require ext_code.size(stor14)
                        staticcall stor14.getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9525 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _9585 = mem[_9525]
                        require mem[_9525] == mem[_9525 + 18 len 14]
                        _9661 = mem[_9525 + 32]
                        require mem[_9525 + 32] == mem[_9525 + 50 len 14]
                        require mem[_9525 + 64] == mem[_9525 + 92 len 4]
                        if _9421 <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_9525 + 50 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if mem[_9525 + 18 len 14] <= 0:
                            revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                        if _9421 and 997 > -1 / _9421:
                            revert with 'NH{q', 17
                        if 997 * _9421 / 997 != _9421:
                            revert with 0, 'ds-math-mul-overflow'
                        if not mem[_9525 + 18 len 14]:
                            if mem[_9525 + 50 len 14] and 1000 > -1 / mem[_9525 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9525 + 50 len 14] / 1000 != mem[_9525 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9525 + 50 len 14] > (-997 * _9421) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9525 + 50 len 14]) + (997 * _9421) < 1000 * mem[_9525 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9525 + 50 len 14]) + (997 * _9421):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11412 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11412] == mem[_11412 + 18 len 14]
                            require mem[_11412 + 32] == mem[_11412 + 50 len 14]
                            require mem[_11412 + 64] == mem[_11412 + 92 len 4]
                            if 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11412 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11412 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) and 997 > -1 / 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                revert with 'NH{q', 17
                            if 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) / 997 != 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11412 + 18 len 14]:
                                if mem[_11412 + 50 len 14] and 1000 > -1 / mem[_11412 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11412 + 50 len 14] / 1000 != mem[_11412 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11412 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) < 1000 * mem[_11412 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421))
                            else:
                                if 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) and mem[_11412 + 18 len 14] > -1 / 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                    revert with 'NH{q', 17
                                if not mem[_11412 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) * mem[_11412 + 18 len 14] / mem[_11412 + 18 len 14] != 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11412 + 50 len 14] and 1000 > -1 / mem[_11412 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11412 + 50 len 14] / 1000 != mem[_11412 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11412 + 50 len 14] > (-997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) < 1000 * mem[_11412 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421) * mem[_11412 + 18 len 14] / (1000 * mem[_11412 + 50 len 14]) + (997 * 0 / (1000 * Mask(112, 0, _9661)) + (997 * _9421))
                        else:
                            if 997 * _9421 and mem[_9525 + 18 len 14] > -1 / 997 * _9421:
                                revert with 'NH{q', 17
                            if not mem[_9525 + 18 len 14]:
                                revert with 'NH{q', 18
                            if 997 * _9421 * mem[_9525 + 18 len 14] / mem[_9525 + 18 len 14] != 997 * _9421:
                                revert with 0, 'ds-math-mul-overflow'
                            if mem[_9525 + 50 len 14] and 1000 > -1 / mem[_9525 + 50 len 14]:
                                revert with 'NH{q', 17
                            if 1000 * mem[_9525 + 50 len 14] / 1000 != mem[_9525 + 50 len 14]:
                                revert with 0, 'ds-math-mul-overflow'
                            if 1000 * mem[_9525 + 50 len 14] > (-997 * _9421) - 1:
                                revert with 'NH{q', 17
                            if (1000 * mem[_9525 + 50 len 14]) + (997 * _9421) < 1000 * mem[_9525 + 50 len 14]:
                                revert with 0, 'ds-math-add-overflow'
                            if not (1000 * mem[_9525 + 50 len 14]) + (997 * _9421):
                                revert with 'NH{q', 18
                            require ext_code.size(stor13)
                            staticcall stor13.getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11805 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            require mem[_11805] == mem[_11805 + 18 len 14]
                            require mem[_11805 + 32] == mem[_11805 + 50 len 14]
                            require mem[_11805 + 64] == mem[_11805 + 92 len 4]
                            if 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'
                            if mem[_11805 + 50 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if mem[_11805 + 18 len 14] <= 0:
                                revert with 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'
                            if 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) and 997 > -1 / 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                revert with 'NH{q', 17
                            if 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) / 997 != 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                revert with 0, 'ds-math-mul-overflow'
                            if not mem[_11805 + 18 len 14]:
                                if mem[_11805 + 50 len 14] and 1000 > -1 / mem[_11805 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11805 + 50 len 14] / 1000 != mem[_11805 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11805 + 50 len 14] > (-997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) < 1000 * mem[_11805 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 0 / (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421))
                            else:
                                if 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) and mem[_11805 + 18 len 14] > -1 / 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                    revert with 'NH{q', 17
                                if not mem[_11805 + 18 len 14]:
                                    revert with 'NH{q', 18
                                if 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) * mem[_11805 + 18 len 14] / mem[_11805 + 18 len 14] != 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421):
                                    revert with 0, 'ds-math-mul-overflow'
                                if mem[_11805 + 50 len 14] and 1000 > -1 / mem[_11805 + 50 len 14]:
                                    revert with 'NH{q', 17
                                if 1000 * mem[_11805 + 50 len 14] / 1000 != mem[_11805 + 50 len 14]:
                                    revert with 0, 'ds-math-mul-overflow'
                                if 1000 * mem[_11805 + 50 len 14] > (-997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) - 1:
                                    revert with 'NH{q', 17
                                if (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)) < 1000 * mem[_11805 + 50 len 14]:
                                    revert with 0, 'ds-math-add-overflow'
                                if not (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421)):
                                    revert with 'NH{q', 18
                                if idx >= mem[(64 * ('cd', 4).length) + 160]:
                                    revert with 'NH{q', 50
                                mem[(32 * idx) + (64 * ('cd', 4).length) + 192] = 997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421) * mem[_11805 + 18 len 14] / (1000 * mem[_11805 + 50 len 14]) + (997 * 997 * _9421 * Mask(112, 0, _9585) / (1000 * Mask(112, 0, _9661)) + (997 * _9421))
        if idx == -1:
            revert with 'NH{q', 17
        idx = idx + 1
        continue 
    _7068 = mem[64]
    mem[mem[64]] = 64
    _7084 = mem[(32 * ('cd', 4).length) + 128]
    mem[mem[64] + 64] = mem[(32 * ('cd', 4).length) + 128]
    mem[mem[64] + 96 len 32 * _7084] = mem[(32 * ('cd', 4).length) + 160 len 32 * _7084]
    mem[mem[64] + 32] = (32 * _7084) + 96
    _7409 = mem[(64 * ('cd', 4).length) + 160]
    mem[_7068 + (32 * _7084) + 96] = mem[(64 * ('cd', 4).length) + 160]
    mem[_7068 + (32 * _7084) + 128 len 32 * _7409] = mem[(64 * ('cd', 4).length) + 192 len 32 * _7409]
    return memory
      from mem[64]
       len _7068 + (32 * _7084) + (32 * _7409) + -mem[64] + 128
}



}

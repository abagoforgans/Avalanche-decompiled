contract main {




// =====================  Runtime code  =====================


#
#  - stop()
#
const sub_5cd90e58(?) = 10^18

const sub_b94db6af(?) = 100000

const sub_f288a2e2(?) = 0xf66846415d2bf9eabda9e84793ff9c0ea96d87f50fc41e66aa16469c6a442f05


uint8 stor0;
address coreAddress; offset 8
uint256 stor1;
mapping of uint256 sub_1afe308e;
uint256 duration;
uint256 cycle;
uint256 sub_27e79c44;
uint8 stor6;
array of struct tranches;
address stakerAddress;
address devAddress;
array of struct tokens;
uint256 tokenCount;
mapping of uint256 userBalances;
mapping of uint256 sub_26d8cc49;
mapping of uint256 sub_6aad5e20;
mapping of uint256 sub_c8ae97c1;
mapping of struct sub_ae4f9c74;
mapping of struct sub_8365b232;

function active() payable {
    return bool(stor6)
}

function duration() payable {
    return duration
}

function sub_1afe308e(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_1afe308e[arg1]
}

function tranches(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < tranches.length
    return tranches[arg1].field_0, tranches[arg1].field_256, tranches[arg1].field_512, tranches[arg1].field_768
}

function sub_26d8cc49(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_26d8cc49[arg1]
}

function sub_27e79c44(?) payable {
    return sub_27e79c44
}

function devAddress() payable {
    return devAddress
}

function tokens(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < tokens.length
    return address(tokens[arg1].field_0), address(tokens[arg1].field_256), tokens[arg1].field_512
}

function paused() payable {
    return bool(stor0)
}

function staker() payable {
    return stakerAddress
}

function cycle() payable {
    return cycle
}

function sub_6aad5e20(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 == address(arg3)
    return sub_6aad5e20[arg1][arg2][arg3]
}

function sub_8365b232(?) payable {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    return sub_8365b232[arg1][arg2].field_0, 
           sub_8365b232[arg1][arg2].field_256,
           sub_8365b232[arg1][arg2].field_512,
           sub_8365b232[arg1][arg2].field_768,
           bool(uint8(sub_8365b232[arg1][arg2].field_1024))
}

function tokenCount() payable {
    return tokenCount
}

function userBalances(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return userBalances[arg1][arg2]
}

function sub_ae4f9c74(?) payable {
    require calldata.size - 4 >= 64
    return sub_ae4f9c74[arg1][arg2].field_0, 
           sub_ae4f9c74[arg1][arg2].field_256,
           sub_ae4f9c74[arg1][arg2].field_512,
           sub_ae4f9c74[arg1][arg2].field_768,
           sub_ae4f9c74[arg1][arg2].field_1024,
           sub_ae4f9c74[arg1][arg2].field_1280,
           sub_ae4f9c74[arg1][arg2].field_1536
}

function sub_c8ae97c1(?) payable {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    return sub_c8ae97c1[arg1][arg2][arg3]
}

function core() payable {
    return coreAddress
}

function _fallback() payable {
    revert
}

function setDuration(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'CoreRef::onlyGovernor: Caller is not a governor'
    duration = arg1
}

function setCore(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'CoreRef::onlyGovernor: Caller is not a governor'
    coreAddress = arg1
    emit CoreUpdate(arg1);
}

function setDevAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'CoreRef::onlyGovernor: Caller is not a governor'
    devAddress = arg1
    emit SetDevAddress(arg1);
}

function pause() payable {
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        require ext_code.size(coreAddress)
        staticcall coreAddress.isGuardian(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'CoreRef::onlyGuardianOrGovernor: Caller is not a guardian or governor'
    if stor0:
        revert with 0, 'Pausable: paused'
    stor0 = 1
    emit Paused(msg.sender);
}

function unpause() payable {
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        require ext_code.size(coreAddress)
        staticcall coreAddress.isGuardian(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'CoreRef::onlyGuardianOrGovernor: Caller is not a guardian or governor'
    if not stor0:
        revert with 0, 'Pausable: not paused'
    stor0 = 0
    emit Unpaused(msg.sender);
}

function add(uint256 arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require ext_code.size(coreAddress)
    staticcall coreAddress.0xe43581b8 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'CoreRef::onlyGovernor: Caller is not a governor'
    if arg1 <= 0:
        revert with 0, 'invalid target'
    if arg2 > 100000:
        revert with 0, 'invalid APY'
    if arg3 > 10000:
        revert with 0, 'invalid fee'
    if not arg2:
        tranches.length++
        tranches[tranches.length].field_0 = arg1
        tranches[tranches.length].field_256 = 0
        tranches[tranches.length].field_512 = 0
    else:
        if 10^18 * arg2 / arg2 != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        tranches.length++
        tranches[tranches.length].field_0 = arg1
        tranches[tranches.length].field_256 = 0
        tranches[tranches.length].field_512 = 10^18 * arg2 / 100000
    tranches[tranches.length].field_768 = arg3
    emit 0x955a633d: tranches.length - 1, arg1, arg2, arg3
}

function set(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    require ext_code.size(coreAddress)
    staticcall coreAddress.0x91d14854 with:
            gas gas_remaining wei
           args 0xf66846415d2bf9eabda9e84793ff9c0ea96d87f50fc41e66aa16469c6a442f05, msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if not ext_call.return_data[0]:
        revert with 0, 'CoreRef::onlyTimelock: Caller is not a timelock'
    if arg1 >= tranches.length:
        revert with 0, 'invalid tranche id'
    if arg2 < tranches[arg1].field_256:
        revert with 0, 'invalid target'
    if arg3 > 100000:
        revert with 0, 'invalid APY'
    if arg4 > 10000:
        revert with 0, 'invalid fee'
    require arg1 < tranches.length
    tranches[arg1].field_0 = arg2
    if not arg3:
        require arg1 < tranches.length
        tranches[arg1].field_512 = 0
    else:
        if 10^18 * arg3 / arg3 != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        require arg1 < tranches.length
        tranches[arg1].field_512 = 10^18 * arg3 / 100000
    tranches[arg1].field_768 = arg4
    emit 0x7304cbcb: arg1, arg2, arg3, arg4
}

function approveToken() payable {
    mem[64] = 96
    idx = 0
    while idx < tokenCount:
        require idx < tokens.length
        mem[0] = 10
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = address(tokens[idx].field_256)
        require ext_code.size(address(tokens[idx].field_0))
        staticcall address(tokens[idx].field_0).0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(tokens[idx].field_256)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _76 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_76]:
            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
        _78 = mem[64]
        mem[mem[64] + 36] = address(tokens[idx].field_256)
        mem[mem[64] + 68] = -1
        _80 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_80 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_80 + 36 len 28]
        mem[64] = _78 + 164
        mem[_78 + 100] = 32
        mem[_78 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(address(tokens[idx].field_0)):
            revert with 0, 'Address: call to non-contract'
        _88 = mem[_80]
        s = 0
        while s < _88:
            mem[s + _78 + 164] = mem[s + _80 + 32]
            s = s + 32
            continue 
        if ceil32(_88) > _88:
            mem[_88 + _78 + 164] = 0
        call address(tokens[idx].field_0).mem[_78 + 164 len 4] with:
             gas gas_remaining wei
            args mem[_78 + 168 len _88 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                mem[_78 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_78 + 168] = 32
                idx = 0
                while idx < 32:
                    mem[idx + _78 + 232] = mem[idx + _78 + 132]
                    idx = idx + 32
                    continue 
                revert with 0, 32, 32, mem[_78 + 232]
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[64] = _78 + ceil32(return_data.size) + 165
            mem[_78 + 164] = return_data.size
            mem[_78 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_78 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_78 + ceil32(return_data.size) + 169] = 32
                idx = 0
                while idx < 32:
                    mem[idx + _78 + ceil32(return_data.size) + 233] = mem[idx + _78 + 132]
                    idx = idx + 32
                    continue 
                revert with 0, 32, 32, mem[_78 + ceil32(return_data.size) + 233]
            if return_data.size:
                require return_data.size >= 32
                require mem[_78 + 196] == bool(mem[_78 + 196])
                if not mem[_78 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        idx = idx + 1
        continue 
}

function withdrawFee() payable {
    mem[64] = 96
    if not devAddress:
        revert with 0, 'devAddress not set'
    idx = 0
    while idx < tokens.length:
        mem[32] = 2
        mem[0] = 10
        _112 = mem[64]
        mem[mem[64] + 36] = devAddress
        mem[mem[64] + 68] = sub_1afe308e[address(stor10[idx].field_0)]
        _113 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_113 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_113 + 36 len 28]
        mem[64] = _112 + 164
        mem[_112 + 100] = 32
        mem[_112 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(address(tokens[idx].field_0)):
            revert with 0, 'Address: call to non-contract'
        _120 = mem[_113]
        s = 0
        while s < _120:
            mem[s + _112 + 164] = mem[s + _113 + 32]
            s = s + 32
            continue 
        if ceil32(_120) > _120:
            mem[_120 + _112 + 164] = 0
        call address(tokens[idx].field_0).mem[_112 + 164 len 4] with:
             gas gas_remaining wei
            args mem[_112 + 168 len _120 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                mem[_112 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_112 + 168] = 32
                idx = 0
                while idx < 32:
                    mem[idx + _112 + 232] = mem[idx + _112 + 132]
                    idx = idx + 32
                    continue 
                revert with 0, 32, 32, mem[_112 + 232]
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            require idx < tokens.length
            mem[32] = 2
            sub_1afe308e[address(stor10[idx].field_0)] = 0
            mem[0] = 10
            mem[_112 + 164] = devAddress
            mem[_112 + 196] = address(tokens[idx].field_0)
            mem[_112 + 228] = sub_1afe308e[address(stor10[idx].field_0)]
        else:
            mem[64] = _112 + ceil32(return_data.size) + 165
            mem[_112 + 164] = return_data.size
            mem[_112 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_112 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_112 + ceil32(return_data.size) + 169] = 32
                idx = 0
                while idx < 32:
                    mem[idx + _112 + ceil32(return_data.size) + 233] = mem[idx + _112 + 132]
                    idx = idx + 32
                    continue 
                revert with 0, 32, 32, mem[_112 + ceil32(return_data.size) + 233]
            if return_data.size:
                require return_data.size >= 32
                require mem[_112 + 196] == bool(mem[_112 + 196])
                if not mem[_112 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            require idx < tokens.length
            mem[32] = 2
            sub_1afe308e[address(stor10[idx].field_0)] = 0
            mem[0] = 10
            mem[_112 + ceil32(return_data.size) + 165] = devAddress
            mem[_112 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
            mem[_112 + ceil32(return_data.size) + 229] = sub_1afe308e[address(stor10[idx].field_0)]
        emit WithdrawFee(devAddress, address(tokens[idx].field_0), sub_1afe308e[address(stor10[idx].field_0)]);
        idx = idx + 1
        continue 
}

function redeem(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= tranches.length:
        revert with 0, 'invalid tranche id'
    if stor6:
        revert with 0, 'already active'
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        require tokenCount <= test266151307()
        mem[96] = tokenCount
        mem[64] = (32 * tokenCount) + 128
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(arg1, sha3(msg.sender, 14))
            if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                require idx < tokens.length
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokens.length
                userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require idx < tokens.length
                sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(arg1, sha3(msg.sender, 14))
                sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < mem[96]
                mem[(32 * idx) + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                mem[mem[64]] = msg.sender
                mem[mem[64] + 32] = arg1
                mem[mem[64] + 64] = cycle
                mem[mem[64] + 96] = idx
                mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
            idx = idx + 1
            continue 
    else:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[448] = 0
        mem[480] = 0
        mem[512] = 0
        mem[544] = 0
        mem[576] = 0
        mem[352] = 448
        mem[608] = 0
        mem[640] = 0
        mem[672] = 0
        mem[704] = 0
        mem[736] = 0
        mem[384] = 608
        mem[768] = 0
        mem[800] = 0
        mem[832] = 0
        mem[864] = 0
        mem[896] = 0
        mem[928] = 0
        mem[960] = 0
        mem[416] = 768
        mem[96] = 0
        require tokenCount <= test266151307()
        mem[992] = tokenCount
        mem[64] = (32 * tokenCount) + 1024
        if not tokenCount:
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1512 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1512] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1512 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1512 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1512 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1512 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1512
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _2996 = mem[64]
                mem[64] = mem[64] + 224
                mem[_2996] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_2996 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_2996 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_2996 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_2996 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_2996 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_2996 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _2996
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _4448 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_4448] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_4448 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_4448 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_4448 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_4448 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _4448
                        _4450 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _4901 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4901
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4901);
                                else:
                                    _4948 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4948
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4948);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _4983 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4983
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4983);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5028 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5028
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5028);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6924 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6924] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6924 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6924 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6924 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6924 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6924
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7160 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7160
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7160);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6916 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6916] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6916 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6916 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6916 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6916 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6916
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7154 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7154
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7154);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6908 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6908] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6908 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6908 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6908 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6908 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6908
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7148 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7148
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7148);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6900 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6900] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6900 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6900 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6900 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6900 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6900
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7142 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7142
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7142);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _4450 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _4976 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4976
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4976);
                                else:
                                    _5026 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5026
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5026);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5042 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5042
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5042);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5076 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5076
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5076);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6860 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6860] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6860 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6860 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6860 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6860 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6860
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7112 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7112
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7112);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6852 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6852] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6852 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6852 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6852 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6852 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6852
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7106 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7106
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7106);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6844 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6844] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6844 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6844 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6844 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6844 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6844
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7100 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7100
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7100);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6836 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6836] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6836 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6836 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6836 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6836 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6836
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7094 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7094
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7094);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _4432 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _4432
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            require tokenCount <= test266151307()
            _4430 = mem[64]
            mem[mem[64]] = tokenCount
            mem[64] = mem[64] + (32 * tokenCount) + 32
            if tokenCount:
                mem[_4430 + 32 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(arg1, sha3(msg.sender, 14))
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                    require idx < tokens.length
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[_4430]
                    mem[(32 * idx) + _4430 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = arg1
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                idx = idx + 1
                continue 
        else:
            mem[1024 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1516 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1516] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1516 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1516 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1516 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1516 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1516
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _2999 = mem[64]
                mem[64] = mem[64] + 224
                mem[_2999] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_2999 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_2999 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_2999 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_2999 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_2999 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_2999 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _2999
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _4456 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_4456] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_4456 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_4456 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_4456 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_4456 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _4456
                        _4458 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _4923 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4923
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4923);
                                else:
                                    _4968 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _4968
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _4968);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5008 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5008
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5008);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5039 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5039
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5039);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7054 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7054] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7054 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7054 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7054 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7054 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7054
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7262 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7262
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7262);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7046 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7046] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7046 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7046 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7046 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7046 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7046
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7256 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7256
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7256);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7038 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7038] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7038 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7038 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7038 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7038 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7038
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7250 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7250
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7250);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7030 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7030] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7030 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7030 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7030 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7030 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7030
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7244 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7244
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7244);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _4458 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _5001 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5001
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5001);
                                else:
                                    _5037 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5037
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5037);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5059 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5059
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5059);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5080 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5080
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5080);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6990 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6990] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6990 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6990 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6990 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6990 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6990
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7214 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7214
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7214);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6982 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6982] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6982 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6982 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6982 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6982 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6982
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7208 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7208
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7208);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6974 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6974] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6974 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6974 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6974 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6974 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6974
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7202 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7202
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7202);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _6966 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_6966] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_6966 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_6966 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_6966 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_6966 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _6966
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _7196 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _7196
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7196);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _4436 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _4436
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            require tokenCount <= test266151307()
            _4434 = mem[64]
            mem[mem[64]] = tokenCount
            mem[64] = mem[64] + (32 * tokenCount) + 32
            if tokenCount:
                mem[_4434 + 32 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(arg1, sha3(msg.sender, 14))
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                    require idx < tokens.length
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[_4434]
                    mem[(32 * idx) + _4434 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = arg1
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                idx = idx + 1
                continue 
    require arg1 < tranches.length
    if 0 > tranches[arg1].field_256:
        revert with 0, 'SafeMath: subtraction overflow'
    require ext_code.size(stakerAddress)
    call stakerAddress.0x15c2fdc9 with:
         gas gas_remaining wei
        args arg1, msg.sender, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function deposit(uint256[] arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        if arg1.length != tokenCount:
            revert with 0, 'invalid amountsIn'
        idx = 0
        while idx < tokenCount:
            require idx < arg1.length
            require idx < tokens.length
            mem[0] = 10
            _1766 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = this.address
            mem[mem[64] + 100] = cd[((32 * idx) + arg1 + 36)]
            _1789 = mem[64]
            mem[mem[64]] = 100
            mem[64] = mem[64] + 132
            mem[_1789 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_1789 + 36 len 28]
            mem[64] = _1766 + 196
            mem[_1766 + 132] = 32
            mem[_1766 + 164] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(tokens[idx].field_0)):
                revert with 0, 'Address: call to non-contract'
            _1856 = mem[_1789]
            s = 0
            while s < _1856:
                mem[s + _1766 + 196] = mem[s + _1789 + 32]
                s = s + 32
                continue 
            if ceil32(_1856) > _1856:
                mem[_1856 + _1766 + 196] = 0
            call address(tokens[idx].field_0).mem[_1766 + 196 len 4] with:
                 gas gas_remaining wei
                args mem[_1766 + 200 len _1856 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[_1766 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_1766 + 200] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _1766 + 264] = mem[idx + _1766 + 164]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_1766 + 264]
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require idx < tokens.length
                require idx < arg1.length
                if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokens.length
                mem[32] = sha3(msg.sender, 12)
                userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                mem[0] = 10
                require idx < arg1.length
                mem[_1766 + 196] = msg.sender
                mem[_1766 + 228] = address(tokens[idx].field_0)
                mem[_1766 + 260] = cd[((32 * idx) + arg1 + 36)]
            else:
                mem[64] = _1766 + ceil32(return_data.size) + 197
                mem[_1766 + 196] = return_data.size
                mem[_1766 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1766 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_1766 + ceil32(return_data.size) + 201] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _1766 + ceil32(return_data.size) + 265] = mem[idx + _1766 + 164]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_1766 + ceil32(return_data.size) + 265]
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_1766 + 228] == bool(mem[_1766 + 228])
                    if not mem[_1766 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require idx < tokens.length
                require idx < arg1.length
                if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokens.length
                mem[32] = sha3(msg.sender, 12)
                userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                mem[0] = 10
                require idx < arg1.length
                mem[_1766 + ceil32(return_data.size) + 197] = msg.sender
                mem[_1766 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                mem[_1766 + ceil32(return_data.size) + 261] = cd[((32 * idx) + arg1 + 36)]
            emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + arg1 + 36)]);
            idx = idx + 1
            continue 
    else:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[448] = 0
        mem[480] = 0
        mem[512] = 0
        mem[544] = 0
        mem[576] = 0
        mem[352] = 448
        mem[608] = 0
        mem[640] = 0
        mem[672] = 0
        mem[704] = 0
        mem[736] = 0
        mem[384] = 608
        mem[768] = 0
        mem[800] = 0
        mem[832] = 0
        mem[864] = 0
        mem[896] = 0
        mem[928] = 0
        mem[960] = 0
        mem[416] = 768
        mem[96] = 0
        require tokenCount <= test266151307()
        mem[992] = tokenCount
        mem[64] = (32 * tokenCount) + 1024
        if not tokenCount:
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1747 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1747] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1747 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1747 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1747 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1747 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1747
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3477 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3477] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3477 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3477 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3477 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3477 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3477 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3477 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3477
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _5245 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_5245] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_5245 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_5245 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_5245 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_5245 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _5245
                        _5247 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _5619 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5619
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5619);
                                else:
                                    _5674 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5674
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5674);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5721 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5721
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5721);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5770 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5770
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5770);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7861 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7861] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7861 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7861 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7861 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7861 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7861
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8091 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8091
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8091);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7853 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7853] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7853 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7853 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7853 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7853 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7853
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8085 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8085
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8085);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7845 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7845] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7845 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7845 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7845 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7845 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7845
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8079 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8079
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8079);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7837 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7837] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7837 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7837 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7837 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7837 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7837
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8073 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8073
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8073);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _5247 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _5714 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5714
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5714);
                                else:
                                    _5768 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5768
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5768);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5800 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5800
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5800);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5858 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5858
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5858);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7797 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7797] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7797 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7797 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7797 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7797 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7797
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8043 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8043
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8043);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7789 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7789] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7789 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7789 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7789 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7789 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7789
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8037 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8037
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8037);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7781 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7781] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7781 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7781 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7781 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7781 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7781
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8031 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8031
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8031);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7773 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7773] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7773 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7773 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7773 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7773 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7773
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8025 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8025
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8025);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _5229 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _5229
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if arg1.length != tokenCount:
                revert with 0, 'invalid amountsIn'
            idx = 0
            while idx < tokenCount:
                require idx < arg1.length
                require idx < tokens.length
                mem[0] = 10
                _8024 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = cd[((32 * idx) + arg1 + 36)]
                _8218 = mem[64]
                mem[mem[64]] = 100
                mem[64] = mem[64] + 132
                mem[_8218 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_8218 + 36 len 28]
                mem[64] = _8024 + 196
                mem[_8024 + 132] = 32
                mem[_8024 + 164] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(tokens[idx].field_0)):
                    revert with 0, 'Address: call to non-contract'
                _8520 = mem[_8218]
                s = 0
                while s < _8520:
                    mem[s + _8024 + 196] = mem[s + _8218 + 32]
                    s = s + 32
                    continue 
                if ceil32(_8520) > _8520:
                    mem[_8520 + _8024 + 196] = 0
                call address(tokens[idx].field_0).mem[_8024 + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[_8024 + 200 len _8520 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_8024 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_8024 + 200] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _8024 + 264] = mem[idx + _8024 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_8024 + 264]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < arg1.length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                    mem[0] = 10
                    require idx < arg1.length
                    mem[_8024 + 196] = msg.sender
                    mem[_8024 + 228] = address(tokens[idx].field_0)
                    mem[_8024 + 260] = cd[((32 * idx) + arg1 + 36)]
                else:
                    mem[64] = _8024 + ceil32(return_data.size) + 197
                    mem[_8024 + 196] = return_data.size
                    mem[_8024 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_8024 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_8024 + ceil32(return_data.size) + 201] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _8024 + ceil32(return_data.size) + 265] = mem[idx + _8024 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_8024 + ceil32(return_data.size) + 265]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_8024 + 228] == bool(mem[_8024 + 228])
                        if not mem[_8024 + 228]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < arg1.length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                    mem[0] = 10
                    require idx < arg1.length
                    mem[_8024 + ceil32(return_data.size) + 197] = msg.sender
                    mem[_8024 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                    mem[_8024 + ceil32(return_data.size) + 261] = cd[((32 * idx) + arg1 + 36)]
                emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + arg1 + 36)]);
                idx = idx + 1
                continue 
        else:
            mem[1024 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1751 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1751] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1751 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1751 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1751 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1751 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1751
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3480 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3480] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3480 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3480 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3480 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3480 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3480 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3480 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3480
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _5252 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_5252] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_5252 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_5252 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_5252 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_5252 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _5252
                        _5254 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _5641 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5641
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5641);
                                else:
                                    _5702 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5702
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5702);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5750 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5750
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5750);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5781 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5781
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5781);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7990 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7990] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7990 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7990 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7990 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7990 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7990
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8188 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8188
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8188);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7982 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7982] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7982 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7982 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7982 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7982 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7982
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8182 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8182
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8182);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7974 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7974] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7974 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7974 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7974 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7974 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7974
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8176 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8176
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8176);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7966 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7966] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7966 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7966 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7966 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7966 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7966
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8170 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8170
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8170);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _5254 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _5743 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5743
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5743);
                                else:
                                    _5779 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5779
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5779);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _5833 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _5833
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5833);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _5870 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _5870
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _5870);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7926 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7926] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7926 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7926 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7926 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7926 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7926
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8140 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8140
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8140);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7918 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7918] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7918 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7918 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7918 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7918 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7918
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8134 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8134
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8134);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7910 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7910] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7910 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7910 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7910 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7910 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7910
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8128 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8128
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8128);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _7902 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_7902] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_7902 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_7902 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_7902 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_7902 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _7902
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _8122 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8122
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8122);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _5232 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _5232
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if arg1.length != tokenCount:
                revert with 0, 'invalid amountsIn'
            idx = 0
            while idx < tokenCount:
                require idx < arg1.length
                require idx < tokens.length
                mem[0] = 10
                _8121 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = cd[((32 * idx) + arg1 + 36)]
                _8236 = mem[64]
                mem[mem[64]] = 100
                mem[64] = mem[64] + 132
                mem[_8236 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_8236 + 36 len 28]
                mem[64] = _8121 + 196
                mem[_8121 + 132] = 32
                mem[_8121 + 164] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(tokens[idx].field_0)):
                    revert with 0, 'Address: call to non-contract'
                _8569 = mem[_8236]
                s = 0
                while s < _8569:
                    mem[s + _8121 + 196] = mem[s + _8236 + 32]
                    s = s + 32
                    continue 
                if ceil32(_8569) > _8569:
                    mem[_8569 + _8121 + 196] = 0
                call address(tokens[idx].field_0).mem[_8121 + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[_8121 + 200 len _8569 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_8121 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_8121 + 200] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _8121 + 264] = mem[idx + _8121 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_8121 + 264]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < arg1.length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                    mem[0] = 10
                    require idx < arg1.length
                    mem[_8121 + 196] = msg.sender
                    mem[_8121 + 228] = address(tokens[idx].field_0)
                    mem[_8121 + 260] = cd[((32 * idx) + arg1 + 36)]
                else:
                    mem[64] = _8121 + ceil32(return_data.size) + 197
                    mem[_8121 + 196] = return_data.size
                    mem[_8121 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_8121 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_8121 + ceil32(return_data.size) + 201] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _8121 + ceil32(return_data.size) + 265] = mem[idx + _8121 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_8121 + ceil32(return_data.size) + 265]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_8121 + 228] == bool(mem[_8121 + 228])
                        if not mem[_8121 + 228]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < arg1.length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + arg1 + 36)] < cd[((32 * idx) + arg1 + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + arg1 + 36)]
                    mem[0] = 10
                    require idx < arg1.length
                    mem[_8121 + ceil32(return_data.size) + 197] = msg.sender
                    mem[_8121 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                    mem[_8121 + ceil32(return_data.size) + 261] = cd[((32 * idx) + arg1 + 36)]
                emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + arg1 + 36)]);
                idx = idx + 1
                continue 
    stor1 = 1
}

function withdraw(uint256[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require calldata.size > arg1 + 35
    require arg1.length <= test266151307()
    require (32 * arg1.length) + 128 >= 96 and (32 * arg1.length) + 128 <= test266151307()
    mem[64] = (32 * arg1.length) + 128
    mem[96] = arg1.length
    require calldata.size >= arg1 + (32 * arg1.length) + 36
    s = arg1 + 36
    t = 128
    idx = 0
    while idx < arg1.length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        idx = 0
        while idx < tokenCount:
            require idx < mem[96]
            _3161 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] > 0:
                require idx < tokens.length
                if mem[(32 * idx) + 128] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                require idx < tokens.length
                mem[32] = sha3(msg.sender, 12)
                userBalances[msg.sender][address(stor10[idx].field_0)] -= mem[(32 * idx) + 128]
                mem[0] = 10
                _3233 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = _3161
                _3256 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_3256 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_3256 + 36 len 28]
                mem[64] = _3233 + 164
                mem[_3233 + 100] = 32
                mem[_3233 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(tokens[idx].field_0)):
                    revert with 0, 'Address: call to non-contract'
                _3295 = mem[_3256]
                s = 0
                while s < _3295:
                    mem[s + _3233 + 164] = mem[s + _3256 + 32]
                    s = s + 32
                    continue 
                if ceil32(_3295) > _3295:
                    mem[_3295 + _3233 + 164] = 0
                call address(tokens[idx].field_0).mem[_3233 + 164 len 4] with:
                     gas gas_remaining wei
                    args mem[_3233 + 168 len _3295 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_3233 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3233 + 168] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3233 + 232] = mem[idx + _3233 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3233 + 232]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[_3233 + 164] = msg.sender
                    mem[_3233 + 196] = address(tokens[idx].field_0)
                    mem[_3233 + 228] = _3161
                else:
                    mem[64] = _3233 + ceil32(return_data.size) + 165
                    mem[_3233 + 164] = return_data.size
                    mem[_3233 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3233 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_3233 + ceil32(return_data.size) + 169] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _3233 + ceil32(return_data.size) + 233] = mem[idx + _3233 + 132]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_3233 + ceil32(return_data.size) + 233]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3233 + 196] == bool(mem[_3233 + 196])
                        if not mem[_3233 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[_3233 + ceil32(return_data.size) + 165] = msg.sender
                    mem[_3233 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                    mem[_3233 + ceil32(return_data.size) + 229] = _3161
                emit Withdraw(msg.sender, address(tokens[idx].field_0), _3161);
            idx = idx + 1
            continue 
    else:
        mem[(32 * arg1.length) + 160] = 0
        mem[(32 * arg1.length) + 192] = 0
        mem[(32 * arg1.length) + 224] = 0
        mem[(32 * arg1.length) + 256] = 0
        mem[(32 * arg1.length) + 288] = 0
        mem[(32 * arg1.length) + 320] = 0
        mem[(32 * arg1.length) + 480] = 0
        mem[(32 * arg1.length) + 512] = 0
        mem[(32 * arg1.length) + 544] = 0
        mem[(32 * arg1.length) + 576] = 0
        mem[(32 * arg1.length) + 608] = 0
        mem[(32 * arg1.length) + 384] = (32 * arg1.length) + 480
        mem[(32 * arg1.length) + 640] = 0
        mem[(32 * arg1.length) + 672] = 0
        mem[(32 * arg1.length) + 704] = 0
        mem[(32 * arg1.length) + 736] = 0
        mem[(32 * arg1.length) + 768] = 0
        mem[(32 * arg1.length) + 416] = (32 * arg1.length) + 640
        mem[(32 * arg1.length) + 800] = 0
        mem[(32 * arg1.length) + 832] = 0
        mem[(32 * arg1.length) + 864] = 0
        mem[(32 * arg1.length) + 896] = 0
        mem[(32 * arg1.length) + 928] = 0
        mem[(32 * arg1.length) + 960] = 0
        mem[(32 * arg1.length) + 992] = 0
        mem[(32 * arg1.length) + 448] = (32 * arg1.length) + 800
        mem[(32 * arg1.length) + 128] = 0
        require tokenCount <= test266151307()
        mem[(32 * arg1.length) + 1024] = tokenCount
        mem[64] = (32 * arg1.length) + (32 * tokenCount) + 1056
        if not tokenCount:
            mem[(32 * arg1.length) + 352] = (32 * arg1.length) + 1024
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _3155 = mem[64]
                mem[64] = mem[64] + 160
                mem[_3155] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_3155 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_3155 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_3155 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_3155 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[(32 * arg1.length) + 384] = _3155
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[(32 * arg1.length) + 128] < mem[(32 * arg1.length) + 128]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * arg1.length) + 128] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[(32 * arg1.length) + 128]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _4718 = mem[64]
                mem[64] = mem[64] + 224
                mem[_4718] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_4718 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_4718 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_4718 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_4718 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_4718 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_4718 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[(32 * arg1.length) + 448] = _4718
                mem[(32 * arg1.length) + 160] = 0
                mem[(32 * arg1.length) + 192] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[(32 * arg1.length) + 288] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * arg1.length) + 192] < mem[(32 * arg1.length) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(32 * arg1.length) + 192] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * arg1.length) + 192]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6310 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6310] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6310 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6310 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6310 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6310 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[(32 * arg1.length) + 384] = _6310
                        _6312 = mem[mem[(32 * arg1.length) + 448] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[(32 * arg1.length) + 224] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[(32 * arg1.length) + 256] = 0
                                if mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6668 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6668
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6668);
                                else:
                                    _6715 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6715
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6715);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(32 * arg1.length) + 256] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    _6754 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6754
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6754);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        _6811 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6811
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6811);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8818 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8818] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8818 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8818 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8818 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8818 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8818
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9049 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9049
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9049);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8810 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8810] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8810 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8810 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8810 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8810 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8810
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9043 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9043
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9043);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8802 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8802] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8802 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8802 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8802 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8802 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8802
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9037 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9037
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9037);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8794 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8794] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8794 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8794 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8794 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8794 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8794
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9031 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9031
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9031);
                        else:
                            if mem[mem[(32 * arg1.length) + 448] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[(32 * arg1.length) + 448] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[(32 * arg1.length) + 224] = mem[mem[(32 * arg1.length) + 448] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6312 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[(32 * arg1.length) + 256] = 0
                                if mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * arg1.length) + 160] = mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160]
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6747 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6747
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6747);
                                else:
                                    _6809 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6809
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6809);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[(32 * arg1.length) + 224]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(32 * arg1.length) + 256] = mem[(32 * arg1.length) + 224] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * arg1.length) + 160] = mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160]
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    _6837 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6837
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6837);
                                else:
                                    if not mem[(32 * arg1.length) + 224] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        _6875 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6875
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6875);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(32 * arg1.length) + 256]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(32 * arg1.length) + 256]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8754 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8754] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8754 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8754 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8754 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8754 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8754
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9001 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9001
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9001);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8746 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8746] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8746 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8746 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8746 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8746 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8746
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _8995 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8995
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8995);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(32 * arg1.length) + 256]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8738 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8738] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8738 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8738 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8738 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8738 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8738
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _8989 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8989
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8989);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8730 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8730] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8730 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8730 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8730 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8730 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8730
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _8983 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _8983
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _8983);
                    s = s + 1
                    continue 
                if mem[(32 * arg1.length) + 192]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[(32 * arg1.length) + 352]]
                if mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[(32 * arg1.length) + 352]]
                    _6292 = mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _6292
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            idx = 0
            while idx < tokenCount:
                require idx < mem[96]
                _8625 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] > 0:
                    require idx < tokens.length
                    if mem[(32 * idx) + 128] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= mem[(32 * idx) + 128]
                    mem[0] = 10
                    _9253 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = _8625
                    _9319 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_9319 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_9319 + 36 len 28]
                    mem[64] = _9253 + 164
                    mem[_9253 + 100] = 32
                    mem[_9253 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(tokens[idx].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    _9877 = mem[_9319]
                    s = 0
                    while s < _9877:
                        mem[s + _9253 + 164] = mem[s + _9319 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_9877) > _9877:
                        mem[_9877 + _9253 + 164] = 0
                    call address(tokens[idx].field_0).mem[_9253 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_9253 + 168 len _9877 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_9253 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_9253 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _9253 + 232] = mem[idx + _9253 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_9253 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_9253 + 164] = msg.sender
                        mem[_9253 + 196] = address(tokens[idx].field_0)
                        mem[_9253 + 228] = _8625
                    else:
                        mem[64] = _9253 + ceil32(return_data.size) + 165
                        mem[_9253 + 164] = return_data.size
                        mem[_9253 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_9253 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_9253 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _9253 + ceil32(return_data.size) + 233] = mem[idx + _9253 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_9253 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_9253 + 196] == bool(mem[_9253 + 196])
                            if not mem[_9253 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_9253 + ceil32(return_data.size) + 165] = msg.sender
                        mem[_9253 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                        mem[_9253 + ceil32(return_data.size) + 229] = _8625
                    emit Withdraw(msg.sender, address(tokens[idx].field_0), _8625);
                idx = idx + 1
                continue 
        else:
            mem[(32 * arg1.length) + 1056 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[(32 * arg1.length) + 352] = (32 * arg1.length) + 1024
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _3159 = mem[64]
                mem[64] = mem[64] + 160
                mem[_3159] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_3159 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_3159 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_3159 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_3159 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[(32 * arg1.length) + 384] = _3159
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[(32 * arg1.length) + 128] < mem[(32 * arg1.length) + 128]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * arg1.length) + 128] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[(32 * arg1.length) + 128]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _4721 = mem[64]
                mem[64] = mem[64] + 224
                mem[_4721] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_4721 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_4721 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_4721 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_4721 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_4721 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_4721 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[(32 * arg1.length) + 448] = _4721
                mem[(32 * arg1.length) + 160] = 0
                mem[(32 * arg1.length) + 192] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[(32 * arg1.length) + 288] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * arg1.length) + 192] < mem[(32 * arg1.length) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(32 * arg1.length) + 192] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * arg1.length) + 192]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6317 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6317] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6317 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6317 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6317 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6317 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[(32 * arg1.length) + 384] = _6317
                        _6319 = mem[mem[(32 * arg1.length) + 448] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[(32 * arg1.length) + 224] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[(32 * arg1.length) + 256] = 0
                                if mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6690 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6690
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6690);
                                else:
                                    _6735 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6735
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6735);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(32 * arg1.length) + 256] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    _6783 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6783
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6783);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        _6830 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6830
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6830);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8947 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8947] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8947 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8947 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8947 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8947 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8947
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9147 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9147
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9147);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8939 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8939] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8939 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8939 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8939 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8939 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8939
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9141 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9141
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9141);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8931 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8931] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8931 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8931 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8931 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8931 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8931
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9135 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9135
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9135);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8923 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8923] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8923 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8923 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8923 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8923 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8923
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9129 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9129
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9129);
                        else:
                            if mem[mem[(32 * arg1.length) + 448] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[(32 * arg1.length) + 448] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[(32 * arg1.length) + 224] = mem[mem[(32 * arg1.length) + 448] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6319 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[(32 * arg1.length) + 256] = 0
                                if mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * arg1.length) + 160] = mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160]
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6776 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6776
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6776);
                                else:
                                    _6828 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6828
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6828);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[(32 * arg1.length) + 224]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(32 * arg1.length) + 256] = mem[(32 * arg1.length) + 224] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160] < mem[(32 * arg1.length) + 160]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * arg1.length) + 160] = mem[(32 * arg1.length) + 224] + mem[(32 * arg1.length) + 160]
                                require s < mem[mem[(32 * arg1.length) + 352]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[(32 * arg1.length) + 352]]
                                    _6858 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6858
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6858);
                                else:
                                    if not mem[(32 * arg1.length) + 224] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = mem[(32 * arg1.length) + 224] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        _6879 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6879
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6879);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(32 * arg1.length) + 352]]
                                        mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(32 * arg1.length) + 256]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(32 * arg1.length) + 256]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8883 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8883] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8883 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8883 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8883 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8883 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8883
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9099 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9099
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9099);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8875 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8875] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8875 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8875 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8875 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8875 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8875
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9093 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9093
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9093);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(32 * arg1.length) + 352]]
                                            mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(32 * arg1.length) + 256]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8867 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8867] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8867 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8867 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8867 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8867 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8867
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9087 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9087
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9087);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / mem[(32 * arg1.length) + 256] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[(32 * arg1.length) + 320] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[(32 * arg1.length) + 256] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8859 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8859] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8859 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8859 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8859 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8859 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[(32 * arg1.length) + 416] = _8859
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[(32 * arg1.length) + 320]:
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (0 / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 320] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(32 * arg1.length) + 128] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(32 * arg1.length) + 128]
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[(32 * arg1.length) + 352]]
                                                                mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[(32 * arg1.length) + 320] / mem[(32 * arg1.length) + 128]) + mem[(32 * t) + mem[(32 * arg1.length) + 352] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[(32 * arg1.length) + 352]]
                                                _9081 = mem[(32 * s) + mem[(32 * arg1.length) + 352] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9081
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9081);
                    s = s + 1
                    continue 
                if mem[(32 * arg1.length) + 192]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[(32 * arg1.length) + 352]]
                if mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[(32 * arg1.length) + 352]]
                    _6295 = mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32] < mem[(32 * idx) + mem[(32 * arg1.length) + 352] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _6295
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            idx = 0
            while idx < tokenCount:
                require idx < mem[96]
                _8674 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] > 0:
                    require idx < tokens.length
                    if mem[(32 * idx) + 128] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= mem[(32 * idx) + 128]
                    mem[0] = 10
                    _9286 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = _8674
                    _9385 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_9385 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_9385 + 36 len 28]
                    mem[64] = _9286 + 164
                    mem[_9286 + 100] = 32
                    mem[_9286 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(tokens[idx].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    _9878 = mem[_9385]
                    s = 0
                    while s < _9878:
                        mem[s + _9286 + 164] = mem[s + _9385 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_9878) > _9878:
                        mem[_9878 + _9286 + 164] = 0
                    call address(tokens[idx].field_0).mem[_9286 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_9286 + 168 len _9878 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_9286 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_9286 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _9286 + 232] = mem[idx + _9286 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_9286 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_9286 + 164] = msg.sender
                        mem[_9286 + 196] = address(tokens[idx].field_0)
                        mem[_9286 + 228] = _8674
                    else:
                        mem[64] = _9286 + ceil32(return_data.size) + 165
                        mem[_9286 + 164] = return_data.size
                        mem[_9286 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_9286 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_9286 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _9286 + ceil32(return_data.size) + 233] = mem[idx + _9286 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_9286 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_9286 + 196] == bool(mem[_9286 + 196])
                            if not mem[_9286 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_9286 + ceil32(return_data.size) + 165] = msg.sender
                        mem[_9286 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                        mem[_9286 + ceil32(return_data.size) + 229] = _8674
                    emit Withdraw(msg.sender, address(tokens[idx].field_0), _8674);
                idx = idx + 1
                continue 
    stor1 = 1
}

function sub_5f5d217d(?) payable {
    require calldata.size - 4 >= 32
    if arg1 >= tranches.length:
        revert with 0, 'invalid tranche id'
    if stor6:
        revert with 0, 'already active'
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        require tokenCount <= test266151307()
        mem[96] = tokenCount
        mem[64] = (32 * tokenCount) + 128
        if not tokenCount:
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(arg1, sha3(msg.sender, 14))
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                    require idx < tokens.length
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = arg1
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                idx = idx + 1
                continue 
            require arg1 < tranches.length
            mem[0] = 7
            if 0 > tranches[arg1].field_256:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = 0
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args arg1, msg.sender, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            idx = 0
            while idx < tokenCount:
                require idx < mem[96]
                _4178 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] > 0:
                    require idx < tokens.length
                    if mem[(32 * idx) + 128] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= mem[(32 * idx) + 128]
                    mem[0] = 10
                    _4266 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = _4178
                    _4294 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4294 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4294 + 36 len 28]
                    mem[64] = _4266 + 164
                    mem[_4266 + 100] = 32
                    mem[_4266 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(tokens[idx].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    _4386 = mem[_4294]
                    s = 0
                    while s < _4386:
                        mem[s + _4266 + 164] = mem[s + _4294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4386) > _4386:
                        mem[_4386 + _4266 + 164] = 0
                    call address(tokens[idx].field_0).mem[_4266 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4266 + 168 len _4386 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4266 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4266 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4266 + 232] = mem[idx + _4266 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4266 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_4266 + 164] = msg.sender
                        mem[_4266 + 196] = address(tokens[idx].field_0)
                        mem[_4266 + 228] = _4178
                    else:
                        mem[64] = _4266 + ceil32(return_data.size) + 165
                        mem[_4266 + 164] = return_data.size
                        mem[_4266 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4266 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4266 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4266 + ceil32(return_data.size) + 233] = mem[idx + _4266 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4266 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4266 + 196] == bool(mem[_4266 + 196])
                            if not mem[_4266 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_4266 + ceil32(return_data.size) + 165] = msg.sender
                        mem[_4266 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                        mem[_4266 + ceil32(return_data.size) + 229] = _4178
                    emit Withdraw(msg.sender, address(tokens[idx].field_0), _4178);
                idx = idx + 1
                continue 
        else:
            mem[128 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(arg1, sha3(msg.sender, 14))
                if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                    require idx < tokens.length
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = arg1
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                    emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                idx = idx + 1
                continue 
            require arg1 < tranches.length
            mem[0] = 7
            if 0 > tranches[arg1].field_256:
                revert with 0, 'SafeMath: subtraction overflow'
            mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg1
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = 0
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args arg1, msg.sender, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            idx = 0
            while idx < tokenCount:
                require idx < mem[96]
                _4179 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] > 0:
                    require idx < tokens.length
                    if mem[(32 * idx) + 128] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= mem[(32 * idx) + 128]
                    mem[0] = 10
                    _4267 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = _4179
                    _4296 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_4296 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_4296 + 36 len 28]
                    mem[64] = _4267 + 164
                    mem[_4267 + 100] = 32
                    mem[_4267 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(tokens[idx].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    _4387 = mem[_4296]
                    s = 0
                    while s < _4387:
                        mem[s + _4267 + 164] = mem[s + _4296 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_4387) > _4387:
                        mem[_4387 + _4267 + 164] = 0
                    call address(tokens[idx].field_0).mem[_4267 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_4267 + 168 len _4387 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_4267 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4267 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4267 + 232] = mem[idx + _4267 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4267 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_4267 + 164] = msg.sender
                        mem[_4267 + 196] = address(tokens[idx].field_0)
                        mem[_4267 + 228] = _4179
                    else:
                        mem[64] = _4267 + ceil32(return_data.size) + 165
                        mem[_4267 + 164] = return_data.size
                        mem[_4267 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_4267 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_4267 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _4267 + ceil32(return_data.size) + 233] = mem[idx + _4267 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_4267 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_4267 + 196] == bool(mem[_4267 + 196])
                            if not mem[_4267 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[_4267 + ceil32(return_data.size) + 165] = msg.sender
                        mem[_4267 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                        mem[_4267 + ceil32(return_data.size) + 229] = _4179
                    emit Withdraw(msg.sender, address(tokens[idx].field_0), _4179);
                idx = idx + 1
                continue 
    else:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[448] = 0
        mem[480] = 0
        mem[512] = 0
        mem[544] = 0
        mem[576] = 0
        mem[352] = 448
        mem[608] = 0
        mem[640] = 0
        mem[672] = 0
        mem[704] = 0
        mem[736] = 0
        mem[384] = 608
        mem[768] = 0
        mem[800] = 0
        mem[832] = 0
        mem[864] = 0
        mem[896] = 0
        mem[928] = 0
        mem[960] = 0
        mem[416] = 768
        mem[96] = 0
        require tokenCount <= test266151307()
        mem[992] = tokenCount
        mem[64] = (32 * tokenCount) + 1024
        if not tokenCount:
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _2100 = mem[64]
                mem[64] = mem[64] + 160
                mem[_2100] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_2100 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_2100 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_2100 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_2100 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _2100
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _4172 = mem[64]
                mem[64] = mem[64] + 224
                mem[_4172] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_4172 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_4172 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_4172 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_4172 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_4172 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_4172 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _4172
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6222 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6222] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6222 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6222 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6222 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6222 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _6222
                        _6224 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6878 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6878
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6878);
                                else:
                                    _6926 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6926
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6926);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6962 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6962
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6962);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _7009 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _7009
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7009);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9242 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9242] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9242 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9242 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9242 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9242 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9242
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9478 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9478
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9478);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9234 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9234] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9234 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9234 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9234 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9234 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9234
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9472 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9472
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9472);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9226 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9226] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9226 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9226 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9226 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9226 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9226
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9466 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9466
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9466);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9218 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9218] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9218 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9218 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9218 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9218 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9218
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9460 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9460
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9460);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6224 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6955 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6955
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6955);
                                else:
                                    _7007 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _7007
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7007);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _7025 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _7025
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7025);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _7063 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _7063
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7063);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9178 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9178] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9178 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9178 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9178 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9178 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9178
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9430 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9430
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9430);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9170 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9170] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9170 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9170 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9170 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9170 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9170
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9424 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9424
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9424);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9162 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9162] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9162 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9162 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9162 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9162 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9162
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9418 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9418
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9418);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9154 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9154] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9154 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9154 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9154 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9154 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9154
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9412 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9412
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9412);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _6202 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _6202
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            require tokenCount <= test266151307()
            _6200 = mem[64]
            mem[mem[64]] = tokenCount
            mem[64] = mem[64] + (32 * tokenCount) + 32
            if not tokenCount:
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(arg1, sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < mem[_6200]
                        mem[(32 * idx) + _6200 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[mem[64]] = msg.sender
                        mem[mem[64] + 32] = arg1
                        mem[mem[64] + 64] = cycle
                        mem[mem[64] + 96] = idx
                        mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                require arg1 < tranches.length
                mem[0] = 7
                if 0 > tranches[arg1].field_256:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = 0
                require ext_code.size(stakerAddress)
                call stakerAddress.0x15c2fdc9 with:
                     gas gas_remaining wei
                    args arg1, msg.sender, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = 0
                while idx < tokenCount:
                    require idx < mem[_6200]
                    _10802 = mem[(32 * idx) + _6200 + 32]
                    if mem[(32 * idx) + _6200 + 32] > 0:
                        require idx < tokens.length
                        if mem[(32 * idx) + _6200 + 32] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= _10802
                        mem[0] = 10
                        _10842 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = _10802
                        _10846 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_10846 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_10846 + 36 len 28]
                        mem[64] = _10842 + 164
                        mem[_10842 + 100] = 32
                        mem[_10842 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _10874 = mem[_10846]
                        s = 0
                        while s < _10874:
                            mem[s + _10842 + 164] = mem[s + _10846 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_10874) > _10874:
                            mem[_10874 + _10842 + 164] = 0
                        call address(tokens[idx].field_0).mem[_10842 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_10842 + 168 len _10874 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_10842 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10842 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10842 + 232] = mem[idx + _10842 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10842 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10842 + 164] = msg.sender
                            mem[_10842 + 196] = address(tokens[idx].field_0)
                            mem[_10842 + 228] = _10802
                        else:
                            mem[64] = _10842 + ceil32(return_data.size) + 165
                            mem[_10842 + 164] = return_data.size
                            mem[_10842 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_10842 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10842 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10842 + ceil32(return_data.size) + 233] = mem[idx + _10842 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10842 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_10842 + 196] == bool(mem[_10842 + 196])
                                if not mem[_10842 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10842 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_10842 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_10842 + ceil32(return_data.size) + 229] = _10802
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), _10802);
                    idx = idx + 1
                    continue 
            else:
                mem[_6200 + 32 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(arg1, sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < mem[_6200]
                        mem[(32 * idx) + _6200 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[mem[64]] = msg.sender
                        mem[mem[64] + 32] = arg1
                        mem[mem[64] + 64] = cycle
                        mem[mem[64] + 96] = idx
                        mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                require arg1 < tranches.length
                mem[0] = 7
                if 0 > tranches[arg1].field_256:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = 0
                require ext_code.size(stakerAddress)
                call stakerAddress.0x15c2fdc9 with:
                     gas gas_remaining wei
                    args arg1, msg.sender, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = 0
                while idx < tokenCount:
                    require idx < mem[_6200]
                    _10803 = mem[(32 * idx) + _6200 + 32]
                    if mem[(32 * idx) + _6200 + 32] > 0:
                        require idx < tokens.length
                        if mem[(32 * idx) + _6200 + 32] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= _10803
                        mem[0] = 10
                        _10843 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = _10803
                        _10848 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_10848 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_10848 + 36 len 28]
                        mem[64] = _10843 + 164
                        mem[_10843 + 100] = 32
                        mem[_10843 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _10875 = mem[_10848]
                        s = 0
                        while s < _10875:
                            mem[s + _10843 + 164] = mem[s + _10848 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_10875) > _10875:
                            mem[_10875 + _10843 + 164] = 0
                        call address(tokens[idx].field_0).mem[_10843 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_10843 + 168 len _10875 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_10843 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10843 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10843 + 232] = mem[idx + _10843 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10843 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10843 + 164] = msg.sender
                            mem[_10843 + 196] = address(tokens[idx].field_0)
                            mem[_10843 + 228] = _10803
                        else:
                            mem[64] = _10843 + ceil32(return_data.size) + 165
                            mem[_10843 + 164] = return_data.size
                            mem[_10843 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_10843 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10843 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10843 + ceil32(return_data.size) + 233] = mem[idx + _10843 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10843 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_10843 + 196] == bool(mem[_10843 + 196])
                                if not mem[_10843 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10843 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_10843 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_10843 + ceil32(return_data.size) + 229] = _10803
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), _10803);
                    idx = idx + 1
                    continue 
        else:
            mem[1024 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _2104 = mem[64]
                mem[64] = mem[64] + 160
                mem[_2104] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_2104 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_2104 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_2104 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_2104 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _2104
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _4175 = mem[64]
                mem[64] = mem[64] + 224
                mem[_4175] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_4175 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_4175 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_4175 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_4175 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_4175 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_4175 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _4175
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6230 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6230] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6230 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6230 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6230 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6230 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _6230
                        _6232 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6901 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6901
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6901);
                                else:
                                    _6946 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6946
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6946);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6988 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6988
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6988);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _7021 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _7021
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7021);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9372 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9372] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9372 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9372 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9372 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9372 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9372
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9580 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9580
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9580);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9364 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9364] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9364 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9364 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9364 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9364 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9364
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9574 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9574
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9574);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9356 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9356] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9356 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9356 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9356 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9356 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9356
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9568 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9568
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9568);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9348 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9348] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9348 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9348 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9348 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9348 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9348
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9562 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9562
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9562);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6232 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6981 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6981
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6981);
                                else:
                                    _7019 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _7019
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7019);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _7043 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _7043
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7043);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _7070 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _7070
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _7070);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9308 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9308] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9308 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9308 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9308 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9308 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9308
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9532 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9532
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9532);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9300 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9300] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9300 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9300 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9300 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9300 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9300
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9526 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9526
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9526);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9292 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9292] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9292 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9292 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9292 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9292 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9292
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9520 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9520
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9520);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9284 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9284] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9284 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9284 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9284 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9284 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9284
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9514 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9514
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9514);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _6206 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _6206
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            require tokenCount <= test266151307()
            _6204 = mem[64]
            mem[mem[64]] = tokenCount
            mem[64] = mem[64] + (32 * tokenCount) + 32
            if not tokenCount:
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(arg1, sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < mem[_6204]
                        mem[(32 * idx) + _6204 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[mem[64]] = msg.sender
                        mem[mem[64] + 32] = arg1
                        mem[mem[64] + 64] = cycle
                        mem[mem[64] + 96] = idx
                        mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                require arg1 < tranches.length
                mem[0] = 7
                if 0 > tranches[arg1].field_256:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = 0
                require ext_code.size(stakerAddress)
                call stakerAddress.0x15c2fdc9 with:
                     gas gas_remaining wei
                    args arg1, msg.sender, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = 0
                while idx < tokenCount:
                    require idx < mem[_6204]
                    _10804 = mem[(32 * idx) + _6204 + 32]
                    if mem[(32 * idx) + _6204 + 32] > 0:
                        require idx < tokens.length
                        if mem[(32 * idx) + _6204 + 32] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= _10804
                        mem[0] = 10
                        _10844 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = _10804
                        _10850 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_10850 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_10850 + 36 len 28]
                        mem[64] = _10844 + 164
                        mem[_10844 + 100] = 32
                        mem[_10844 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _10876 = mem[_10850]
                        s = 0
                        while s < _10876:
                            mem[s + _10844 + 164] = mem[s + _10850 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_10876) > _10876:
                            mem[_10876 + _10844 + 164] = 0
                        call address(tokens[idx].field_0).mem[_10844 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_10844 + 168 len _10876 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_10844 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10844 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10844 + 232] = mem[idx + _10844 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10844 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10844 + 164] = msg.sender
                            mem[_10844 + 196] = address(tokens[idx].field_0)
                            mem[_10844 + 228] = _10804
                        else:
                            mem[64] = _10844 + ceil32(return_data.size) + 165
                            mem[_10844 + 164] = return_data.size
                            mem[_10844 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_10844 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10844 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10844 + ceil32(return_data.size) + 233] = mem[idx + _10844 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10844 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_10844 + 196] == bool(mem[_10844 + 196])
                                if not mem[_10844 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10844 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_10844 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_10844 + ceil32(return_data.size) + 229] = _10804
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), _10804);
                    idx = idx + 1
                    continue 
            else:
                mem[_6204 + 32 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(arg1, sha3(msg.sender, 14))
                    if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] + userBalances[msg.sender][address(stor10[idx].field_0)] < userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] += sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] > sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][arg1][address(stor10[idx].field_0)] -= sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(arg1, sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] = 0
                        if sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < mem[_6204]
                        mem[(32 * idx) + _6204 + 32] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        mem[mem[64]] = msg.sender
                        mem[mem[64] + 32] = arg1
                        mem[mem[64] + 64] = cycle
                        mem[mem[64] + 96] = idx
                        mem[mem[64] + 128] = sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]
                        emit Redeem(msg.sender, arg1, cycle, idx, sub_6aad5e20[msg.sender][arg1][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                require arg1 < tranches.length
                mem[0] = 7
                if 0 > tranches[arg1].field_256:
                    revert with 0, 'SafeMath: subtraction overflow'
                mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = arg1
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = 0
                require ext_code.size(stakerAddress)
                call stakerAddress.0x15c2fdc9 with:
                     gas gas_remaining wei
                    args arg1, msg.sender, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = 0
                while idx < tokenCount:
                    require idx < mem[_6204]
                    _10805 = mem[(32 * idx) + _6204 + 32]
                    if mem[(32 * idx) + _6204 + 32] > 0:
                        require idx < tokens.length
                        if mem[(32 * idx) + _6204 + 32] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= _10805
                        mem[0] = 10
                        _10845 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = _10805
                        _10852 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_10852 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_10852 + 36 len 28]
                        mem[64] = _10845 + 164
                        mem[_10845 + 100] = 32
                        mem[_10845 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _10877 = mem[_10852]
                        s = 0
                        while s < _10877:
                            mem[s + _10845 + 164] = mem[s + _10852 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_10877) > _10877:
                            mem[_10877 + _10845 + 164] = 0
                        call address(tokens[idx].field_0).mem[_10845 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_10845 + 168 len _10877 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_10845 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10845 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10845 + 232] = mem[idx + _10845 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10845 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10845 + 164] = msg.sender
                            mem[_10845 + 196] = address(tokens[idx].field_0)
                            mem[_10845 + 228] = _10805
                        else:
                            mem[64] = _10845 + ceil32(return_data.size) + 165
                            mem[_10845 + 164] = return_data.size
                            mem[_10845 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_10845 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_10845 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _10845 + ceil32(return_data.size) + 233] = mem[idx + _10845 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_10845 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_10845 + 196] == bool(mem[_10845 + 196])
                                if not mem[_10845 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[0] = 10
                            mem[_10845 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_10845 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_10845 + ceil32(return_data.size) + 229] = _10805
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), _10805);
                    idx = idx + 1
                    continue 
    stor1 = 1
}

function sub_e2a06e0b(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    if cd[4] >= tranches.length:
        revert with 0, 'invalid tranche id'
    if stor6:
        revert with 0, 'already active'
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        if ('cd', 36).length != tokenCount:
            revert with 0, 'invalid amountsIn'
        if ('cd', 68).length != tokenCount:
            revert with 0, 'invalid amountsInvest'
        idx = 0
        while idx < tokenCount:
            require idx < ('cd', 36).length
            require idx < tokens.length
            mem[0] = 10
            _2026 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = this.address
            mem[mem[64] + 100] = cd[((32 * idx) + cd[36] + 36)]
            _2049 = mem[64]
            mem[mem[64]] = 100
            mem[64] = mem[64] + 132
            mem[_2049 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_2049 + 36 len 28]
            mem[64] = _2026 + 196
            mem[_2026 + 132] = 32
            mem[_2026 + 164] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(address(tokens[idx].field_0)):
                revert with 0, 'Address: call to non-contract'
            _2129 = mem[_2049]
            s = 0
            while s < _2129:
                mem[s + _2026 + 196] = mem[s + _2049 + 32]
                s = s + 32
                continue 
            if ceil32(_2129) > _2129:
                mem[_2129 + _2026 + 196] = 0
            call address(tokens[idx].field_0).mem[_2026 + 196 len 4] with:
                 gas gas_remaining wei
                args mem[_2026 + 200 len _2129 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[_2026 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2026 + 200] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _2026 + 264] = mem[idx + _2026 + 164]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_2026 + 264]
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require idx < tokens.length
                require idx < ('cd', 36).length
                if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokens.length
                mem[32] = sha3(msg.sender, 12)
                userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                mem[0] = 10
                require idx < ('cd', 36).length
                mem[_2026 + 196] = msg.sender
                mem[_2026 + 228] = address(tokens[idx].field_0)
                mem[_2026 + 260] = cd[((32 * idx) + cd[36] + 36)]
            else:
                mem[64] = _2026 + ceil32(return_data.size) + 197
                mem[_2026 + 196] = return_data.size
                mem[_2026 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2026 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_2026 + ceil32(return_data.size) + 201] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _2026 + ceil32(return_data.size) + 265] = mem[idx + _2026 + 164]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_2026 + ceil32(return_data.size) + 265]
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_2026 + 228] == bool(mem[_2026 + 228])
                    if not mem[_2026 + 228]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                require idx < tokens.length
                require idx < ('cd', 36).length
                if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokens.length
                mem[32] = sha3(msg.sender, 12)
                userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                mem[0] = 10
                require idx < ('cd', 36).length
                mem[_2026 + ceil32(return_data.size) + 197] = msg.sender
                mem[_2026 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                mem[_2026 + ceil32(return_data.size) + 261] = cd[((32 * idx) + cd[36] + 36)]
            emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + cd[36] + 36)]);
            idx = idx + 1
            continue 
        require cd[4] < tranches.length
        idx = 0
        s = 0
        while idx < tokenCount:
            require idx < ('cd', 68).length
            if s + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + cd[((32 * idx) + cd[68] + 36)]
            continue 
        if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
            revert with 0, 'SafeMath: addition overflow'
        if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
            revert with 0, 'not enough quota'
        idx = 0
        t = 0
        while idx < tranches.length:
            mem[0] = 7
            _5964 = sha3(7)
            if tranches[idx].field_0 + t < t:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            t = tranches[idx].field_0 + t
            continue 
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = 10
            if not stor[(4 * stor7.length) + _5964] * tranches.length:
                require idx < ('cd', 68).length
                mem[mem[64]] = msg.sender
                mem[mem[64] + 32] = cd[4]
                mem[mem[64] + 64] = cycle
                mem[mem[64] + 96] = idx
                mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                if cd[((32 * idx) + cd[68] + 36)]:
                    s = 0
                    t = 0
                    while s < tranches.length:
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(s, sha3(cycle, 15))
                        _10533 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                        if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                            revert with 0, 'SafeMath: addition overflow'
                        s = s + 1
                        t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                        continue 
                    if (stor[_10533] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require (stor[_10533] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= 0
                    require idx < tokens.length
                    if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                    if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                    if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
            else:
                if tokens[idx].field_512 * stor[(4 * stor7.length) + _5964] * tranches.length / stor[(4 * stor7.length) + _5964] * tranches.length != tokens[idx].field_512:
                    revert with 0, 'SafeMath: multiplication overflow'
                require idx < ('cd', 68).length
                mem[mem[64]] = msg.sender
                mem[mem[64] + 32] = cd[4]
                mem[mem[64] + 64] = cycle
                mem[mem[64] + 96] = idx
                mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                if cd[((32 * idx) + cd[68] + 36)]:
                    s = 0
                    t = 0
                    while s < tranches.length:
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(s, sha3(cycle, 15))
                        _10531 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                        if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                            revert with 0, 'SafeMath: addition overflow'
                        s = s + 1
                        t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                        continue 
                    if (stor[_10531] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require (stor[_10531] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _5964] * tranches.length / 100000
                    require idx < tokens.length
                    if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                    if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                    if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
            idx = idx + 1
            continue 
        if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
            revert with 0, 'SafeMath: addition overflow'
        tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
        idx = 0
        s = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(cd[4], sha3(msg.sender, 14))
            _10529 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
            if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
            continue 
        require ext_code.size(stakerAddress)
        call stakerAddress.0x15c2fdc9 with:
             gas gas_remaining wei
            args cd[4], msg.sender, stor[_10529] * tokenCount
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        idx = 0
        while idx < tranches.length:
            _11079 = mem[64]
            mem[64] = mem[64] + 128
            mem[_11079] = 0
            mem[_11079 + 32] = 0
            mem[_11079 + 64] = 0
            mem[_11079 + 96] = 0
            mem[0] = 7
            _11102 = mem[64]
            mem[64] = mem[64] + 128
            mem[_11102] = tranches[idx].field_0
            mem[_11102 + 32] = tranches[idx].field_256
            mem[_11102 + 64] = tranches[idx].field_512
            mem[_11102 + 96] = tranches[idx].field_768
            if tranches[idx].field_256 >= tranches[idx].field_0:
                idx = idx + 1
                continue 
            stor1 = 1
        if stor6:
            revert with 0, 'already active'
        idx = 0
        s = 0
        while idx < tranches.length:
            _11351 = mem[64]
            mem[64] = mem[64] + 128
            mem[_11351] = 0
            mem[_11351 + 32] = 0
            mem[_11351 + 64] = 0
            mem[_11351 + 96] = 0
            mem[0] = 7
            _11356 = mem[64]
            mem[64] = mem[64] + 128
            mem[_11356] = tranches[idx].field_0
            mem[_11356 + 32] = tranches[idx].field_256
            mem[_11356 + 64] = tranches[idx].field_512
            mem[_11356 + 96] = tranches[idx].field_768
            _11357 = tranches[idx].field_256
            if tranches[idx].field_256 + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = tranches[idx].field_256 + s
            continue 
        idx = 0
        while idx < tokens.length:
            if not _11357 * tranches.length:
                require idx < tokens.length
                mem[0] = 10
                mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0
                require ext_code.size(address(tokens[idx].field_256))
                call address(tokens[idx].field_256).0xb6b55f25 with:
                     gas gas_remaining wei
                    args 0
            else:
                if tokens[idx].field_512 * _11357 * tranches.length / _11357 * tranches.length != tokens[idx].field_512:
                    revert with 0, 'SafeMath: multiplication overflow'
                require idx < tokens.length
                mem[0] = 10
                mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = tokens[idx].field_512 * _11357 * tranches.length / 100000
                require ext_code.size(address(tokens[idx].field_256))
                call address(tokens[idx].field_256).0xb6b55f25 with:
                     gas gas_remaining wei
                    args (tokens[idx].field_512 * _11357 * tranches.length / 100000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            idx = idx + 1
            continue 
    else:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[448] = 0
        mem[480] = 0
        mem[512] = 0
        mem[544] = 0
        mem[576] = 0
        mem[352] = 448
        mem[608] = 0
        mem[640] = 0
        mem[672] = 0
        mem[704] = 0
        mem[736] = 0
        mem[384] = 608
        mem[768] = 0
        mem[800] = 0
        mem[832] = 0
        mem[864] = 0
        mem[896] = 0
        mem[928] = 0
        mem[960] = 0
        mem[416] = 768
        mem[96] = 0
        require tokenCount <= test266151307()
        mem[992] = tokenCount
        mem[64] = (32 * tokenCount) + 1024
        if not tokenCount:
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _2006 = mem[64]
                mem[64] = mem[64] + 160
                mem[_2006] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_2006 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_2006 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_2006 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_2006 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _2006
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3989 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3989] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3989 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3989 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3989 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3989 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3989 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3989 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3989
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6018 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6018] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6018 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6018 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6018 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6018 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _6018
                        _6020 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6512 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6512
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6512);
                                else:
                                    _6567 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6567
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6567);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6617 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6617
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6617);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6687 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6687
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6687);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8913 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8913] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8913 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8913 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8913 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8913 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8913
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9145 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9145
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9145);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8905 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8905] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8905 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8905 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8905 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8905 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8905
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9139 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9139
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9139);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8897 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8897] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8897 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8897 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8897 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8897 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8897
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9133 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9133
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9133);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8889 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8889] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8889 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8889 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8889 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8889 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8889
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9127 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9127
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9127);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6020 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6610 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6610
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6610);
                                else:
                                    _6685 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6685
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6685);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6717 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6717
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6717);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6777 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6777
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6777);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8849 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8849] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8849 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8849 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8849 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8849 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8849
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9097 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9097
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9097);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8841 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8841] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8841 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8841 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8841 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8841 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8841
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9091 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9091
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9091);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8833 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8833] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8833 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8833 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8833 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8833 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8833
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9085 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9085
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9085);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8825 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8825] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8825 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8825 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8825 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8825 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8825
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9079 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9079
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9079);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _5997 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _5997
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if ('cd', 36).length != tokenCount:
                revert with 0, 'invalid amountsIn'
            if ('cd', 68).length != tokenCount:
                revert with 0, 'invalid amountsInvest'
            idx = 0
            while idx < tokenCount:
                require idx < ('cd', 36).length
                require idx < tokens.length
                mem[0] = 10
                _9078 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = cd[((32 * idx) + cd[36] + 36)]
                _9273 = mem[64]
                mem[mem[64]] = 100
                mem[64] = mem[64] + 132
                mem[_9273 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_9273 + 36 len 28]
                mem[64] = _9078 + 196
                mem[_9078 + 132] = 32
                mem[_9078 + 164] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(tokens[idx].field_0)):
                    revert with 0, 'Address: call to non-contract'
                _9602 = mem[_9273]
                s = 0
                while s < _9602:
                    mem[s + _9078 + 196] = mem[s + _9273 + 32]
                    s = s + 32
                    continue 
                if ceil32(_9602) > _9602:
                    mem[_9602 + _9078 + 196] = 0
                call address(tokens[idx].field_0).mem[_9078 + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[_9078 + 200 len _9602 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_9078 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_9078 + 200] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _9078 + 264] = mem[idx + _9078 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_9078 + 264]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < ('cd', 36).length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    mem[0] = 10
                    require idx < ('cd', 36).length
                    mem[_9078 + 196] = msg.sender
                    mem[_9078 + 228] = address(tokens[idx].field_0)
                    mem[_9078 + 260] = cd[((32 * idx) + cd[36] + 36)]
                else:
                    mem[64] = _9078 + ceil32(return_data.size) + 197
                    mem[_9078 + 196] = return_data.size
                    mem[_9078 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_9078 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_9078 + ceil32(return_data.size) + 201] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _9078 + ceil32(return_data.size) + 265] = mem[idx + _9078 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_9078 + ceil32(return_data.size) + 265]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_9078 + 228] == bool(mem[_9078 + 228])
                        if not mem[_9078 + 228]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < ('cd', 36).length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    mem[0] = 10
                    require idx < ('cd', 36).length
                    mem[_9078 + ceil32(return_data.size) + 197] = msg.sender
                    mem[_9078 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                    mem[_9078 + ceil32(return_data.size) + 261] = cd[((32 * idx) + cd[36] + 36)]
                emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + cd[36] + 36)]);
                idx = idx + 1
                continue 
            require cd[4] < tranches.length
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < ('cd', 68).length
                if s + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + cd[((32 * idx) + cd[68] + 36)]
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
                revert with 0, 'not enough quota'
            idx = 0
            t = 0
            while idx < tranches.length:
                mem[0] = 7
                _11077 = sha3(7)
                if tranches[idx].field_0 + t < t:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = tranches[idx].field_0 + t
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = 10
                if not stor[(4 * stor7.length) + _11077] * tranches.length:
                    require idx < ('cd', 68).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                    if cd[((32 * idx) + cd[68] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11616 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11616] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11616] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= 0
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                else:
                    if tokens[idx].field_512 * stor[(4 * stor7.length) + _11077] * tranches.length / stor[(4 * stor7.length) + _11077] * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < ('cd', 68).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                    if cd[((32 * idx) + cd[68] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11614 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11614] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11614] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _11077] * tranches.length / 100000
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                idx = idx + 1
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                _11612 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
                if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
                continue 
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args cd[4], msg.sender, stor[_11612] * tokenCount
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            idx = 0
            while idx < tranches.length:
                _11821 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11821] = 0
                mem[_11821 + 32] = 0
                mem[_11821 + 64] = 0
                mem[_11821 + 96] = 0
                mem[0] = 7
                _11828 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11828] = tranches[idx].field_0
                mem[_11828 + 32] = tranches[idx].field_256
                mem[_11828 + 64] = tranches[idx].field_512
                mem[_11828 + 96] = tranches[idx].field_768
                if tranches[idx].field_256 >= tranches[idx].field_0:
                    idx = idx + 1
                    continue 
                stor1 = 1
            if stor6:
                revert with 0, 'already active'
            idx = 0
            s = 0
            while idx < tranches.length:
                _11876 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11876] = 0
                mem[_11876 + 32] = 0
                mem[_11876 + 64] = 0
                mem[_11876 + 96] = 0
                mem[0] = 7
                _11880 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11880] = tranches[idx].field_0
                mem[_11880 + 32] = tranches[idx].field_256
                mem[_11880 + 64] = tranches[idx].field_512
                mem[_11880 + 96] = tranches[idx].field_768
                _11881 = tranches[idx].field_256
                if tranches[idx].field_256 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = tranches[idx].field_256 + s
                continue 
            idx = 0
            while idx < tokens.length:
                if not _11881 * tranches.length:
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args 0
                else:
                    if tokens[idx].field_512 * _11881 * tranches.length / _11881 * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = tokens[idx].field_512 * _11881 * tranches.length / 100000
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args (tokens[idx].field_512 * _11881 * tranches.length / 100000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
        else:
            mem[1024 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _2010 = mem[64]
                mem[64] = mem[64] + 160
                mem[_2010] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_2010 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_2010 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_2010 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_2010 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _2010
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3992 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3992] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3992 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3992 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3992 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3992 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3992 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3992 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3992
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _6024 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_6024] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_6024 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_6024 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_6024 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_6024 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _6024
                        _6026 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6534 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6534
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6534);
                                else:
                                    _6587 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6587
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6587);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6653 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6653
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6653);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6705 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6705
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6705);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9043 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9043] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9043 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9043 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9043 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9043 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9043
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9242 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9242
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9242);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9035 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9035] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9035 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9035 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9035 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9035 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9035
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9236 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9236
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9236);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9027 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9027] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9027 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9027 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9027 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9027 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9027
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9230 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9230
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9230);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9019 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9019] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9019 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9019 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9019 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9019 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9019
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9224 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9224
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9224);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _6026 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6646 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6646
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6646);
                                else:
                                    _6703 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6703
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6703);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6739 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6739
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6739);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6799 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6799
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6799);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8979 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8979] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8979 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8979 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8979 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8979 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8979
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9194 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9194
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9194);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8971 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8971] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8971 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8971 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8971 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8971 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8971
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9188 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9188
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9188);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8963 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8963] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8963 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8963 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8963 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8963 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8963
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9182 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9182
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9182);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8955 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8955] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8955 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8955 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8955 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8955 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8955
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9176 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9176
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9176);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _6001 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _6001
                idx = idx + 1
                continue 
            mem[0] = msg.sender
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if ('cd', 36).length != tokenCount:
                revert with 0, 'invalid amountsIn'
            if ('cd', 68).length != tokenCount:
                revert with 0, 'invalid amountsInvest'
            idx = 0
            while idx < tokenCount:
                require idx < ('cd', 36).length
                require idx < tokens.length
                mem[0] = 10
                _9175 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = this.address
                mem[mem[64] + 100] = cd[((32 * idx) + cd[36] + 36)]
                _9291 = mem[64]
                mem[mem[64]] = 100
                mem[64] = mem[64] + 132
                mem[_9291 + 32] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or mem[_9291 + 36 len 28]
                mem[64] = _9175 + 196
                mem[_9175 + 132] = 32
                mem[_9175 + 164] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(address(tokens[idx].field_0)):
                    revert with 0, 'Address: call to non-contract'
                _9651 = mem[_9291]
                s = 0
                while s < _9651:
                    mem[s + _9175 + 196] = mem[s + _9291 + 32]
                    s = s + 32
                    continue 
                if ceil32(_9651) > _9651:
                    mem[_9651 + _9175 + 196] = 0
                call address(tokens[idx].field_0).mem[_9175 + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[_9175 + 200 len _9651 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        mem[_9175 + 196] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_9175 + 200] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _9175 + 264] = mem[idx + _9175 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_9175 + 264]
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < ('cd', 36).length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    mem[0] = 10
                    require idx < ('cd', 36).length
                    mem[_9175 + 196] = msg.sender
                    mem[_9175 + 228] = address(tokens[idx].field_0)
                    mem[_9175 + 260] = cd[((32 * idx) + cd[36] + 36)]
                else:
                    mem[64] = _9175 + ceil32(return_data.size) + 197
                    mem[_9175 + 196] = return_data.size
                    mem[_9175 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_9175 + ceil32(return_data.size) + 197] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[_9175 + ceil32(return_data.size) + 201] = 32
                        idx = 0
                        while idx < 32:
                            mem[idx + _9175 + ceil32(return_data.size) + 265] = mem[idx + _9175 + 164]
                            idx = idx + 32
                            continue 
                        revert with 0, 32, 32, mem[_9175 + ceil32(return_data.size) + 265]
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_9175 + 228] == bool(mem[_9175 + 228])
                        if not mem[_9175 + 228]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    require idx < tokens.length
                    require idx < ('cd', 36).length
                    if userBalances[msg.sender][address(stor10[idx].field_0)] + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[32] = sha3(msg.sender, 12)
                    userBalances[msg.sender][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    mem[0] = 10
                    require idx < ('cd', 36).length
                    mem[_9175 + ceil32(return_data.size) + 197] = msg.sender
                    mem[_9175 + ceil32(return_data.size) + 229] = address(tokens[idx].field_0)
                    mem[_9175 + ceil32(return_data.size) + 261] = cd[((32 * idx) + cd[36] + 36)]
                emit Deposit(msg.sender, address(tokens[idx].field_0), cd[((32 * idx) + cd[36] + 36)]);
                idx = idx + 1
                continue 
            require cd[4] < tranches.length
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < ('cd', 68).length
                if s + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + cd[((32 * idx) + cd[68] + 36)]
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
                revert with 0, 'not enough quota'
            idx = 0
            t = 0
            while idx < tranches.length:
                mem[0] = 7
                _11078 = sha3(7)
                if tranches[idx].field_0 + t < t:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = tranches[idx].field_0 + t
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = 10
                if not stor[(4 * stor7.length) + _11078] * tranches.length:
                    require idx < ('cd', 68).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                    if cd[((32 * idx) + cd[68] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11622 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11622] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11622] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= 0
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                else:
                    if tokens[idx].field_512 * stor[(4 * stor7.length) + _11078] * tranches.length / stor[(4 * stor7.length) + _11078] * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < ('cd', 68).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[68] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[68] + 36)]);
                    if cd[((32 * idx) + cd[68] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11620 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11620] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] < cd[((32 * idx) + cd[68] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11620] * tranches.length) + cd[((32 * idx) + cd[68] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _11078] * tranches.length / 100000
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[68] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                        if cd[((32 * idx) + cd[68] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[68] + 36)]
                idx = idx + 1
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                _11618 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
                if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
                continue 
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args cd[4], msg.sender, stor[_11618] * tokenCount
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            idx = 0
            while idx < tranches.length:
                _11822 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11822] = 0
                mem[_11822 + 32] = 0
                mem[_11822 + 64] = 0
                mem[_11822 + 96] = 0
                mem[0] = 7
                _11832 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11832] = tranches[idx].field_0
                mem[_11832 + 32] = tranches[idx].field_256
                mem[_11832 + 64] = tranches[idx].field_512
                mem[_11832 + 96] = tranches[idx].field_768
                if tranches[idx].field_256 >= tranches[idx].field_0:
                    idx = idx + 1
                    continue 
                stor1 = 1
            if stor6:
                revert with 0, 'already active'
            idx = 0
            s = 0
            while idx < tranches.length:
                _11877 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11877] = 0
                mem[_11877 + 32] = 0
                mem[_11877 + 64] = 0
                mem[_11877 + 96] = 0
                mem[0] = 7
                _11884 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11884] = tranches[idx].field_0
                mem[_11884 + 32] = tranches[idx].field_256
                mem[_11884 + 64] = tranches[idx].field_512
                mem[_11884 + 96] = tranches[idx].field_768
                _11885 = tranches[idx].field_256
                if tranches[idx].field_256 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = tranches[idx].field_256 + s
                continue 
            idx = 0
            while idx < tokens.length:
                if not _11885 * tranches.length:
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args 0
                else:
                    if tokens[idx].field_512 * _11885 * tranches.length / _11885 * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = tokens[idx].field_512 * _11885 * tranches.length / 100000
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args (tokens[idx].field_512 * _11885 * tranches.length / 100000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
    sub_27e79c44 = block.timestamp
    stor6 = 1
    idx = 0
    while idx < tranches.length:
        mem[0] = 7
        mem[mem[64]] = idx
        mem[mem[64] + 32] = cycle
        mem[mem[64] + 64] = tranches[idx].field_256
        emit 0xe9792504: idx, cycle, tranches[idx].field_256
        idx = idx + 1
        continue 
    if (duration / 3) + block.number < block.number:
        revert with 0, 'SafeMath: addition overflow'
    require ext_code.size(stakerAddress)
    call stakerAddress.0x95805dad with:
         gas gas_remaining wei
        args ((duration / 3) + block.number)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function sub_2b3f4cc8(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] == bool(cd[68])
    if cd[4] >= tranches.length:
        revert with 0, 'invalid tranche id'
    if stor6:
        revert with 0, 'already active'
    mem[0] = msg.sender
    mem[32] = 13
    if sub_26d8cc49[address(msg.sender)] == cycle:
        if stor1 == 2:
            revert with 0, 'ReentrancyGuard: reentrant call'
        stor1 = 2
        if ('cd', 36).length != tokenCount:
            revert with 0, 'invalid amountsIn'
        require cd[4] < tranches.length
        mem[0] = 7
        idx = 0
        s = 0
        while idx < tokenCount:
            require idx < ('cd', 36).length
            if s + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + cd[((32 * idx) + cd[36] + 36)]
            continue 
        if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
            revert with 0, 'SafeMath: addition overflow'
        if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
            revert with 0, 'not enough quota'
        idx = 0
        t = 0
        while idx < tranches.length:
            mem[0] = 7
            _3904 = sha3(7)
            if tranches[idx].field_0 + t < t:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            t = tranches[idx].field_0 + t
            continue 
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = 10
            if not stor[(4 * stor7.length) + _3904] * tranches.length:
                require idx < ('cd', 36).length
                mem[mem[64]] = msg.sender
                mem[mem[64] + 32] = cd[4]
                mem[mem[64] + 64] = cycle
                mem[mem[64] + 96] = idx
                mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                if cd[((32 * idx) + cd[36] + 36)]:
                    s = 0
                    t = 0
                    while s < tranches.length:
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(s, sha3(cycle, 15))
                        _8835 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                        if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                            revert with 0, 'SafeMath: addition overflow'
                        s = s + 1
                        t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                        continue 
                    if (stor[_8835] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require (stor[_8835] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= 0
                    require idx < tokens.length
                    if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                    if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
            else:
                if tokens[idx].field_512 * stor[(4 * stor7.length) + _3904] * tranches.length / stor[(4 * stor7.length) + _3904] * tranches.length != tokens[idx].field_512:
                    revert with 0, 'SafeMath: multiplication overflow'
                require idx < ('cd', 36).length
                mem[mem[64]] = msg.sender
                mem[mem[64] + 32] = cd[4]
                mem[mem[64] + 64] = cycle
                mem[mem[64] + 96] = idx
                mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                if cd[((32 * idx) + cd[36] + 36)]:
                    s = 0
                    t = 0
                    while s < tranches.length:
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(s, sha3(cycle, 15))
                        _8833 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                        if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                            revert with 0, 'SafeMath: addition overflow'
                        s = s + 1
                        t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                        continue 
                    if (stor[_8833] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require (stor[_8833] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _3904] * tranches.length / 100000
                    require idx < tokens.length
                    if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require idx < tokens.length
                    userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                    if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                    if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                    sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
            idx = idx + 1
            continue 
        if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
            revert with 0, 'SafeMath: addition overflow'
        tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
        idx = 0
        s = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(cd[4], sha3(msg.sender, 14))
            _8831 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
            if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
            continue 
        mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = cd[4]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = stor[_8831] * tokenCount
        require ext_code.size(stakerAddress)
        call stakerAddress.0x15c2fdc9 with:
             gas gas_remaining wei
            args cd[4], msg.sender, stor[_8831] * tokenCount
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not cd[68]:
            idx = 0
            while idx < tranches.length:
                _10631 = mem[64]
                mem[64] = mem[64] + 128
                mem[_10631] = 0
                mem[_10631 + 32] = 0
                mem[_10631 + 64] = 0
                mem[_10631 + 96] = 0
                mem[0] = 7
                _10640 = mem[64]
                mem[64] = mem[64] + 128
                mem[_10640] = tranches[idx].field_0
                mem[_10640 + 32] = tranches[idx].field_256
                mem[_10640 + 64] = tranches[idx].field_512
                mem[_10640 + 96] = tranches[idx].field_768
                if tranches[idx].field_256 >= tranches[idx].field_0:
                    idx = idx + 1
                    continue 
                stor1 = 1
            if stor6:
                revert with 0, 'already active'
            idx = 0
            s = 0
            while idx < tranches.length:
                _11304 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11304] = 0
                mem[_11304 + 32] = 0
                mem[_11304 + 64] = 0
                mem[_11304 + 96] = 0
                mem[0] = 7
                _11311 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11311] = tranches[idx].field_0
                mem[_11311 + 32] = tranches[idx].field_256
                mem[_11311 + 64] = tranches[idx].field_512
                mem[_11311 + 96] = tranches[idx].field_768
                _11312 = tranches[idx].field_256
                if tranches[idx].field_256 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = tranches[idx].field_256 + s
                continue 
            idx = 0
            while idx < tokens.length:
                if not _11312 * tranches.length:
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args 0
                else:
                    if tokens[idx].field_512 * _11312 * tranches.length / _11312 * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = tokens[idx].field_512 * _11312 * tranches.length / 100000
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args (tokens[idx].field_512 * _11312 * tranches.length / 100000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
        else:
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(msg.sender, 12)
                if userBalances[msg.sender][address(stor10[idx].field_0)]:
                    require idx < tokens.length
                    mem[0] = 10
                    _10647 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = userBalances[msg.sender][address(stor10[idx].field_0)]
                    _10655 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_10655 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_10655 + 36 len 28]
                    mem[64] = _10647 + 164
                    mem[_10647 + 100] = 32
                    mem[_10647 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(tokens[idx].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    _10711 = mem[_10655]
                    s = 0
                    while s < _10711:
                        mem[s + _10647 + 164] = mem[s + _10655 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_10711) > _10711:
                        mem[_10711 + _10647 + 164] = 0
                    call address(tokens[idx].field_0).mem[_10647 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_10647 + 168 len _10711 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_10647 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10647 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _10647 + 232] = mem[idx + _10647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_10647 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                        mem[0] = 10
                        mem[_10647 + 164] = msg.sender
                        mem[_10647 + 196] = address(tokens[idx].field_0)
                        mem[_10647 + 228] = userBalances[msg.sender][address(stor10[idx].field_0)]
                    else:
                        mem[64] = _10647 + ceil32(return_data.size) + 165
                        mem[_10647 + 164] = return_data.size
                        mem[_10647 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_10647 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_10647 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _10647 + ceil32(return_data.size) + 233] = mem[idx + _10647 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_10647 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_10647 + 196] == bool(mem[_10647 + 196])
                            if not mem[_10647 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require idx < tokens.length
                        mem[32] = sha3(msg.sender, 12)
                        userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                        mem[0] = 10
                        mem[_10647 + ceil32(return_data.size) + 165] = msg.sender
                        mem[_10647 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                        mem[_10647 + ceil32(return_data.size) + 229] = userBalances[msg.sender][address(stor10[idx].field_0)]
                    emit Withdraw(msg.sender, address(tokens[idx].field_0), userBalances[msg.sender][address(stor10[idx].field_0)]);
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                _11305 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11305] = 0
                mem[_11305 + 32] = 0
                mem[_11305 + 64] = 0
                mem[_11305 + 96] = 0
                mem[0] = 7
                _11314 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11314] = tranches[idx].field_0
                mem[_11314 + 32] = tranches[idx].field_256
                mem[_11314 + 64] = tranches[idx].field_512
                mem[_11314 + 96] = tranches[idx].field_768
                if tranches[idx].field_256 >= tranches[idx].field_0:
                    idx = idx + 1
                    continue 
                stor1 = 1
            if stor6:
                revert with 0, 'already active'
            idx = 0
            s = 0
            while idx < tranches.length:
                _11983 = mem[64]
                mem[64] = mem[64] + 128
                mem[_11983] = 0
                mem[_11983 + 32] = 0
                mem[_11983 + 64] = 0
                mem[_11983 + 96] = 0
                mem[0] = 7
                _12000 = mem[64]
                mem[64] = mem[64] + 128
                mem[_12000] = tranches[idx].field_0
                mem[_12000 + 32] = tranches[idx].field_256
                mem[_12000 + 64] = tranches[idx].field_512
                mem[_12000 + 96] = tranches[idx].field_768
                _12001 = tranches[idx].field_256
                if tranches[idx].field_256 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = tranches[idx].field_256 + s
                continue 
            idx = 0
            while idx < tokens.length:
                if not _12001 * tranches.length:
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args 0
                else:
                    if tokens[idx].field_512 * _12001 * tranches.length / _12001 * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < tokens.length
                    mem[0] = 10
                    mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = tokens[idx].field_512 * _12001 * tranches.length / 100000
                    require ext_code.size(address(tokens[idx].field_256))
                    call address(tokens[idx].field_256).0xb6b55f25 with:
                         gas gas_remaining wei
                        args (tokens[idx].field_512 * _12001 * tranches.length / 100000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
    else:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[448] = 0
        mem[480] = 0
        mem[512] = 0
        mem[544] = 0
        mem[576] = 0
        mem[352] = 448
        mem[608] = 0
        mem[640] = 0
        mem[672] = 0
        mem[704] = 0
        mem[736] = 0
        mem[384] = 608
        mem[768] = 0
        mem[800] = 0
        mem[832] = 0
        mem[864] = 0
        mem[896] = 0
        mem[928] = 0
        mem[960] = 0
        mem[416] = 768
        mem[96] = 0
        require tokenCount <= test266151307()
        mem[992] = tokenCount
        mem[64] = (32 * tokenCount) + 1024
        if not tokenCount:
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1961 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1961] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1961 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1961 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1961 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1961 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1961
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3900 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3900] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3900 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3900 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3900 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3900 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3900 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3900 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3900
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _5918 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_5918] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_5918 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_5918 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_5918 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_5918 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _5918
                        _5920 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6403 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6403
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6403);
                                else:
                                    _6467 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6467
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6467);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6521 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6521
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6521);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6579 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6579
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6579);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8931 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8931] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8931 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8931 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8931 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8931 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8931
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9164 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9164
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9164);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8923 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8923] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8923 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8923 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8923 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8923 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8923
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9158 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9158
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9158);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8915 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8915] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8915 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8915 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8915 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8915 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8915
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9152 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9152
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9152);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8907 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8907] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8907 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8907 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8907 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8907 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8907
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9146 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9146
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9146);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _5920 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6514 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6514
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6514);
                                else:
                                    _6577 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6577
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6577);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6607 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6607
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6607);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6659 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6659
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6659);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8867 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8867] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8867 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8867 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8867 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8867 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8867
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9116 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9116
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9116);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8859 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8859] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8859 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8859 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8859 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8859 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8859
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9110 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9110
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9110);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8851 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8851] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8851 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8851 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8851 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8851 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8851
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9104 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9104
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9104);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8843 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8843] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8843 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8843 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8843 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8843 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8843
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9098 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9098
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9098);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _5896 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _5896
                idx = idx + 1
                continue 
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if ('cd', 36).length != tokenCount:
                revert with 0, 'invalid amountsIn'
            require cd[4] < tranches.length
            mem[0] = 7
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < ('cd', 36).length
                if s + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + cd[((32 * idx) + cd[36] + 36)]
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
                revert with 0, 'not enough quota'
            idx = 0
            t = 0
            while idx < tranches.length:
                mem[0] = 7
                _10629 = sha3(7)
                if tranches[idx].field_0 + t < t:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = tranches[idx].field_0 + t
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = 10
                if not stor[(4 * stor7.length) + _10629] * tranches.length:
                    require idx < ('cd', 36).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                    if cd[((32 * idx) + cd[36] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11975 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11975] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11975] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= 0
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                else:
                    if tokens[idx].field_512 * stor[(4 * stor7.length) + _10629] * tranches.length / stor[(4 * stor7.length) + _10629] * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < ('cd', 36).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                    if cd[((32 * idx) + cd[36] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11973 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11973] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11973] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _10629] * tranches.length / 100000
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                idx = idx + 1
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                _11971 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
                if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
                continue 
            mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = cd[4]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = stor[_11971] * tokenCount
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args cd[4], msg.sender, stor[_11971] * tokenCount
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not cd[68]:
                idx = 0
                while idx < tranches.length:
                    _12490 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12490] = 0
                    mem[_12490 + 32] = 0
                    mem[_12490 + 64] = 0
                    mem[_12490 + 96] = 0
                    mem[0] = 7
                    _12502 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12502] = tranches[idx].field_0
                    mem[_12502 + 32] = tranches[idx].field_256
                    mem[_12502 + 64] = tranches[idx].field_512
                    mem[_12502 + 96] = tranches[idx].field_768
                    if tranches[idx].field_256 >= tranches[idx].field_0:
                        idx = idx + 1
                        continue 
                    stor1 = 1
                if stor6:
                    revert with 0, 'already active'
                idx = 0
                s = 0
                while idx < tranches.length:
                    _12839 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12839] = 0
                    mem[_12839 + 32] = 0
                    mem[_12839 + 64] = 0
                    mem[_12839 + 96] = 0
                    mem[0] = 7
                    _12849 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12849] = tranches[idx].field_0
                    mem[_12849 + 32] = tranches[idx].field_256
                    mem[_12849 + 64] = tranches[idx].field_512
                    mem[_12849 + 96] = tranches[idx].field_768
                    _12850 = tranches[idx].field_256
                    if tranches[idx].field_256 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = tranches[idx].field_256 + s
                    continue 
                idx = 0
                while idx < tokens.length:
                    if not _12850 * tranches.length:
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args 0
                    else:
                        if tokens[idx].field_512 * _12850 * tranches.length / _12850 * tranches.length != tokens[idx].field_512:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = tokens[idx].field_512 * _12850 * tranches.length / 100000
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args (tokens[idx].field_512 * _12850 * tranches.length / 100000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    idx = idx + 1
                    continue 
            else:
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(msg.sender, 12)
                    if userBalances[msg.sender][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        mem[0] = 10
                        _12515 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        _12525 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12525 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12525 + 36 len 28]
                        mem[64] = _12515 + 164
                        mem[_12515 + 100] = 32
                        mem[_12515 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _12599 = mem[_12525]
                        s = 0
                        while s < _12599:
                            mem[s + _12515 + 164] = mem[s + _12525 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_12599) > _12599:
                            mem[_12599 + _12515 + 164] = 0
                        call address(tokens[idx].field_0).mem[_12515 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_12515 + 168 len _12599 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_12515 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_12515 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _12515 + 232] = mem[idx + _12515 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_12515 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[32] = sha3(msg.sender, 12)
                            userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                            mem[0] = 10
                            mem[_12515 + 164] = msg.sender
                            mem[_12515 + 196] = address(tokens[idx].field_0)
                            mem[_12515 + 228] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        else:
                            mem[64] = _12515 + ceil32(return_data.size) + 165
                            mem[_12515 + 164] = return_data.size
                            mem[_12515 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_12515 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_12515 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _12515 + ceil32(return_data.size) + 233] = mem[idx + _12515 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_12515 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_12515 + 196] == bool(mem[_12515 + 196])
                                if not mem[_12515 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[32] = sha3(msg.sender, 12)
                            userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                            mem[0] = 10
                            mem[_12515 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_12515 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_12515 + ceil32(return_data.size) + 229] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), userBalances[msg.sender][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < tranches.length:
                    _12840 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12840] = 0
                    mem[_12840 + 32] = 0
                    mem[_12840 + 64] = 0
                    mem[_12840 + 96] = 0
                    mem[0] = 7
                    _12852 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12852] = tranches[idx].field_0
                    mem[_12852 + 32] = tranches[idx].field_256
                    mem[_12852 + 64] = tranches[idx].field_512
                    mem[_12852 + 96] = tranches[idx].field_768
                    if tranches[idx].field_256 >= tranches[idx].field_0:
                        idx = idx + 1
                        continue 
                    stor1 = 1
                if stor6:
                    revert with 0, 'already active'
                idx = 0
                s = 0
                while idx < tranches.length:
                    _13147 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_13147] = 0
                    mem[_13147 + 32] = 0
                    mem[_13147 + 64] = 0
                    mem[_13147 + 96] = 0
                    mem[0] = 7
                    _13154 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_13154] = tranches[idx].field_0
                    mem[_13154 + 32] = tranches[idx].field_256
                    mem[_13154 + 64] = tranches[idx].field_512
                    mem[_13154 + 96] = tranches[idx].field_768
                    _13155 = tranches[idx].field_256
                    if tranches[idx].field_256 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = tranches[idx].field_256 + s
                    continue 
                idx = 0
                while idx < tokens.length:
                    if not _13155 * tranches.length:
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args 0
                    else:
                        if tokens[idx].field_512 * _13155 * tranches.length / _13155 * tranches.length != tokens[idx].field_512:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = tokens[idx].field_512 * _13155 * tranches.length / 100000
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args (tokens[idx].field_512 * _13155 * tranches.length / 100000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    idx = idx + 1
                    continue 
        else:
            mem[1024 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[320] = 992
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                _1965 = mem[64]
                mem[64] = mem[64] + 160
                mem[_1965] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_0
                mem[_1965 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_256
                mem[_1965 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512
                mem[_1965 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_768
                mem[_1965 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024))
                mem[352] = _1965
                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96] < mem[96]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[idx].field_0)].field_512 + mem[96]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 16)
                _3903 = mem[64]
                mem[64] = mem[64] + 224
                mem[_3903] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_0
                mem[_3903 + 32] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_256
                mem[_3903 + 64] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_512
                mem[_3903 + 96] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_768
                mem[_3903 + 128] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1024
                mem[_3903 + 160] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1280
                mem[_3903 + 192] = sub_ae4f9c74[stor13[address(msg.sender)]][idx].field_1536
                mem[416] = _3903
                mem[128] = 0
                mem[160] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                    mem[256] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160] < mem[160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[160] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[160]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                        _5924 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_5924] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_0
                        mem[_5924 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                        mem[_5924 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512
                        mem[_5924 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_768
                        mem[_5924 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024))
                        mem[352] = _5924
                        _5926 = mem[mem[416] + 64]
                        if not sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                            mem[192] = 0
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                mem[224] = 0
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6429 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6429
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6429);
                                else:
                                    _6493 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6493
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6493);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6549 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6549
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6549);
                                else:
                                    if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6595 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6595
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6595);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9060 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9060] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9060 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9060 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9060 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9060 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9060
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9261 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9261
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9261);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9052 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9052] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9052 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9052 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9052 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9052 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9052
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9255 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9255
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9255);
                                        else:
                                            if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (-1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9044 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9044] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9044 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9044 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9044 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9044 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9044
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9249 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9249
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9249);
                                            else:
                                                if -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = -1 * sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _9036 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_9036] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_9036 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_9036 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_9036 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_9036 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _9036
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9243 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9243
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9243);
                        else:
                            if mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] != mem[mem[416] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[192] = mem[mem[416] + 64] * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > _5926 * sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[224] = 0
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[320]]
                                mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                require s < tokens.length
                                mem[0] = address(tokens[s].field_0)
                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    _6542 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6542
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6542);
                                else:
                                    _6593 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6593
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6593);
                            else:
                                if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] > mem[192]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[224] = mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]
                                if mem[192] + mem[128] < mem[128]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[128] = mem[192] + mem[128]
                                require s < mem[mem[320]]
                                if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_1024):
                                    if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[320]]
                                    mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                    require s < tokens.length
                                    mem[0] = address(tokens[s].field_0)
                                    mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                    sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                    require s < mem[mem[320]]
                                    _6631 = mem[(32 * s) + mem[320] + 32]
                                    mem[mem[64]] = msg.sender
                                    mem[mem[64] + 32] = idx
                                    mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                    mem[mem[64] + 96] = s
                                    mem[mem[64] + 128] = _6631
                                    emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6631);
                                else:
                                    if not mem[192] - sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)]:
                                        if mem[192] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = mem[192] + mem[(32 * s) + mem[320] + 32]
                                        require s < tokens.length
                                        mem[0] = address(tokens[s].field_0)
                                        mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                        sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                        require s < mem[mem[320]]
                                        _6670 = mem[(32 * s) + mem[320] + 32]
                                        mem[mem[64]] = msg.sender
                                        mem[mem[64] + 32] = idx
                                        mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                        mem[mem[64] + 96] = s
                                        mem[mem[64] + 128] = _6670
                                        emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _6670);
                                    else:
                                        if sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[320]]
                                        mem[(32 * s) + mem[320] + 32] = sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[320] + 32]
                                        if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[224]:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8996 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8996] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8996 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8996 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8996 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8996 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8996
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9213 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9213
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9213);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8988 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8988] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8988 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8988 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8988 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8988 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8988
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9207 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9207
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9207);
                                        else:
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[320]]
                                            if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32] < mem[(32 * s) + mem[320] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[320]]
                                            mem[(32 * s) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[320] + 32]
                                            if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[224]:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = 0 / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8980 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8980] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8980 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8980 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8980 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8980 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8980
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9201 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9201
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9201);
                                            else:
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / mem[224] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                mem[288] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 * mem[224] / sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(msg.sender)]][address(stor10[s].field_0)].field_256
                                                t = 0
                                                while t < tokenCount:
                                                    if s != t:
                                                        require t < tokens.length
                                                        mem[0] = address(tokens[t].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(msg.sender)], 17)
                                                        _8972 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_8972] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_0
                                                        mem[_8972 + 32] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_256
                                                        mem[_8972 + 64] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512
                                                        mem[_8972 + 96] = sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_768
                                                        mem[_8972 + 128] = bool(uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024))
                                                        mem[384] = _8972
                                                        if uint8(sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_1024):
                                                            if not mem[288]:
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (0 / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (0 / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[288] != sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[96] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[96]
                                                                require t < mem[mem[320]]
                                                                if (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32] < mem[(32 * t) + mem[320] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require t < mem[mem[320]]
                                                                mem[(32 * t) + mem[320] + 32] = (sub_8365b232[stor13[address(msg.sender)]][address(stor10[t].field_0)].field_512 * mem[288] / mem[96]) + mem[(32 * t) + mem[320] + 32]
                                                    t = t + 1
                                                    continue 
                                                require s < tokens.length
                                                mem[0] = address(tokens[s].field_0)
                                                mem[32] = sha3(idx, sha3(address(msg.sender), 14))
                                                sub_6aad5e20[address(msg.sender)][idx][address(stor10[s].field_0)] = 0
                                                require s < mem[mem[320]]
                                                _9195 = mem[(32 * s) + mem[320] + 32]
                                                mem[mem[64]] = msg.sender
                                                mem[mem[64] + 32] = idx
                                                mem[mem[64] + 64] = sub_26d8cc49[address(msg.sender)]
                                                mem[mem[64] + 96] = s
                                                mem[mem[64] + 128] = _9195
                                                emit Harvest(msg.sender, idx, sub_26d8cc49[address(msg.sender)], s, _9195);
                    s = s + 1
                    continue 
                if mem[160]:
                    mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = idx
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = 0
                    require ext_code.size(stakerAddress)
                    call stakerAddress.0x15c2fdc9 with:
                         gas gas_remaining wei
                        args idx, msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[320]]
                if mem[(32 * idx) + mem[320] + 32] > 0:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    require idx < mem[mem[320]]
                    _5899 = mem[(32 * idx) + mem[320] + 32]
                    if userBalances[address(msg.sender)][address(stor10[idx].field_0)] + mem[(32 * idx) + mem[320] + 32] < mem[(32 * idx) + mem[320] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(address(msg.sender), 12)
                    userBalances[address(msg.sender)][address(stor10[idx].field_0)] += _5899
                idx = idx + 1
                continue 
            mem[32] = 13
            sub_26d8cc49[address(msg.sender)] = cycle
            if stor1 == 2:
                revert with 0, 'ReentrancyGuard: reentrant call'
            stor1 = 2
            if ('cd', 36).length != tokenCount:
                revert with 0, 'invalid amountsIn'
            require cd[4] < tranches.length
            mem[0] = 7
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < ('cd', 36).length
                if s + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + cd[((32 * idx) + cd[36] + 36)]
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            if tranches[cd[4]].field_0 < (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256:
                revert with 0, 'not enough quota'
            idx = 0
            t = 0
            while idx < tranches.length:
                mem[0] = 7
                _10630 = sha3(7)
                if tranches[idx].field_0 + t < t:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = tranches[idx].field_0 + t
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = 10
                if not stor[(4 * stor7.length) + _10630] * tranches.length:
                    require idx < ('cd', 36).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                    if cd[((32 * idx) + cd[36] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11981 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11981] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11981] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= 0
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                else:
                    if tokens[idx].field_512 * stor[(4 * stor7.length) + _10630] * tranches.length / stor[(4 * stor7.length) + _10630] * tranches.length != tokens[idx].field_512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require idx < ('cd', 36).length
                    mem[mem[64]] = msg.sender
                    mem[mem[64] + 32] = cd[4]
                    mem[mem[64] + 64] = cycle
                    mem[mem[64] + 96] = idx
                    mem[mem[64] + 128] = cd[((32 * idx) + cd[36] + 36)]
                    emit Invest(msg.sender, cd[4], cycle, idx, cd[((32 * idx) + cd[36] + 36)]);
                    if cd[((32 * idx) + cd[36] + 36)]:
                        s = 0
                        t = 0
                        while s < tranches.length:
                            require idx < tokens.length
                            mem[0] = address(tokens[idx].field_0)
                            mem[32] = sha3(s, sha3(cycle, 15))
                            _11979 = sha3(address(tokens[idx].field_0), sha3(s, sha3(cycle, 15)))
                            if sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t < t:
                                revert with 0, 'SafeMath: addition overflow'
                            s = s + 1
                            t = sub_c8ae97c1[stor4][s][address(stor10[idx].field_0)] + t
                            continue 
                        if (stor[_11979] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] < cd[((32 * idx) + cd[36] + 36)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require (stor[_11979] * tranches.length) + cd[((32 * idx) + cd[36] + 36)] <= tokens[idx].field_512 * stor[(4 * stor7.length) + _10630] * tranches.length / 100000
                        require idx < tokens.length
                        if cd[((32 * idx) + cd[36] + 36)] > userBalances[msg.sender][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require idx < tokens.length
                        userBalances[msg.sender][address(stor10[idx].field_0)] -= cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] < sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        sub_c8ae97c1[stor4][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                        if cd[((32 * idx) + cd[36] + 36)] + sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] < sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < tokens.length
                        mem[0] = address(tokens[idx].field_0)
                        mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                        sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] += cd[((32 * idx) + cd[36] + 36)]
                idx = idx + 1
                continue 
            if (s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount) + tranches[cd[4]].field_256 < tranches[cd[4]].field_256:
                revert with 0, 'SafeMath: addition overflow'
            tranches[cd[4]].field_256 += s * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount * tokenCount
            idx = 0
            s = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(cd[4], sha3(msg.sender, 14))
                _11977 = sha3(address(tokens[idx].field_0), sha3(cd[4], sha3(msg.sender, 14)))
                if sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = sub_6aad5e20[msg.sender][cd[4]][address(stor10[idx].field_0)] + s
                continue 
            mem[mem[64]] = 0x15c2fdc900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = cd[4]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = stor[_11977] * tokenCount
            require ext_code.size(stakerAddress)
            call stakerAddress.0x15c2fdc9 with:
                 gas gas_remaining wei
                args cd[4], msg.sender, stor[_11977] * tokenCount
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not cd[68]:
                idx = 0
                while idx < tranches.length:
                    _12493 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12493] = 0
                    mem[_12493 + 32] = 0
                    mem[_12493 + 64] = 0
                    mem[_12493 + 96] = 0
                    mem[0] = 7
                    _12507 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12507] = tranches[idx].field_0
                    mem[_12507 + 32] = tranches[idx].field_256
                    mem[_12507 + 64] = tranches[idx].field_512
                    mem[_12507 + 96] = tranches[idx].field_768
                    if tranches[idx].field_256 >= tranches[idx].field_0:
                        idx = idx + 1
                        continue 
                    stor1 = 1
                if stor6:
                    revert with 0, 'already active'
                idx = 0
                s = 0
                while idx < tranches.length:
                    _12841 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12841] = 0
                    mem[_12841 + 32] = 0
                    mem[_12841 + 64] = 0
                    mem[_12841 + 96] = 0
                    mem[0] = 7
                    _12859 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12859] = tranches[idx].field_0
                    mem[_12859 + 32] = tranches[idx].field_256
                    mem[_12859 + 64] = tranches[idx].field_512
                    mem[_12859 + 96] = tranches[idx].field_768
                    _12860 = tranches[idx].field_256
                    if tranches[idx].field_256 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = tranches[idx].field_256 + s
                    continue 
                idx = 0
                while idx < tokens.length:
                    if not _12860 * tranches.length:
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args 0
                    else:
                        if tokens[idx].field_512 * _12860 * tranches.length / _12860 * tranches.length != tokens[idx].field_512:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = tokens[idx].field_512 * _12860 * tranches.length / 100000
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args (tokens[idx].field_512 * _12860 * tranches.length / 100000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    idx = idx + 1
                    continue 
            else:
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(msg.sender, 12)
                    if userBalances[msg.sender][address(stor10[idx].field_0)]:
                        require idx < tokens.length
                        mem[0] = 10
                        _12517 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        _12528 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12528 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_12528 + 36 len 28]
                        mem[64] = _12517 + 164
                        mem[_12517 + 100] = 32
                        mem[_12517 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(address(tokens[idx].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        _12601 = mem[_12528]
                        s = 0
                        while s < _12601:
                            mem[s + _12517 + 164] = mem[s + _12528 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_12601) > _12601:
                            mem[_12601 + _12517 + 164] = 0
                        call address(tokens[idx].field_0).mem[_12517 + 164 len 4] with:
                             gas gas_remaining wei
                            args mem[_12517 + 168 len _12601 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                mem[_12517 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_12517 + 168] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _12517 + 232] = mem[idx + _12517 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_12517 + 232]
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[32] = sha3(msg.sender, 12)
                            userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                            mem[0] = 10
                            mem[_12517 + 164] = msg.sender
                            mem[_12517 + 196] = address(tokens[idx].field_0)
                            mem[_12517 + 228] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        else:
                            mem[64] = _12517 + ceil32(return_data.size) + 165
                            mem[_12517 + 164] = return_data.size
                            mem[_12517 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_12517 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[_12517 + ceil32(return_data.size) + 169] = 32
                                idx = 0
                                while idx < 32:
                                    mem[idx + _12517 + ceil32(return_data.size) + 233] = mem[idx + _12517 + 132]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 32, 32, mem[_12517 + ceil32(return_data.size) + 233]
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_12517 + 196] == bool(mem[_12517 + 196])
                                if not mem[_12517 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < tokens.length
                            mem[32] = sha3(msg.sender, 12)
                            userBalances[msg.sender][address(stor10[idx].field_0)] = 0
                            mem[0] = 10
                            mem[_12517 + ceil32(return_data.size) + 165] = msg.sender
                            mem[_12517 + ceil32(return_data.size) + 197] = address(tokens[idx].field_0)
                            mem[_12517 + ceil32(return_data.size) + 229] = userBalances[msg.sender][address(stor10[idx].field_0)]
                        emit Withdraw(msg.sender, address(tokens[idx].field_0), userBalances[msg.sender][address(stor10[idx].field_0)]);
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < tranches.length:
                    _12842 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12842] = 0
                    mem[_12842 + 32] = 0
                    mem[_12842 + 64] = 0
                    mem[_12842 + 96] = 0
                    mem[0] = 7
                    _12862 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_12862] = tranches[idx].field_0
                    mem[_12862 + 32] = tranches[idx].field_256
                    mem[_12862 + 64] = tranches[idx].field_512
                    mem[_12862 + 96] = tranches[idx].field_768
                    if tranches[idx].field_256 >= tranches[idx].field_0:
                        idx = idx + 1
                        continue 
                    stor1 = 1
                if stor6:
                    revert with 0, 'already active'
                idx = 0
                s = 0
                while idx < tranches.length:
                    _13149 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_13149] = 0
                    mem[_13149 + 32] = 0
                    mem[_13149 + 64] = 0
                    mem[_13149 + 96] = 0
                    mem[0] = 7
                    _13168 = mem[64]
                    mem[64] = mem[64] + 128
                    mem[_13168] = tranches[idx].field_0
                    mem[_13168 + 32] = tranches[idx].field_256
                    mem[_13168 + 64] = tranches[idx].field_512
                    mem[_13168 + 96] = tranches[idx].field_768
                    _13169 = tranches[idx].field_256
                    if tranches[idx].field_256 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = tranches[idx].field_256 + s
                    continue 
                idx = 0
                while idx < tokens.length:
                    if not _13169 * tranches.length:
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args 0
                    else:
                        if tokens[idx].field_512 * _13169 * tranches.length / _13169 * tranches.length != tokens[idx].field_512:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require idx < tokens.length
                        mem[0] = 10
                        mem[mem[64]] = 0xb6b55f2500000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = tokens[idx].field_512 * _13169 * tranches.length / 100000
                        require ext_code.size(address(tokens[idx].field_256))
                        call address(tokens[idx].field_256).0xb6b55f25 with:
                             gas gas_remaining wei
                            args (tokens[idx].field_512 * _13169 * tranches.length / 100000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    idx = idx + 1
                    continue 
    sub_27e79c44 = block.timestamp
    stor6 = 1
    idx = 0
    while idx < tranches.length:
        mem[0] = 7
        mem[mem[64]] = idx
        mem[mem[64] + 32] = cycle
        mem[mem[64] + 64] = tranches[idx].field_256
        emit 0xe9792504: idx, cycle, tranches[idx].field_256
        idx = idx + 1
        continue 
    if (duration / 3) + block.number < block.number:
        revert with 0, 'SafeMath: addition overflow'
    require ext_code.size(stakerAddress)
    call stakerAddress.0x95805dad with:
         gas gas_remaining wei
        args ((duration / 3) + block.number)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require tokenCount <= test266151307()
    mem[96] = tokenCount
    if not tokenCount:
        require tokenCount <= test266151307()
        mem[(32 * tokenCount) + 128] = tokenCount
        if not tokenCount:
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(address(arg1), 12)
                require idx < tokenCount
                if userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128] < mem[(32 * idx) + 128]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < tokenCount
                mem[(32 * idx) + 128] = userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128]
                idx = idx + 1
                continue 
            mem[(64 * tokenCount) + 160] = 0
            mem[(64 * tokenCount) + 192] = 0
            mem[(64 * tokenCount) + 224] = 0
            mem[(64 * tokenCount) + 256] = 0
            mem[(64 * tokenCount) + 288] = 0
            mem[(64 * tokenCount) + 320] = 0
            mem[(64 * tokenCount) + 352] = 0
            mem[(64 * tokenCount) + 384] = 96
            mem[(64 * tokenCount) + 512] = 0
            mem[(64 * tokenCount) + 544] = 0
            mem[(64 * tokenCount) + 576] = 0
            mem[(64 * tokenCount) + 608] = 0
            mem[(64 * tokenCount) + 640] = 0
            mem[(64 * tokenCount) + 416] = (64 * tokenCount) + 512
            mem[(64 * tokenCount) + 672] = 0
            mem[(64 * tokenCount) + 704] = 0
            mem[(64 * tokenCount) + 736] = 0
            mem[(64 * tokenCount) + 768] = 0
            mem[(64 * tokenCount) + 800] = 0
            mem[(64 * tokenCount) + 448] = (64 * tokenCount) + 672
            mem[(64 * tokenCount) + 832] = 0
            mem[(64 * tokenCount) + 864] = 0
            mem[(64 * tokenCount) + 896] = 0
            mem[(64 * tokenCount) + 928] = 0
            mem[(64 * tokenCount) + 960] = 0
            mem[(64 * tokenCount) + 992] = 0
            mem[(64 * tokenCount) + 1024] = 0
            mem[(64 * tokenCount) + 480] = (64 * tokenCount) + 832
            mem[0] = arg1
            mem[32] = 13
            if sub_26d8cc49[address(arg1)] == cycle:
                idx = 0
                while idx < tokenCount:
                    mem[(64 * tokenCount) + 224] = 0
                    s = 0
                    while s < tranches.length:
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(s, sha3(address(arg1), 14))
                        if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)]:
                            if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                        s = s + 1
                        continue 
                    if mem[(64 * tokenCount) + 224]:
                        require s < mem[(32 * tokenCount) + 128]
                        if mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160] < mem[(32 * s) + (32 * tokenCount) + 160]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[(32 * tokenCount) + 128]
                        mem[(32 * s) + (32 * tokenCount) + 160] = mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160]
                    s = s + 1
                    continue 
                mem[(64 * tokenCount) + 1056] = 64
                mem[(64 * tokenCount) + 1120] = tokenCount
                mem[(64 * tokenCount) + 1152 len 32 * tokenCount] = mem[128 len 32 * tokenCount]
                var34001 = tokenCount
                mem[(64 * tokenCount) + 1088] = (32 * tokenCount) + 96
                mem[(98 * tokenCount) + 1152] = mem[(32 * tokenCount) + 128]
                mem[(98 * tokenCount) + 1184 len 32 * mem[(32 * tokenCount) + 128]] = mem[(32 * tokenCount) + 160 len 32 * mem[(32 * tokenCount) + 128]]
                var39001 = mem[(32 * tokenCount) + 128]
                return memory
                  from (64 * tokenCount) + 1056
                   len (32 * tokenCount) + (32 * mem[(32 * tokenCount) + 128]) + 128
            mem[(64 * tokenCount) + 160] = 0
            require tokenCount <= test266151307()
            mem[(64 * tokenCount) + 1056] = tokenCount
            mem[64] = (98 * tokenCount) + 1088
            if not tokenCount:
                mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
                idx = 0
                while idx < tokenCount:
                    require idx < tokens.length
                    mem[0] = address(tokens[idx].field_0)
                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                    _6958 = mem[64]
                    mem[64] = mem[64] + 160
                    mem[_6958] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                    mem[_6958 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                    mem[_6958 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                    mem[_6958 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                    mem[_6958 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                    mem[(64 * tokenCount) + 416] = _6958
                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < tranches.length:
                    mem[0] = idx
                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
                    _10366 = mem[64]
                    mem[64] = mem[64] + 224
                    mem[_10366] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
                    mem[_10366 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
                    mem[_10366 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
                    mem[_10366 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
                    mem[_10366 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
                    mem[_10366 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
                    mem[_10366 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
                    mem[(64 * tokenCount) + 480] = _10366
                    mem[(64 * tokenCount) + 192] = 0
                    mem[(64 * tokenCount) + 224] = 0
                    s = 0
                    while s < tokenCount:
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(idx, sha3(address(arg1), 14))
                        mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                            require s < tokens.length
                            mem[0] = address(tokens[s].field_0)
                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                            _13870 = mem[64]
                            mem[64] = mem[64] + 160
                            mem[_13870] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                            mem[_13870 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[_13870 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                            mem[_13870 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                            mem[_13870 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                            mem[(64 * tokenCount) + 416] = _13870
                            _13872 = mem[mem[(64 * tokenCount) + 480] + 64]
                            if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                mem[(64 * tokenCount) + 256] = 0
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                    mem[(64 * tokenCount) + 288] = 0
                                    if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    s = s + 1
                                    continue 
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                                if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    s = s + 1
                                    continue 
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    s = s + 1
                                    continue 
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _20827 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_20827] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_20827 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_20827 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_20827 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_20827 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _20827
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _20823 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_20823] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_20823 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_20823 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_20823 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_20823 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _20823
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _20819 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_20819] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_20819 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_20819 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_20819 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_20819 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _20819
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _20815 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_20815] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_20815 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_20815 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_20815 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_20815 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _20815
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                            else:
                                if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13872 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                                    mem[(64 * tokenCount) + 288] = 0
                                    if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                                    if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                        if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    else:
                                        if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                            if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        else:
                                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                require s < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[(64 * tokenCount) + 288]:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    idx = 0
                                                    while idx < tokenCount:
                                                        if s != idx:
                                                            require idx < tokens.length
                                                            mem[0] = address(tokens[idx].field_0)
                                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                            _20795 = mem[64]
                                                            mem[64] = mem[64] + 160
                                                            mem[_20795] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                            mem[_20795 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                            mem[_20795 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                            mem[_20795 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                            mem[_20795 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                            mem[(64 * tokenCount) + 448] = _20795
                                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                                if not mem[(64 * tokenCount) + 352]:
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                                else:
                                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    idx = 0
                                                    while idx < tokenCount:
                                                        if s != idx:
                                                            require idx < tokens.length
                                                            mem[0] = address(tokens[idx].field_0)
                                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                            _20791 = mem[64]
                                                            mem[64] = mem[64] + 160
                                                            mem[_20791] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                            mem[_20791 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                            mem[_20791 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                            mem[_20791 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                            mem[_20791 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                            mem[(64 * tokenCount) + 448] = _20791
                                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                                if not mem[(64 * tokenCount) + 352]:
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                                else:
                                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        idx = idx + 1
                                                        continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                require s < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require s < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[(64 * tokenCount) + 288]:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    idx = 0
                                                    while idx < tokenCount:
                                                        if s != idx:
                                                            require idx < tokens.length
                                                            mem[0] = address(tokens[idx].field_0)
                                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                            _20787 = mem[64]
                                                            mem[64] = mem[64] + 160
                                                            mem[_20787] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                            mem[_20787 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                            mem[_20787 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                            mem[_20787 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                            mem[_20787 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                            mem[(64 * tokenCount) + 448] = _20787
                                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                                if not mem[(64 * tokenCount) + 352]:
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                                else:
                                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        idx = idx + 1
                                                        continue 
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                    idx = 0
                                                    while idx < tokenCount:
                                                        if s != idx:
                                                            require idx < tokens.length
                                                            mem[0] = address(tokens[idx].field_0)
                                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                            _20783 = mem[64]
                                                            mem[64] = mem[64] + 160
                                                            mem[_20783] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                            mem[_20783 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                            mem[_20783 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                            mem[_20783 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                            mem[_20783 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                            mem[(64 * tokenCount) + 448] = _20783
                                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                                if not mem[(64 * tokenCount) + 352]:
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                                else:
                                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require mem[(64 * tokenCount) + 160]
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        idx = idx + 1
                                                        continue 
                        s = s + 1
                        continue 
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < tokenCount:
                    require idx < mem[mem[(64 * tokenCount) + 384]]
                    if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                        require idx < mem[96]
                        require idx < mem[mem[(64 * tokenCount) + 384]]
                        if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                    idx = idx + 1
                    continue 
                _13752 = mem[64]
                mem[mem[64]] = 64
                _13812 = mem[96]
                mem[mem[64] + 64] = mem[96]
                mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                mem[mem[64] + 32] = (32 * mem[96]) + 96
                _20780 = mem[(32 * tokenCount) + 128]
                mem[_13752 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
                mem[_13752 + (32 * _13812) + 128 len 32 * _20780] = mem[(32 * tokenCount) + 160 len 32 * _20780]
                return memory
                  from mem[64]
                   len _13752 + (32 * _13812) + (32 * _20780) + -mem[64] + 128
            mem[(64 * tokenCount) + 1088 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
            mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                _6962 = mem[64]
                mem[64] = mem[64] + 160
                mem[_6962] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                mem[_6962 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                mem[_6962 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                mem[_6962 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                mem[_6962 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                mem[(64 * tokenCount) + 416] = _6962
                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
                _10369 = mem[64]
                mem[64] = mem[64] + 224
                mem[_10369] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
                mem[_10369 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
                mem[_10369 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
                mem[_10369 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
                mem[_10369 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
                mem[_10369 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
                mem[_10369 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
                mem[(64 * tokenCount) + 480] = _10369
                mem[(64 * tokenCount) + 192] = 0
                mem[(64 * tokenCount) + 224] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(arg1), 14))
                    mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                        _13876 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_13876] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                        mem[_13876 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        mem[_13876 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                        mem[_13876 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                        mem[_13876 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                        mem[(64 * tokenCount) + 416] = _13876
                        _13878 = mem[mem[(64 * tokenCount) + 480] + 64]
                        if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            mem[(64 * tokenCount) + 256] = 0
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20892 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20892] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20892 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20892 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20892 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20892 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20892
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20888 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20888] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20888 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20888 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20888 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20888 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20888
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20884 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20884] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20884 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20884 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20884 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20884 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20884
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20880 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20880] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20880 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20880 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20880 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20880 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20880
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                        else:
                            if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13878 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                        if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    else:
                                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20860 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20860] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20860 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20860 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20860 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20860 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20860
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20856 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20856] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20856 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20856 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20856 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20856 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20856
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20852 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20852] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20852 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20852 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20852 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20852 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20852
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20848 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20848] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20848 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20848 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20848 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20848 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20848
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                    s = s + 1
                    continue 
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                    require idx < mem[96]
                    require idx < mem[mem[(64 * tokenCount) + 384]]
                    if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                idx = idx + 1
                continue 
            _13756 = mem[64]
            mem[mem[64]] = 64
            _13815 = mem[96]
            mem[mem[64] + 64] = mem[96]
            mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            mem[mem[64] + 32] = (32 * mem[96]) + 96
            _20845 = mem[(32 * tokenCount) + 128]
            mem[_13756 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
            mem[_13756 + (32 * _13815) + 128 len 32 * _20845] = mem[(32 * tokenCount) + 160 len 32 * _20845]
            return memory
              from mem[64]
               len _13756 + (32 * _13815) + (32 * _20845) + -mem[64] + 128
        mem[(32 * tokenCount) + 160 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(address(arg1), 12)
            require idx < tokenCount
            if userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128] < mem[(32 * idx) + 128]:
                revert with 0, 'SafeMath: addition overflow'
            require idx < tokenCount
            mem[(32 * idx) + 128] = userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128]
            idx = idx + 1
            continue 
        mem[(64 * tokenCount) + 160] = 0
        mem[(64 * tokenCount) + 192] = 0
        mem[(64 * tokenCount) + 224] = 0
        mem[(64 * tokenCount) + 256] = 0
        mem[(64 * tokenCount) + 288] = 0
        mem[(64 * tokenCount) + 320] = 0
        mem[(64 * tokenCount) + 352] = 0
        mem[(64 * tokenCount) + 384] = 96
        mem[(64 * tokenCount) + 512] = 0
        mem[(64 * tokenCount) + 544] = 0
        mem[(64 * tokenCount) + 576] = 0
        mem[(64 * tokenCount) + 608] = 0
        mem[(64 * tokenCount) + 640] = 0
        mem[(64 * tokenCount) + 416] = (64 * tokenCount) + 512
        mem[(64 * tokenCount) + 672] = 0
        mem[(64 * tokenCount) + 704] = 0
        mem[(64 * tokenCount) + 736] = 0
        mem[(64 * tokenCount) + 768] = 0
        mem[(64 * tokenCount) + 800] = 0
        mem[(64 * tokenCount) + 448] = (64 * tokenCount) + 672
        mem[(64 * tokenCount) + 832] = 0
        mem[(64 * tokenCount) + 864] = 0
        mem[(64 * tokenCount) + 896] = 0
        mem[(64 * tokenCount) + 928] = 0
        mem[(64 * tokenCount) + 960] = 0
        mem[(64 * tokenCount) + 992] = 0
        mem[(64 * tokenCount) + 1024] = 0
        mem[(64 * tokenCount) + 480] = (64 * tokenCount) + 832
        mem[0] = arg1
        mem[32] = 13
        if sub_26d8cc49[address(arg1)] == cycle:
            idx = 0
            while idx < tokenCount:
                mem[(64 * tokenCount) + 224] = 0
                s = 0
                while s < tranches.length:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(s, sha3(address(arg1), 14))
                    if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                    s = s + 1
                    continue 
                if mem[(64 * tokenCount) + 224]:
                    require s < mem[(32 * tokenCount) + 128]
                    if mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160] < mem[(32 * s) + (32 * tokenCount) + 160]:
                        revert with 0, 'SafeMath: addition overflow'
                    require s < mem[(32 * tokenCount) + 128]
                    mem[(32 * s) + (32 * tokenCount) + 160] = mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160]
                s = s + 1
                continue 
            mem[(64 * tokenCount) + 1056] = 64
            mem[(64 * tokenCount) + 1120] = tokenCount
            mem[(64 * tokenCount) + 1152 len 32 * tokenCount] = mem[128 len 32 * tokenCount]
            var35001 = tokenCount
            mem[(64 * tokenCount) + 1088] = (32 * tokenCount) + 96
            mem[(98 * tokenCount) + 1152] = mem[(32 * tokenCount) + 128]
            mem[(98 * tokenCount) + 1184 len 32 * mem[(32 * tokenCount) + 128]] = mem[(32 * tokenCount) + 160 len 32 * mem[(32 * tokenCount) + 128]]
            var40001 = mem[(32 * tokenCount) + 128]
            return memory
              from (64 * tokenCount) + 1056
               len (32 * tokenCount) + (32 * mem[(32 * tokenCount) + 128]) + 128
        mem[(64 * tokenCount) + 160] = 0
        require tokenCount <= test266151307()
        mem[(64 * tokenCount) + 1056] = tokenCount
        mem[64] = (98 * tokenCount) + 1088
        if not tokenCount:
            mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                _6966 = mem[64]
                mem[64] = mem[64] + 160
                mem[_6966] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                mem[_6966 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                mem[_6966 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                mem[_6966 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                mem[_6966 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                mem[(64 * tokenCount) + 416] = _6966
                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
                _10376 = mem[64]
                mem[64] = mem[64] + 224
                mem[_10376] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
                mem[_10376 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
                mem[_10376 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
                mem[_10376 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
                mem[_10376 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
                mem[_10376 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
                mem[_10376 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
                mem[(64 * tokenCount) + 480] = _10376
                mem[(64 * tokenCount) + 192] = 0
                mem[(64 * tokenCount) + 224] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(arg1), 14))
                    mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                        _13882 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_13882] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                        mem[_13882 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        mem[_13882 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                        mem[_13882 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                        mem[_13882 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                        mem[(64 * tokenCount) + 416] = _13882
                        _13884 = mem[mem[(64 * tokenCount) + 480] + 64]
                        if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            mem[(64 * tokenCount) + 256] = 0
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20957 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20957] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20957 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20957 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20957 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20957 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20957
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20953 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20953] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20953 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20953 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20953 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20953 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20953
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20949 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20949] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20949 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20949 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20949 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20949 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20949
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _20945 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_20945] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_20945 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_20945 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_20945 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_20945 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _20945
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                        else:
                            if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13884 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                        if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    else:
                                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20925 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20925] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20925 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20925 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20925 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20925 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20925
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20921 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20921] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20921 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20921 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20921 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20921 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20921
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20917 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20917] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20917 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20917 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20917 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20917 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20917
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _20913 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_20913] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_20913 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_20913 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_20913 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_20913 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _20913
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                    s = s + 1
                    continue 
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                    require idx < mem[96]
                    require idx < mem[mem[(64 * tokenCount) + 384]]
                    if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                idx = idx + 1
                continue 
            _13761 = mem[64]
            mem[mem[64]] = 64
            _13818 = mem[96]
            mem[mem[64] + 64] = mem[96]
            mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            mem[mem[64] + 32] = (32 * mem[96]) + 96
            _20910 = mem[(32 * tokenCount) + 128]
            mem[_13761 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
            mem[_13761 + (32 * _13818) + 128 len 32 * _20910] = mem[(32 * tokenCount) + 160 len 32 * _20910]
            return memory
              from mem[64]
               len _13761 + (32 * _13818) + (32 * _20910) + -mem[64] + 128
        mem[(64 * tokenCount) + 1088 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
        mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
            _6970 = mem[64]
            mem[64] = mem[64] + 160
            mem[_6970] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
            mem[_6970 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
            mem[_6970 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
            mem[_6970 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
            mem[_6970 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
            mem[(64 * tokenCount) + 416] = _6970
            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
            idx = idx + 1
            continue 
        idx = 0
        while idx < tranches.length:
            mem[0] = idx
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
            _10379 = mem[64]
            mem[64] = mem[64] + 224
            mem[_10379] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
            mem[_10379 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
            mem[_10379 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
            mem[_10379 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
            mem[_10379 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
            mem[_10379 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
            mem[_10379 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
            mem[(64 * tokenCount) + 480] = _10379
            mem[(64 * tokenCount) + 192] = 0
            mem[(64 * tokenCount) + 224] = 0
            s = 0
            while s < tokenCount:
                require s < tokens.length
                mem[0] = address(tokens[s].field_0)
                mem[32] = sha3(idx, sha3(address(arg1), 14))
                mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                    _13888 = mem[64]
                    mem[64] = mem[64] + 160
                    mem[_13888] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                    mem[_13888 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                    mem[_13888 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                    mem[_13888 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                    mem[_13888 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                    mem[(64 * tokenCount) + 416] = _13888
                    _13890 = mem[mem[(64 * tokenCount) + 480] + 64]
                    if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        mem[(64 * tokenCount) + 256] = 0
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                        if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21022 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21022] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21022 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21022 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21022 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21022 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21022
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21018 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21018] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21018 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21018 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21018 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21018 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21018
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                        else:
                            if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21014 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21014] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21014 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21014 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21014 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21014 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21014
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21010 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21010] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21010 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21010 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21010 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21010 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21010
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                    else:
                        if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13890 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        else:
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[(64 * tokenCount) + 288]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _20990 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_20990] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_20990 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_20990 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_20990 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_20990 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _20990
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _20986 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_20986] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_20986 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_20986 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_20986 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_20986 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _20986
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _20982 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_20982] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_20982 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_20982 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_20982 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_20982 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _20982
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _20978 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_20978] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_20978 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_20978 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_20978 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_20978 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _20978
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                s = s + 1
                continue 
            idx = idx + 1
            continue 
        idx = 0
        while idx < tokenCount:
            require idx < mem[mem[(64 * tokenCount) + 384]]
            if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                require idx < mem[96]
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < mem[96]
                mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
            idx = idx + 1
            continue 
        _13765 = mem[64]
        mem[mem[64]] = 64
        _13821 = mem[96]
        mem[mem[64] + 64] = mem[96]
        mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
        mem[mem[64] + 32] = (32 * mem[96]) + 96
        _20975 = mem[(32 * tokenCount) + 128]
        mem[_13765 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
        mem[_13765 + (32 * _13821) + 128 len 32 * _20975] = mem[(32 * tokenCount) + 160 len 32 * _20975]
        return memory
          from mem[64]
           len _13765 + (32 * _13821) + (32 * _20975) + -mem[64] + 128
    mem[128 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
    require tokenCount <= test266151307()
    mem[(32 * tokenCount) + 128] = tokenCount
    if not tokenCount:
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(address(arg1), 12)
            require idx < tokenCount
            if userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128] < mem[(32 * idx) + 128]:
                revert with 0, 'SafeMath: addition overflow'
            require idx < tokenCount
            mem[(32 * idx) + 128] = userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128]
            idx = idx + 1
            continue 
        mem[(64 * tokenCount) + 160] = 0
        mem[(64 * tokenCount) + 192] = 0
        mem[(64 * tokenCount) + 224] = 0
        mem[(64 * tokenCount) + 256] = 0
        mem[(64 * tokenCount) + 288] = 0
        mem[(64 * tokenCount) + 320] = 0
        mem[(64 * tokenCount) + 352] = 0
        mem[(64 * tokenCount) + 384] = 96
        mem[(64 * tokenCount) + 512] = 0
        mem[(64 * tokenCount) + 544] = 0
        mem[(64 * tokenCount) + 576] = 0
        mem[(64 * tokenCount) + 608] = 0
        mem[(64 * tokenCount) + 640] = 0
        mem[(64 * tokenCount) + 416] = (64 * tokenCount) + 512
        mem[(64 * tokenCount) + 672] = 0
        mem[(64 * tokenCount) + 704] = 0
        mem[(64 * tokenCount) + 736] = 0
        mem[(64 * tokenCount) + 768] = 0
        mem[(64 * tokenCount) + 800] = 0
        mem[(64 * tokenCount) + 448] = (64 * tokenCount) + 672
        mem[(64 * tokenCount) + 832] = 0
        mem[(64 * tokenCount) + 864] = 0
        mem[(64 * tokenCount) + 896] = 0
        mem[(64 * tokenCount) + 928] = 0
        mem[(64 * tokenCount) + 960] = 0
        mem[(64 * tokenCount) + 992] = 0
        mem[(64 * tokenCount) + 1024] = 0
        mem[(64 * tokenCount) + 480] = (64 * tokenCount) + 832
        mem[0] = arg1
        mem[32] = 13
        if sub_26d8cc49[address(arg1)] == cycle:
            idx = 0
            while idx < tokenCount:
                mem[(64 * tokenCount) + 224] = 0
                s = 0
                while s < tranches.length:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(s, sha3(address(arg1), 14))
                    if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                    s = s + 1
                    continue 
                if mem[(64 * tokenCount) + 224]:
                    require s < mem[(32 * tokenCount) + 128]
                    if mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160] < mem[(32 * s) + (32 * tokenCount) + 160]:
                        revert with 0, 'SafeMath: addition overflow'
                    require s < mem[(32 * tokenCount) + 128]
                    mem[(32 * s) + (32 * tokenCount) + 160] = mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160]
                s = s + 1
                continue 
            mem[(64 * tokenCount) + 1056] = 64
            mem[(64 * tokenCount) + 1120] = tokenCount
            mem[(64 * tokenCount) + 1152 len 32 * tokenCount] = mem[128 len 32 * tokenCount]
            var35001 = tokenCount
            mem[(64 * tokenCount) + 1088] = (32 * tokenCount) + 96
            mem[(98 * tokenCount) + 1152] = mem[(32 * tokenCount) + 128]
            mem[(98 * tokenCount) + 1184 len 32 * mem[(32 * tokenCount) + 128]] = mem[(32 * tokenCount) + 160 len 32 * mem[(32 * tokenCount) + 128]]
            var40001 = mem[(32 * tokenCount) + 128]
            return memory
              from (64 * tokenCount) + 1056
               len (32 * tokenCount) + (32 * mem[(32 * tokenCount) + 128]) + 128
        mem[(64 * tokenCount) + 160] = 0
        require tokenCount <= test266151307()
        mem[(64 * tokenCount) + 1056] = tokenCount
        mem[64] = (98 * tokenCount) + 1088
        if not tokenCount:
            mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
            idx = 0
            while idx < tokenCount:
                require idx < tokens.length
                mem[0] = address(tokens[idx].field_0)
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                _6974 = mem[64]
                mem[64] = mem[64] + 160
                mem[_6974] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                mem[_6974 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                mem[_6974 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                mem[_6974 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                mem[_6974 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                mem[(64 * tokenCount) + 416] = _6974
                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
                idx = idx + 1
                continue 
            idx = 0
            while idx < tranches.length:
                mem[0] = idx
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
                _10386 = mem[64]
                mem[64] = mem[64] + 224
                mem[_10386] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
                mem[_10386 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
                mem[_10386 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
                mem[_10386 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
                mem[_10386 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
                mem[_10386 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
                mem[_10386 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
                mem[(64 * tokenCount) + 480] = _10386
                mem[(64 * tokenCount) + 192] = 0
                mem[(64 * tokenCount) + 224] = 0
                s = 0
                while s < tokenCount:
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(idx, sha3(address(arg1), 14))
                    mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                        require s < tokens.length
                        mem[0] = address(tokens[s].field_0)
                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                        _13894 = mem[64]
                        mem[64] = mem[64] + 160
                        mem[_13894] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                        mem[_13894 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        mem[_13894 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                        mem[_13894 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                        mem[_13894 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                        mem[(64 * tokenCount) + 416] = _13894
                        _13896 = mem[mem[(64 * tokenCount) + 480] + 64]
                        if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            mem[(64 * tokenCount) + 256] = 0
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                s = s + 1
                                continue 
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _21087 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_21087] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_21087 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_21087 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_21087 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_21087 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _21087
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _21083 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_21083] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_21083 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_21083 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_21083 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_21083 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _21083
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _21079 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_21079] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_21079 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_21079 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_21079 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_21079 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _21079
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                                else:
                                    if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    idx = 0
                                    while idx < tokenCount:
                                        if s != idx:
                                            require idx < tokens.length
                                            mem[0] = address(tokens[idx].field_0)
                                            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                            _21075 = mem[64]
                                            mem[64] = mem[64] + 160
                                            mem[_21075] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                            mem[_21075 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                            mem[_21075 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                            mem[_21075 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                            mem[_21075 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                            mem[(64 * tokenCount) + 448] = _21075
                                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                if not mem[(64 * tokenCount) + 352]:
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                else:
                                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if mem[(64 * tokenCount) + 160] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require mem[(64 * tokenCount) + 160]
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    require idx < mem[mem[(64 * tokenCount) + 384]]
                                                    mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        idx = idx + 1
                                        continue 
                        else:
                            if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13896 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                                mem[(64 * tokenCount) + 288] = 0
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                                if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                        if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    else:
                                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _21055 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_21055] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_21055 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_21055 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_21055 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_21055 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _21055
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _21051 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_21051] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_21051 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_21051 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_21051 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_21051 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _21051
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require s < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[(64 * tokenCount) + 288]:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _21047 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_21047] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_21047 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_21047 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_21047 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_21047 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _21047
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                                idx = 0
                                                while idx < tokenCount:
                                                    if s != idx:
                                                        require idx < tokens.length
                                                        mem[0] = address(tokens[idx].field_0)
                                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                        _21043 = mem[64]
                                                        mem[64] = mem[64] + 160
                                                        mem[_21043] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                        mem[_21043 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                        mem[_21043 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                        mem[_21043 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                        mem[_21043 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                        mem[(64 * tokenCount) + 448] = _21043
                                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                            if not mem[(64 * tokenCount) + 352]:
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                            else:
                                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require mem[(64 * tokenCount) + 160]
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    idx = idx + 1
                                                    continue 
                    s = s + 1
                    continue 
                idx = idx + 1
                continue 
            idx = 0
            while idx < tokenCount:
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                    require idx < mem[96]
                    require idx < mem[mem[(64 * tokenCount) + 384]]
                    if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                idx = idx + 1
                continue 
            _13770 = mem[64]
            mem[mem[64]] = 64
            _13824 = mem[96]
            mem[mem[64] + 64] = mem[96]
            mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            mem[mem[64] + 32] = (32 * mem[96]) + 96
            _21040 = mem[(32 * tokenCount) + 128]
            mem[_13770 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
            mem[_13770 + (32 * _13824) + 128 len 32 * _21040] = mem[(32 * tokenCount) + 160 len 32 * _21040]
            return memory
              from mem[64]
               len _13770 + (32 * _13824) + (32 * _21040) + -mem[64] + 128
        mem[(64 * tokenCount) + 1088 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
        mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
            _6978 = mem[64]
            mem[64] = mem[64] + 160
            mem[_6978] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
            mem[_6978 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
            mem[_6978 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
            mem[_6978 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
            mem[_6978 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
            mem[(64 * tokenCount) + 416] = _6978
            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
            idx = idx + 1
            continue 
        idx = 0
        while idx < tranches.length:
            mem[0] = idx
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
            _10389 = mem[64]
            mem[64] = mem[64] + 224
            mem[_10389] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
            mem[_10389 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
            mem[_10389 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
            mem[_10389 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
            mem[_10389 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
            mem[_10389 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
            mem[_10389 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
            mem[(64 * tokenCount) + 480] = _10389
            mem[(64 * tokenCount) + 192] = 0
            mem[(64 * tokenCount) + 224] = 0
            s = 0
            while s < tokenCount:
                require s < tokens.length
                mem[0] = address(tokens[s].field_0)
                mem[32] = sha3(idx, sha3(address(arg1), 14))
                mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                    _13900 = mem[64]
                    mem[64] = mem[64] + 160
                    mem[_13900] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                    mem[_13900 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                    mem[_13900 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                    mem[_13900 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                    mem[_13900 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                    mem[(64 * tokenCount) + 416] = _13900
                    _13902 = mem[mem[(64 * tokenCount) + 480] + 64]
                    if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        mem[(64 * tokenCount) + 256] = 0
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                        if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21152 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21152] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21152 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21152 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21152 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21152 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21152
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21148 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21148] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21148 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21148 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21148 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21148 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21148
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                        else:
                            if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21144 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21144] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21144 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21144 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21144 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21144 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21144
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21140 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21140] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21140 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21140 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21140 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21140 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21140
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                    else:
                        if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13902 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        else:
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[(64 * tokenCount) + 288]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21120 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21120] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21120 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21120 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21120 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21120 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21120
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21116 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21116] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21116 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21116 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21116 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21116 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21116
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21112 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21112] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21112 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21112 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21112 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21112 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21112
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21108 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21108] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21108 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21108 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21108 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21108 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21108
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                s = s + 1
                continue 
            idx = idx + 1
            continue 
        idx = 0
        while idx < tokenCount:
            require idx < mem[mem[(64 * tokenCount) + 384]]
            if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                require idx < mem[96]
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < mem[96]
                mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
            idx = idx + 1
            continue 
        _13774 = mem[64]
        mem[mem[64]] = 64
        _13827 = mem[96]
        mem[mem[64] + 64] = mem[96]
        mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
        mem[mem[64] + 32] = (32 * mem[96]) + 96
        _21105 = mem[(32 * tokenCount) + 128]
        mem[_13774 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
        mem[_13774 + (32 * _13827) + 128 len 32 * _21105] = mem[(32 * tokenCount) + 160 len 32 * _21105]
        return memory
          from mem[64]
           len _13774 + (32 * _13827) + (32 * _21105) + -mem[64] + 128
    mem[(32 * tokenCount) + 160 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
    idx = 0
    while idx < tokenCount:
        require idx < tokens.length
        mem[0] = address(tokens[idx].field_0)
        mem[32] = sha3(address(arg1), 12)
        require idx < tokenCount
        if userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128] < mem[(32 * idx) + 128]:
            revert with 0, 'SafeMath: addition overflow'
        require idx < tokenCount
        mem[(32 * idx) + 128] = userBalances[address(arg1)][address(stor10[idx].field_0)] + mem[(32 * idx) + 128]
        idx = idx + 1
        continue 
    mem[(64 * tokenCount) + 160] = 0
    mem[(64 * tokenCount) + 192] = 0
    mem[(64 * tokenCount) + 224] = 0
    mem[(64 * tokenCount) + 256] = 0
    mem[(64 * tokenCount) + 288] = 0
    mem[(64 * tokenCount) + 320] = 0
    mem[(64 * tokenCount) + 352] = 0
    mem[(64 * tokenCount) + 384] = 96
    mem[(64 * tokenCount) + 512] = 0
    mem[(64 * tokenCount) + 544] = 0
    mem[(64 * tokenCount) + 576] = 0
    mem[(64 * tokenCount) + 608] = 0
    mem[(64 * tokenCount) + 640] = 0
    mem[(64 * tokenCount) + 416] = (64 * tokenCount) + 512
    mem[(64 * tokenCount) + 672] = 0
    mem[(64 * tokenCount) + 704] = 0
    mem[(64 * tokenCount) + 736] = 0
    mem[(64 * tokenCount) + 768] = 0
    mem[(64 * tokenCount) + 800] = 0
    mem[(64 * tokenCount) + 448] = (64 * tokenCount) + 672
    mem[(64 * tokenCount) + 832] = 0
    mem[(64 * tokenCount) + 864] = 0
    mem[(64 * tokenCount) + 896] = 0
    mem[(64 * tokenCount) + 928] = 0
    mem[(64 * tokenCount) + 960] = 0
    mem[(64 * tokenCount) + 992] = 0
    mem[(64 * tokenCount) + 1024] = 0
    mem[(64 * tokenCount) + 480] = (64 * tokenCount) + 832
    mem[0] = arg1
    mem[32] = 13
    if sub_26d8cc49[address(arg1)] == cycle:
        idx = 0
        while idx < tokenCount:
            mem[(64 * tokenCount) + 224] = 0
            s = 0
            while s < tranches.length:
                require s < tokens.length
                mem[0] = address(tokens[s].field_0)
                mem[32] = sha3(s, sha3(address(arg1), 14))
                if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)]:
                    if sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][s][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                s = s + 1
                continue 
            if mem[(64 * tokenCount) + 224]:
                require s < mem[(32 * tokenCount) + 128]
                if mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160] < mem[(32 * s) + (32 * tokenCount) + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                require s < mem[(32 * tokenCount) + 128]
                mem[(32 * s) + (32 * tokenCount) + 160] = mem[(64 * tokenCount) + 224] + mem[(32 * s) + (32 * tokenCount) + 160]
            s = s + 1
            continue 
        mem[(64 * tokenCount) + 1056] = 64
        mem[(64 * tokenCount) + 1120] = tokenCount
        mem[(64 * tokenCount) + 1152 len 32 * tokenCount] = mem[128 len 32 * tokenCount]
        var36001 = tokenCount
        mem[(64 * tokenCount) + 1088] = (32 * tokenCount) + 96
        mem[(98 * tokenCount) + 1152] = mem[(32 * tokenCount) + 128]
        mem[(98 * tokenCount) + 1184 len 32 * mem[(32 * tokenCount) + 128]] = mem[(32 * tokenCount) + 160 len 32 * mem[(32 * tokenCount) + 128]]
        var41001 = mem[(32 * tokenCount) + 128]
        return memory
          from (64 * tokenCount) + 1056
           len (32 * tokenCount) + (32 * mem[(32 * tokenCount) + 128]) + 128
    mem[(64 * tokenCount) + 160] = 0
    require tokenCount <= test266151307()
    mem[(64 * tokenCount) + 1056] = tokenCount
    mem[64] = (98 * tokenCount) + 1088
    if not tokenCount:
        mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
        idx = 0
        while idx < tokenCount:
            require idx < tokens.length
            mem[0] = address(tokens[idx].field_0)
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
            _6982 = mem[64]
            mem[64] = mem[64] + 160
            mem[_6982] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
            mem[_6982 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
            mem[_6982 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
            mem[_6982 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
            mem[_6982 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
            mem[(64 * tokenCount) + 416] = _6982
            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
            idx = idx + 1
            continue 
        idx = 0
        while idx < tranches.length:
            mem[0] = idx
            mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
            _10396 = mem[64]
            mem[64] = mem[64] + 224
            mem[_10396] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
            mem[_10396 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
            mem[_10396 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
            mem[_10396 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
            mem[_10396 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
            mem[_10396 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
            mem[_10396 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
            mem[(64 * tokenCount) + 480] = _10396
            mem[(64 * tokenCount) + 192] = 0
            mem[(64 * tokenCount) + 224] = 0
            s = 0
            while s < tokenCount:
                require s < tokens.length
                mem[0] = address(tokens[s].field_0)
                mem[32] = sha3(idx, sha3(address(arg1), 14))
                mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                    require s < tokens.length
                    mem[0] = address(tokens[s].field_0)
                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                    _13906 = mem[64]
                    mem[64] = mem[64] + 160
                    mem[_13906] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                    mem[_13906 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                    mem[_13906 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                    mem[_13906 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                    mem[_13906 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                    mem[(64 * tokenCount) + 416] = _13906
                    _13908 = mem[mem[(64 * tokenCount) + 480] + 64]
                    if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        mem[(64 * tokenCount) + 256] = 0
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                        if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            s = s + 1
                            continue 
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21217 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21217] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21217 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21217 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21217 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21217 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21217
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21213 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21213] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21213 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21213 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21213 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21213 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21213
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                        else:
                            if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21209 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21209] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21209 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21209 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21209 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21209 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21209
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                            else:
                                if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                idx = 0
                                while idx < tokenCount:
                                    if s != idx:
                                        require idx < tokens.length
                                        mem[0] = address(tokens[idx].field_0)
                                        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                        _21205 = mem[64]
                                        mem[64] = mem[64] + 160
                                        mem[_21205] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                        mem[_21205 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                        mem[_21205 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                        mem[_21205 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                        mem[_21205 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                        mem[(64 * tokenCount) + 448] = _21205
                                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                            if not mem[(64 * tokenCount) + 352]:
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            else:
                                                if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if mem[(64 * tokenCount) + 160] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require mem[(64 * tokenCount) + 160]
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                require idx < mem[mem[(64 * tokenCount) + 384]]
                                                mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                    idx = idx + 1
                                    continue 
                    else:
                        if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13908 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                            mem[(64 * tokenCount) + 288] = 0
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        else:
                            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                            if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                    if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                else:
                                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[(64 * tokenCount) + 288]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21185 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21185] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21185 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21185 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21185 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21185 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21185
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21181 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21181] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21181 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21181 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21181 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21181 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21181
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                    else:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require s < mem[mem[(64 * tokenCount) + 384]]
                                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not mem[(64 * tokenCount) + 288]:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21177 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21177] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21177 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21177 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21177 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21177 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21177
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                            idx = 0
                                            while idx < tokenCount:
                                                if s != idx:
                                                    require idx < tokens.length
                                                    mem[0] = address(tokens[idx].field_0)
                                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                    _21173 = mem[64]
                                                    mem[64] = mem[64] + 160
                                                    mem[_21173] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                    mem[_21173 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                    mem[_21173 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                    mem[_21173 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                    mem[_21173 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                    mem[(64 * tokenCount) + 448] = _21173
                                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                        if not mem[(64 * tokenCount) + 352]:
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                        else:
                                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require mem[(64 * tokenCount) + 160]
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                idx = idx + 1
                                                continue 
                s = s + 1
                continue 
            idx = idx + 1
            continue 
        idx = 0
        while idx < tokenCount:
            require idx < mem[mem[(64 * tokenCount) + 384]]
            if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
                require idx < mem[96]
                require idx < mem[mem[(64 * tokenCount) + 384]]
                if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                require idx < mem[96]
                mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
            idx = idx + 1
            continue 
        _13779 = mem[64]
        mem[mem[64]] = 64
        _13830 = mem[96]
        mem[mem[64] + 64] = mem[96]
        mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
        mem[mem[64] + 32] = (32 * mem[96]) + 96
        _21170 = mem[(32 * tokenCount) + 128]
        mem[_13779 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
        mem[_13779 + (32 * _13830) + 128 len 32 * _21170] = mem[(32 * tokenCount) + 160 len 32 * _21170]
        return memory
          from mem[64]
           len _13779 + (32 * _13830) + (32 * _21170) + -mem[64] + 128
    mem[(64 * tokenCount) + 1088 len 32 * tokenCount] = call.data[calldata.size len 32 * tokenCount]
    mem[(64 * tokenCount) + 384] = (64 * tokenCount) + 1056
    idx = 0
    while idx < tokenCount:
        require idx < tokens.length
        mem[0] = address(tokens[idx].field_0)
        mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
        _6986 = mem[64]
        mem[64] = mem[64] + 160
        mem[_6986] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
        mem[_6986 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
        mem[_6986 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
        mem[_6986 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
        mem[_6986 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
        mem[(64 * tokenCount) + 416] = _6986
        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160] < mem[(64 * tokenCount) + 160]:
                revert with 0, 'SafeMath: addition overflow'
            mem[(64 * tokenCount) + 160] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 + mem[(64 * tokenCount) + 160]
        idx = idx + 1
        continue 
    idx = 0
    while idx < tranches.length:
        mem[0] = idx
        mem[32] = sha3(sub_26d8cc49[address(arg1)], 16)
        _10399 = mem[64]
        mem[64] = mem[64] + 224
        mem[_10399] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_0
        mem[_10399 + 32] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_256
        mem[_10399 + 64] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_512
        mem[_10399 + 96] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_768
        mem[_10399 + 128] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1024
        mem[_10399 + 160] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1280
        mem[_10399 + 192] = sub_ae4f9c74[stor13[address(arg1)]][idx].field_1536
        mem[(64 * tokenCount) + 480] = _10399
        mem[(64 * tokenCount) + 192] = 0
        mem[(64 * tokenCount) + 224] = 0
        s = 0
        while s < tokenCount:
            require s < tokens.length
            mem[0] = address(tokens[s].field_0)
            mem[32] = sha3(idx, sha3(address(arg1), 14))
            mem[(64 * tokenCount) + 320] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
            if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224] < mem[(64 * tokenCount) + 224]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[(64 * tokenCount) + 224] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(64 * tokenCount) + 224]
                require s < tokens.length
                mem[0] = address(tokens[s].field_0)
                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                _13912 = mem[64]
                mem[64] = mem[64] + 160
                mem[_13912] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_0
                mem[_13912 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                mem[_13912 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512
                mem[_13912 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_768
                mem[_13912 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024))
                mem[(64 * tokenCount) + 416] = _13912
                _13914 = mem[mem[(64 * tokenCount) + 480] + 64]
                if not sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                    mem[(64 * tokenCount) + 256] = 0
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                        mem[(64 * tokenCount) + 288] = 0
                        if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        s = s + 1
                        continue 
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[(64 * tokenCount) + 288] = -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                    if mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                        revert with 0, 'SafeMath: addition overflow'
                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        s = s + 1
                        continue 
                    if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        s = s + 1
                        continue 
                    require s < mem[mem[(64 * tokenCount) + 384]]
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    require s < mem[mem[(64 * tokenCount) + 384]]
                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            idx = 0
                            while idx < tokenCount:
                                if s != idx:
                                    require idx < tokens.length
                                    mem[0] = address(tokens[idx].field_0)
                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                    _21282 = mem[64]
                                    mem[64] = mem[64] + 160
                                    mem[_21282] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                    mem[_21282 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                    mem[_21282 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                    mem[_21282 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                    mem[_21282 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                    mem[(64 * tokenCount) + 448] = _21282
                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                        if not mem[(64 * tokenCount) + 352]:
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                idx = idx + 1
                                continue 
                        else:
                            if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            idx = 0
                            while idx < tokenCount:
                                if s != idx:
                                    require idx < tokens.length
                                    mem[0] = address(tokens[idx].field_0)
                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                    _21278 = mem[64]
                                    mem[64] = mem[64] + 160
                                    mem[_21278] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                    mem[_21278 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                    mem[_21278 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                    mem[_21278 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                    mem[_21278 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                    mem[(64 * tokenCount) + 448] = _21278
                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                        if not mem[(64 * tokenCount) + 352]:
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                idx = idx + 1
                                continue 
                    else:
                        if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (-1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            idx = 0
                            while idx < tokenCount:
                                if s != idx:
                                    require idx < tokens.length
                                    mem[0] = address(tokens[idx].field_0)
                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                    _21274 = mem[64]
                                    mem[64] = mem[64] + 160
                                    mem[_21274] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                    mem[_21274 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                    mem[_21274 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                    mem[_21274 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                    mem[_21274 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                    mem[(64 * tokenCount) + 448] = _21274
                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                        if not mem[(64 * tokenCount) + 352]:
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                idx = idx + 1
                                continue 
                        else:
                            if -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / -sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            mem[(64 * tokenCount) + 352] = -1 * sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                            idx = 0
                            while idx < tokenCount:
                                if s != idx:
                                    require idx < tokens.length
                                    mem[0] = address(tokens[idx].field_0)
                                    mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                    _21270 = mem[64]
                                    mem[64] = mem[64] + 160
                                    mem[_21270] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                    mem[_21270 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                    mem[_21270 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                    mem[_21270 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                    mem[_21270 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                    mem[(64 * tokenCount) + 448] = _21270
                                    if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                        if not mem[(64 * tokenCount) + 352]:
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                        else:
                                            if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if mem[(64 * tokenCount) + 160] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require mem[(64 * tokenCount) + 160]
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            require idx < mem[mem[(64 * tokenCount) + 384]]
                                            mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                idx = idx + 1
                                continue 
                else:
                    if mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] != mem[mem[(64 * tokenCount) + 480] + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[(64 * tokenCount) + 256] = mem[mem[(64 * tokenCount) + 480] + 64] * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18
                    if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > _13914 * sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] / 10^18:
                        mem[(64 * tokenCount) + 288] = 0
                        if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                    else:
                        if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] > mem[(64 * tokenCount) + 256]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[(64 * tokenCount) + 288] = mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]
                        if mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192] < mem[(64 * tokenCount) + 192]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(64 * tokenCount) + 192] = mem[(64 * tokenCount) + 256] + mem[(64 * tokenCount) + 192]
                        require s < mem[mem[(64 * tokenCount) + 384]]
                        if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_1024):
                            if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            require s < mem[mem[(64 * tokenCount) + 384]]
                            mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                        else:
                            if not mem[(64 * tokenCount) + 256] - sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)]:
                                if mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = mem[(64 * tokenCount) + 256] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                            else:
                                if sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require s < mem[mem[(64 * tokenCount) + 384]]
                                mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = sub_6aad5e20[address(arg1)][idx][address(stor10[s].field_0)] + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[(64 * tokenCount) + 288]:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[(64 * tokenCount) + 288]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _21250 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_21250] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_21250 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_21250 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_21250 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_21250 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _21250
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _21246 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_21246] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_21246 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_21246 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_21246 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_21246 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _21246
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                else:
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    if (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require s < mem[mem[(64 * tokenCount) + 384]]
                                    mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256) + mem[(32 * s) + mem[(64 * tokenCount) + 384] + 32]
                                    if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 < sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[(64 * tokenCount) + 288]:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = 0 / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _21242 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_21242] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_21242 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_21242 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_21242 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_21242 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _21242
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / mem[(64 * tokenCount) + 288] != sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        mem[(64 * tokenCount) + 352] = sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 * mem[(64 * tokenCount) + 288] / sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_512 + sub_8365b232[stor13[address(arg1)]][address(stor10[s].field_0)].field_256
                                        idx = 0
                                        while idx < tokenCount:
                                            if s != idx:
                                                require idx < tokens.length
                                                mem[0] = address(tokens[idx].field_0)
                                                mem[32] = sha3(sub_26d8cc49[address(arg1)], 17)
                                                _21238 = mem[64]
                                                mem[64] = mem[64] + 160
                                                mem[_21238] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_0
                                                mem[_21238 + 32] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_256
                                                mem[_21238 + 64] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512
                                                mem[_21238 + 96] = sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_768
                                                mem[_21238 + 128] = bool(uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024))
                                                mem[(64 * tokenCount) + 448] = _21238
                                                if uint8(sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_1024):
                                                    if not mem[(64 * tokenCount) + 352]:
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (0 / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                                    else:
                                                        if sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 352] != sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if mem[(64 * tokenCount) + 160] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require mem[(64 * tokenCount) + 160]
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        if (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require idx < mem[mem[(64 * tokenCount) + 384]]
                                                        mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] = (sub_8365b232[stor13[address(arg1)]][address(stor10[idx].field_0)].field_512 * mem[(64 * tokenCount) + 352] / mem[(64 * tokenCount) + 160]) + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
                                            idx = idx + 1
                                            continue 
            s = s + 1
            continue 
        idx = idx + 1
        continue 
    idx = 0
    while idx < tokenCount:
        require idx < mem[mem[(64 * tokenCount) + 384]]
        if mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] > 0:
            require idx < mem[96]
            require idx < mem[mem[(64 * tokenCount) + 384]]
            if mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32] < mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]:
                revert with 0, 'SafeMath: addition overflow'
            require idx < mem[96]
            mem[(32 * idx) + 128] = mem[(32 * idx) + 128] + mem[(32 * idx) + mem[(64 * tokenCount) + 384] + 32]
        idx = idx + 1
        continue 
    _13783 = mem[64]
    mem[mem[64]] = 64
    _13833 = mem[96]
    mem[mem[64] + 64] = mem[96]
    mem[mem[64] + 96 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
    mem[mem[64] + 32] = (32 * mem[96]) + 96
    _21235 = mem[(32 * tokenCount) + 128]
    mem[_13783 + (32 * mem[96]) + 96] = mem[(32 * tokenCount) + 128]
    mem[_13783 + (32 * _13833) + 128 len 32 * _21235] = mem[(32 * tokenCount) + 160 len 32 * _21235]
    return memory
      from mem[64]
       len _13783 + (32 * _13833) + (32 * _21235) + -mem[64] + 128
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
const name = 'Bonfire', 0

const decimals = 11

const symbol = '', 0


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
array of address stor6;
array of address stor7;
uint256 totalSupply;
uint256 stor9;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 stor13;
uint256 stor14;
uint256 stor15;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function totalBurn() payable {
    return totalBurn
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function isCharity(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0xe33e24498ad617de554a7f5ed8a12960541b4779:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The Uniswap router can not be the charity account.'
    if stor5[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Account is already charity account'
    stor5[address(arg1)] = 1
    stor7.length++
    stor7[stor7.length] = arg1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor6.length:
        mem[0] = 6
        if stor6[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor6.length < 1:
            revert with 0, 17
        if stor6.length - 1 >= stor6.length:
            revert with 0, 50
        if idx >= stor6.length:
            revert with 0, 50
        stor6[idx] = stor6[stor6.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor6.length:
            revert with 0, 49
        stor6[stor6.length] = 0
        stor6.length--
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _93 = mem[64]
            mem[64] = mem[64] + 64
            mem[_93] = 26
            mem[_93 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _98 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _98 + 68] = mem[idx + _93 + 32]
                    idx = idx + 32
                    continue 
                mem[_98 + 94] = 0
                revert with memory
                  from mem[64]
                   len _98 + -mem[64] + 100
            _118 = mem[64]
            mem[64] = mem[64] + 64
            mem[_118] = 26
            mem[_118 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (arg1 / stor9 / totalSupply)
            _127 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _127 + 68] = mem[idx + _118 + 32]
                idx = idx + 32
                continue 
            mem[_127 + 94] = 0
            revert with memory
              from mem[64]
               len _127 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _99 = mem[64]
            mem[64] = mem[64] + 64
            mem[_99] = 26
            mem[_99 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _104 + 68] = mem[idx + _99 + 32]
                    idx = idx + 32
                    continue 
                mem[_104 + 94] = 0
                revert with memory
                  from mem[64]
                   len _104 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (arg1 / stor9 / totalSupply)
            _134 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _134 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_134 + 94] = 0
            revert with memory
              from mem[64]
               len _134 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _96 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _123 = mem[64]
        mem[64] = mem[64] + 64
        mem[_123] = 30
        mem[_123 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _130 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _130 + 68] = mem[idx + _123 + 32]
            idx = idx + 32
            continue 
        mem[_130 + 98] = 0
        revert with memory
          from mem[64]
           len _130 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor9 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor9 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor9:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor9
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _123 = mem[64]
            mem[64] = mem[64] + 64
            mem[_123] = 26
            mem[_123 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _132 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _132 + 68] = mem[idx + _123 + 32]
                idx = idx + 32
                continue 
            mem[_132 + 94] = 0
            revert with memory
              from mem[64]
               len _132 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _104 = mem[64]
            mem[64] = mem[64] + 64
            mem[_104] = 26
            mem[_104 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _109 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _109 + 68] = mem[idx + _104 + 32]
                    idx = idx + 32
                    continue 
                mem[_109 + 94] = 0
                revert with memory
                  from mem[64]
                   len _109 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor9 / totalSupply:
                return (stor1[address(arg1)] / stor9 / totalSupply)
            _139 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _139 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_139 + 94] = 0
            revert with memory
              from mem[64]
               len _139 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _101 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _128 = mem[64]
        mem[64] = mem[64] + 64
        mem[_128] = 30
        mem[_128 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _135 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _135 + 68] = mem[idx + _128 + 32]
            idx = idx + 32
            continue 
        mem[_135 + 98] = 0
        revert with memory
          from mem[64]
           len _135 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor9 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor9 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor9 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 == 0xe33e24498ad617de554a7f5ed8a12960541b4779:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'We can not exclude Uniswap router.'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor9:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _103 = mem[64]
                mem[64] = mem[64] + 64
                mem[_103] = 26
                mem[_103 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _108 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _108 + 68] = mem[idx + _103 + 32]
                        idx = idx + 32
                        continue 
                    mem[_108 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _108 + -mem[64] + 100
                _128 = mem[64]
                mem[64] = mem[64] + 64
                mem[_128] = 26
                mem[_128 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _137 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _137 + 68] = mem[idx + _128 + 32]
                    idx = idx + 32
                    continue 
                mem[_137 + 94] = 0
                revert with memory
                  from mem[64]
                   len _137 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] > s:
                _109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_109] = 26
                mem[_109 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _114 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _114 + 68] = mem[idx + _109 + 32]
                        idx = idx + 32
                        continue 
                    mem[_114 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _114 + -mem[64] + 100
                _138 = mem[64]
                mem[64] = mem[64] + 64
                mem[_138] = 26
                mem[_138 + 32] = 'SafeMath: division by zero'
                if stor9 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _144 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _144 + 68] = mem[idx + _138 + 32]
                    idx = idx + 32
                    continue 
                mem[_144 + 94] = 0
                revert with memory
                  from mem[64]
                   len _144 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 1
            _106 = mem[64]
            mem[64] = mem[64] + 64
            mem[_106] = 30
            mem[_106 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor6[idx]] > t:
                _112 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _112 + 68] = mem[idx + _106 + 32]
                    idx = idx + 32
                    continue 
                mem[_112 + 98] = 0
                revert with memory
                  from mem[64]
                   len _112 + -mem[64] + 100
            if t < stor1[stor6[idx]]:
                revert with 0, 17
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 30
            mem[_133 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor6[idx]] <= s:
                if s < stor2[stor6[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor6[idx]]
                t = t - stor1[stor6[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor9 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor9 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor9 / totalSupply
    stor4[address(arg1)] = 1
    stor6.length++
    stor6[stor6.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor9
                    while idx < stor6.length:
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        if stor1[stor6[idx]] > t:
                            _9218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9218] = 26
                            mem[_9218 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _9291 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9291 + 68] = mem[idx + _9218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9291 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9291 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor9 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10242 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10242] = 30
                            mem[_10242 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10400 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10400 + 68] = mem[idx + _10242 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10400 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10400 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10995] = 30
                            mem[_10995 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11302 + 68] = mem[idx + _10995 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11302 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11302 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12545] = 30
                            mem[_12545 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13034 + 68] = mem[idx + _12545 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13034 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13034 + -mem[64] + 100
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        if stor2[stor6[idx]] <= s:
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 1
                            _9260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9260] = 30
                            mem[_9260 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor6[idx]] > t:
                                _9340 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9340 + 68] = mem[idx + _9260 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9340 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9340 + -mem[64] + 100
                            if t < stor1[stor6[idx]]:
                                revert with 0, 17
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 2
                            _9683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9683] = 30
                            mem[_9683 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor6[idx]] <= s:
                                if s < stor2[stor6[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor6[idx]]
                                t = t - stor1[stor6[idx]]
                                continue 
                            _9740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9740 + 68] = mem[idx + _9683 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9740 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9740 + -mem[64] + 100
                        _9292 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9292] = 26
                        mem[_9292 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9380 + 68] = mem[idx + _9292 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9380 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9380 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10402] = 30
                        mem[_10402 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10519 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10519 + 68] = mem[idx + _10402 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10519 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10519 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11304] = 30
                        mem[_11304 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11659 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11659 + 68] = mem[idx + _11304 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11659 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11659 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13035] = 30
                        mem[_13035 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13514 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13514 + 68] = mem[idx + _13035 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13514 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13514 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor9 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9214 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9214] = 26
                        mem[_9214 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9288 + 68] = mem[idx + _9214 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9288 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9288 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10238 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10238] = 30
                            mem[_10238 + 32] = 'SafeMath: subtraction overflow'
                            _10989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10989] = 30
                            mem[_10989 + 32] = 'SafeMath: subtraction overflow'
                            _12538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12538] = 30
                            mem[_12538 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _13029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13029 + 68] = mem[idx + _12538 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13029 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13029 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10237] = 30
                            mem[_10237 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10396 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10396 + 68] = mem[idx + _10237 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10396 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10396 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10987] = 30
                            mem[_10987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11296 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11296 + 68] = mem[idx + _10987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11296 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11296 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12536 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12536] = 30
                            mem[_12536 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13028 + 68] = mem[idx + _12536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13028 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10713] = 30
                        mem[_10713 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10986 + 68] = mem[idx + _10713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10986 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10986 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12069] = 30
                        mem[_12069 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12535 + 68] = mem[idx + _12069 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12535 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12535 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14077] = 30
                        mem[_14077 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14636 + 68] = mem[idx + _14077 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14636 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14636 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9259] = 30
                        mem[_9259 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9337 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9337 + 68] = mem[idx + _9259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9337 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9337 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9681 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9681] = 30
                        mem[_9681 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9739 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9739 + 68] = mem[idx + _9681 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9739 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9739 + -mem[64] + 100
                    _9289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9289] = 26
                    mem[_9289 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9378 + 68] = mem[idx + _9289 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9378 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9378 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10399] = 30
                        mem[_10399 + 32] = 'SafeMath: subtraction overflow'
                        _11301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11301] = 30
                        mem[_11301 + 32] = 'SafeMath: subtraction overflow'
                        _13033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13033] = 30
                        mem[_13033 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13513 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13513 + 68] = mem[idx + _13033 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13513 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13513 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10398 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10398] = 30
                        mem[_10398 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10517 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10517 + 68] = mem[idx + _10398 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10517 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10517 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11299] = 30
                        mem[_11299 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11657 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11657 + 68] = mem[idx + _11299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11657 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11657 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13031] = 30
                        mem[_13031 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13512 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13512 + 68] = mem[idx + _13031 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13512 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13512 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10990 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10990] = 30
                    mem[_10990 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11298 + 68] = mem[idx + _10990 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11298 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11298 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12539 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12539] = 30
                    mem[_12539 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13030 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13030 + 68] = mem[idx + _12539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13030 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13030 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14639 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14639] = 30
                    mem[_14639 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15131 + 68] = mem[idx + _14639 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15131 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15131 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9210] = 26
                        mem[_9210 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9285 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9285 + 68] = mem[idx + _9210 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9285 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9285 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10234 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10234] = 30
                            mem[_10234 + 32] = 'SafeMath: subtraction overflow'
                            _10980 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10980] = 30
                            mem[_10980 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11288 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11288 + 68] = mem[idx + _10980 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11288 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11288 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12527] = 30
                            mem[_12527 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _13022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13022 + 68] = mem[idx + _12527 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13022 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13022 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10233 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10233] = 30
                            mem[_10233 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10391 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10391 + 68] = mem[idx + _10233 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10391 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10391 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10978 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10978] = 30
                            mem[_10978 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11287 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11287 + 68] = mem[idx + _10978 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11287 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11287 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12525] = 30
                            mem[_12525 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13021 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13021 + 68] = mem[idx + _12525 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13021 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13021 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10708 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10708] = 30
                        mem[_10708 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10977 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10977 + 68] = mem[idx + _10708 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10977 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10977 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12059] = 30
                        mem[_12059 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12524 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12524 + 68] = mem[idx + _12059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12524 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12524 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14066 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14066] = 30
                        mem[_14066 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14626 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14626 + 68] = mem[idx + _14066 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14626 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14626 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9258] = 30
                        mem[_9258 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9334 + 68] = mem[idx + _9258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9334 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9679 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9679] = 30
                        mem[_9679 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9738 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9738 + 68] = mem[idx + _9679 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9738 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9738 + -mem[64] + 100
                    _9286 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9286] = 26
                    mem[_9286 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9376 + 68] = mem[idx + _9286 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9376 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9376 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10395] = 30
                        mem[_10395 + 32] = 'SafeMath: subtraction overflow'
                        _11293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11293] = 30
                        mem[_11293 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11653 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11653 + 68] = mem[idx + _11293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11653 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11653 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13026 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13026] = 30
                        mem[_13026 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13507 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13507 + 68] = mem[idx + _13026 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13507 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13507 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10394] = 30
                        mem[_10394 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10512 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10512 + 68] = mem[idx + _10394 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10512 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10512 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11291] = 30
                        mem[_11291 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11652 + 68] = mem[idx + _11291 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11652 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11652 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13024 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13024] = 30
                        mem[_13024 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13506 + 68] = mem[idx + _13024 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13506 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10981 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10981] = 30
                    mem[_10981 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11290 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11290 + 68] = mem[idx + _10981 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11290 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11290 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12529] = 30
                    mem[_12529 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13023 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13023 + 68] = mem[idx + _12529 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13023 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13023 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14629] = 30
                    mem[_14629 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15128 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15128 + 68] = mem[idx + _14629 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15128 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15128 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor14 / 100 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9206 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9206] = 26
                    mem[_9206 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9282 + 68] = mem[idx + _9206 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9282 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9282 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10226 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10226] = 30
                            mem[_10226 + 32] = 'SafeMath: subtraction overflow'
                            _10969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10969] = 30
                            mem[_10969 + 32] = 'SafeMath: subtraction overflow'
                            _12511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12511] = 30
                            mem[_12511 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _13012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13012 + 68] = mem[idx + _12511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13012 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13012 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10225 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10225] = 30
                            mem[_10225 + 32] = 'SafeMath: subtraction overflow'
                            _10968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10968] = 30
                            mem[_10968 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11279 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11279 + 68] = mem[idx + _10968 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11279 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11279 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12509] = 30
                            mem[_12509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _13011 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13011 + 68] = mem[idx + _12509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13011 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13011 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10699] = 30
                        mem[_10699 + 32] = 'SafeMath: subtraction overflow'
                        _12049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12049] = 30
                        mem[_12049 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12508 + 68] = mem[idx + _12049 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12508 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12508 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14051] = 30
                        mem[_14051 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14611 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14611 + 68] = mem[idx + _14051 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14611 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14611 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10224 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10224] = 30
                            mem[_10224 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10385 + 68] = mem[idx + _10224 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10385 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10385 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10966] = 30
                            mem[_10966 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11278 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11278 + 68] = mem[idx + _10966 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11278 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11278 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12506 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12506] = 30
                            mem[_12506 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13010 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13010 + 68] = mem[idx + _12506 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13010 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13010 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10698] = 30
                        mem[_10698 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10965 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10965 + 68] = mem[idx + _10698 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10965 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10965 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12047] = 30
                        mem[_12047 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12505 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12505 + 68] = mem[idx + _12047 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12505 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12505 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14049] = 30
                        mem[_14049 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14609 + 68] = mem[idx + _14049 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14609 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10697] = 30
                        mem[_10697 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10964 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10964 + 68] = mem[idx + _10697 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10964 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10964 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12045] = 30
                        mem[_12045 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12504 + 68] = mem[idx + _12045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12504 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12504 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14047] = 30
                        mem[_14047 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14608 + 68] = mem[idx + _14047 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14608 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14608 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11645 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11645] = 30
                    mem[_11645 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12044 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12044 + 68] = mem[idx + _11645 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12044 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12044 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13497 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13497] = 30
                    mem[_13497 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14046 + 68] = mem[idx + _13497 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14046 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14046 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15650 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15650] = 30
                    mem[_15650 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16159 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16159 + 68] = mem[idx + _15650 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16159 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16159 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9257] = 30
                    mem[_9257 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9331 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9331 + 68] = mem[idx + _9257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9331 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9331 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9677 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9677] = 30
                    mem[_9677 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9737 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9737 + 68] = mem[idx + _9677 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9737 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9737 + -mem[64] + 100
                _9283 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9283] = 26
                mem[_9283 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9374 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9374 + 68] = mem[idx + _9283 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9374 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9374 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10390 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10390] = 30
                        mem[_10390 + 32] = 'SafeMath: subtraction overflow'
                        _11286 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11286] = 30
                        mem[_11286 + 32] = 'SafeMath: subtraction overflow'
                        _13020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13020] = 30
                        mem[_13020 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13501 + 68] = mem[idx + _13020 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13501 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10389 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10389] = 30
                        mem[_10389 + 32] = 'SafeMath: subtraction overflow'
                        _11285 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11285] = 30
                        mem[_11285 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11648 + 68] = mem[idx + _11285 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11648 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13018 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13018] = 30
                        mem[_13018 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13500 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13500 + 68] = mem[idx + _13018 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13500 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13500 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10972 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10972] = 30
                    mem[_10972 + 32] = 'SafeMath: subtraction overflow'
                    _12517 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12517] = 30
                    mem[_12517 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _13017 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13017 + 68] = mem[idx + _12517 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13017 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13017 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14619 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14619] = 30
                    mem[_14619 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15125 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15125 + 68] = mem[idx + _14619 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15125 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15125 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10388 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10388] = 30
                        mem[_10388 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10510 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10510 + 68] = mem[idx + _10388 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10510 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10510 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11283] = 30
                        mem[_11283 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11647 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11647 + 68] = mem[idx + _11283 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11647 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11647 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13015 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13015] = 30
                        mem[_13015 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13499 + 68] = mem[idx + _13015 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13499 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13499 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10971 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10971] = 30
                    mem[_10971 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11282 + 68] = mem[idx + _10971 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11282 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11282 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12515 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12515] = 30
                    mem[_12515 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13014 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13014 + 68] = mem[idx + _12515 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13014 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13014 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14617] = 30
                    mem[_14617 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15123 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15123 + 68] = mem[idx + _14617 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15123 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15123 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10970 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10970] = 30
                    mem[_10970 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11281 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11281 + 68] = mem[idx + _10970 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11281 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11281 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12513 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12513] = 30
                    mem[_12513 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13013 + 68] = mem[idx + _12513 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13013 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13013 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14615] = 30
                    mem[_14615 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15122 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15122 + 68] = mem[idx + _14615 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15122 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15122 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12050 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12050] = 30
                mem[_12050 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _12512 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12512 + 68] = mem[idx + _12050 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12512 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12512 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                _14054 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14054] = 30
                mem[_14054 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _14614 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14614 + 68] = mem[idx + _14054 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14614 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14614 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16163] = 30
                mem[_16163 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16506 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16506 + 68] = mem[idx + _16163 + 32]
                    idx = idx + 32
                    continue 
                mem[_16506 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16506 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor13 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9202] = 26
                        mem[_9202 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9279 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9279 + 68] = mem[idx + _9202 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9279 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9279 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10218] = 30
                            mem[_10218 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10381 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10381 + 68] = mem[idx + _10218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10381 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10381 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10957 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10957] = 30
                            mem[_10957 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11266 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11266 + 68] = mem[idx + _10957 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11266 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11266 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12492] = 30
                            mem[_12492 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _13002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13002 + 68] = mem[idx + _12492 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13002 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13002 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10217] = 30
                            mem[_10217 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10380 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10380 + 68] = mem[idx + _10217 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10380 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10380 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10955 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10955] = 30
                            mem[_10955 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11265 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11265 + 68] = mem[idx + _10955 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11265 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11265 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12490] = 30
                            mem[_12490 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13001 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13001 + 68] = mem[idx + _12490 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13001 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13001 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10688] = 30
                        mem[_10688 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10954 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10954 + 68] = mem[idx + _10688 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10954 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10954 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12030] = 30
                        mem[_12030 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12489 + 68] = mem[idx + _12030 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12489 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12489 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14027 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14027] = 30
                        mem[_14027 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14596 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14596 + 68] = mem[idx + _14027 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14596 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14596 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9256 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9256] = 30
                        mem[_9256 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9328 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9328 + 68] = mem[idx + _9256 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9328 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9328 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9675] = 30
                        mem[_9675 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9736 + 68] = mem[idx + _9675 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9736 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9736 + -mem[64] + 100
                    _9280 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9280] = 26
                    mem[_9280 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9372 + 68] = mem[idx + _9280 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9372 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9372 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10384] = 30
                        mem[_10384 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10504 + 68] = mem[idx + _10384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10504 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10504 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11271] = 30
                        mem[_11271 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11637 + 68] = mem[idx + _11271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11637 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11637 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13006 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13006] = 30
                        mem[_13006 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13484 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13484 + 68] = mem[idx + _13006 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13484 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13484 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10383] = 30
                        mem[_10383 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10503 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10503 + 68] = mem[idx + _10383 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10503 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10503 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11269] = 30
                        mem[_11269 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11636 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11636 + 68] = mem[idx + _11269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11636 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11636 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13004] = 30
                        mem[_13004 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13483 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13483 + 68] = mem[idx + _13004 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13483 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13483 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10959 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10959] = 30
                    mem[_10959 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11268 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11268 + 68] = mem[idx + _10959 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11268 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11268 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12494] = 30
                    mem[_12494 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13003 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13003 + 68] = mem[idx + _12494 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13003 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13003 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14599] = 30
                    mem[_14599 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15115 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15115 + 68] = mem[idx + _14599 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15115 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15115 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        return 0
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor15 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / arg1 != stor15:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9198 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9198] = 26
                    mem[_9198 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9276 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9276 + 68] = mem[idx + _9198 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9276 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9276 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10211] = 30
                            mem[_10211 + 32] = 'SafeMath: subtraction overflow'
                            _10944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10944] = 30
                            mem[_10944 + 32] = 'SafeMath: subtraction overflow'
                            _12475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12475] = 30
                            mem[_12475 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12992 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12992 + 68] = mem[idx + _12475 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12992 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12992 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10210] = 30
                            mem[_10210 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10375 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10375 + 68] = mem[idx + _10210 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10375 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10375 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10942] = 30
                            mem[_10942 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11255 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11255 + 68] = mem[idx + _10942 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11255 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11255 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12473 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12473] = 30
                            mem[_12473 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12991 + 68] = mem[idx + _12473 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12991 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12991 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10681 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10681] = 30
                        mem[_10681 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10941 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10941 + 68] = mem[idx + _10681 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10941 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10941 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12017 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12017] = 30
                        mem[_12017 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12472 + 68] = mem[idx + _12017 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12472 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12472 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14012 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14012] = 30
                        mem[_14012 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14581 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14581 + 68] = mem[idx + _14012 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14581 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14581 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10209] = 30
                            mem[_10209 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10374 + 68] = mem[idx + _10209 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10374 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10939 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10939] = 30
                            mem[_10939 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11254 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11254 + 68] = mem[idx + _10939 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11254 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11254 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12470 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12470] = 30
                            mem[_12470 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _12990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12990 + 68] = mem[idx + _12470 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12990 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12990 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10680 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10680] = 30
                        mem[_10680 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10938 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10938 + 68] = mem[idx + _10680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10938 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10938 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12015 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12015] = 30
                        mem[_12015 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12469 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12469 + 68] = mem[idx + _12015 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12469 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12469 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14010 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14010] = 30
                        mem[_14010 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14579 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14579 + 68] = mem[idx + _14010 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14579 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14579 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10679 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10679] = 30
                        mem[_10679 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10937 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10937 + 68] = mem[idx + _10679 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10937 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10937 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12013] = 30
                        mem[_12013 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12468 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12468 + 68] = mem[idx + _12013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12468 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12468 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14008 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14008] = 30
                        mem[_14008 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14578 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14578 + 68] = mem[idx + _14008 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14578 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14578 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11629] = 30
                    mem[_11629 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12012 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12012 + 68] = mem[idx + _11629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12012 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12012 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13474] = 30
                    mem[_13474 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14007 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14007 + 68] = mem[idx + _13474 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14007 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14007 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _15621 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15621] = 30
                    mem[_15621 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16129 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16129 + 68] = mem[idx + _15621 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16129 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16129 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9255 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9255] = 30
                    mem[_9255 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9325 + 68] = mem[idx + _9255 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9325 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9673] = 30
                    mem[_9673 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9735 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9735 + 68] = mem[idx + _9673 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9735 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9735 + -mem[64] + 100
                _9277 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9277] = 26
                mem[_9277 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9370 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9370 + 68] = mem[idx + _9277 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9370 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9370 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10379 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10379] = 30
                        mem[_10379 + 32] = 'SafeMath: subtraction overflow'
                        _11264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11264] = 30
                        mem[_11264 + 32] = 'SafeMath: subtraction overflow'
                        _13000 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13000] = 30
                        mem[_13000 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13478 + 68] = mem[idx + _13000 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13478 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10378 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10378] = 30
                        mem[_10378 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10501 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10501 + 68] = mem[idx + _10378 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10501 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10501 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11262] = 30
                        mem[_11262 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11632 + 68] = mem[idx + _11262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11632 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12998] = 30
                        mem[_12998 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13477 + 68] = mem[idx + _12998 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13477 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13477 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10947 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10947] = 30
                    mem[_10947 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11261 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11261 + 68] = mem[idx + _10947 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11261 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11261 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12481 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12481] = 30
                    mem[_12481 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12997 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12997 + 68] = mem[idx + _12481 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12997 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12997 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14589 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14589] = 30
                    mem[_14589 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15112 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15112 + 68] = mem[idx + _14589 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15112 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15112 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10377] = 30
                        mem[_10377 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10500 + 68] = mem[idx + _10377 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10500 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10500 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11259] = 30
                        mem[_11259 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11631 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11631 + 68] = mem[idx + _11259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11631 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11631 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12995] = 30
                        mem[_12995 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13476 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13476 + 68] = mem[idx + _12995 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13476 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13476 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10946 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10946] = 30
                    mem[_10946 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11258 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11258 + 68] = mem[idx + _10946 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11258 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11258 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12479 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12479] = 30
                    mem[_12479 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12994 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12994 + 68] = mem[idx + _12479 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12994 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12994 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14587] = 30
                    mem[_14587 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15110 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15110 + 68] = mem[idx + _14587 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15110 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15110 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10945 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10945] = 30
                    mem[_10945 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11257 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11257 + 68] = mem[idx + _10945 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11257 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11257 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12477 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12477] = 30
                    mem[_12477 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12993 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12993 + 68] = mem[idx + _12477 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12993 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12993 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14585] = 30
                    mem[_14585 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15109 + 68] = mem[idx + _14585 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15109 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15109 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12019 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12019] = 30
                mem[_12019 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12476 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12476 + 68] = mem[idx + _12019 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12476 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12476 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _14015 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14015] = 30
                mem[_14015 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14584 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14584 + 68] = mem[idx + _14015 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14584 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14584 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                _16133 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16133] = 30
                mem[_16133 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16501 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16501 + 68] = mem[idx + _16133 + 32]
                    idx = idx + 32
                    continue 
                mem[_16501 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16501 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor14 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor14 / arg1 != stor14:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor13 / 100 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor9
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _9194 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9194] = 26
                    mem[_9194 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9273 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9273 + 68] = mem[idx + _9194 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9273 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9273 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10204 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10204] = 30
                            mem[_10204 + 32] = 'SafeMath: subtraction overflow'
                            _10926 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10926] = 30
                            mem[_10926 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11239 + 68] = mem[idx + _10926 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11239 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11239 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12451] = 30
                            mem[_12451 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12978 + 68] = mem[idx + _12451 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12978 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12978 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10203] = 30
                            mem[_10203 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10367 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10367 + 68] = mem[idx + _10203 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10367 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10367 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10924 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10924] = 30
                            mem[_10924 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11238 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11238 + 68] = mem[idx + _10924 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11238 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11238 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12449] = 30
                            mem[_12449 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12977 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12977 + 68] = mem[idx + _12449 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12977 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12977 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10672] = 30
                        mem[_10672 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10923 + 68] = mem[idx + _10672 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10923 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11993] = 30
                        mem[_11993 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12448 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12448 + 68] = mem[idx + _11993 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12448 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12448 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13986] = 30
                        mem[_13986 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14561 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14561 + 68] = mem[idx + _13986 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14561 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14561 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10201] = 30
                            mem[_10201 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10366 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10366 + 68] = mem[idx + _10201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10366 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10366 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10921 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10921] = 30
                            mem[_10921 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11237 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11237 + 68] = mem[idx + _10921 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11237 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11237 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12446] = 30
                            mem[_12446 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _12976 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12976 + 68] = mem[idx + _12446 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12976 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12976 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10671] = 30
                        mem[_10671 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10920 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10920 + 68] = mem[idx + _10671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10920 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10920 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11991 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11991] = 30
                        mem[_11991 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12445 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12445 + 68] = mem[idx + _11991 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12445 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12445 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13984] = 30
                        mem[_13984 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14559 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14559 + 68] = mem[idx + _13984 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14559 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14559 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10670 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10670] = 30
                        mem[_10670 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10919 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10919 + 68] = mem[idx + _10670 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10919 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10919 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11989 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11989] = 30
                        mem[_11989 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12444 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12444 + 68] = mem[idx + _11989 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12444 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12444 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _13982 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13982] = 30
                        mem[_13982 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14558 + 68] = mem[idx + _13982 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14558 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14558 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11618 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11618] = 30
                    mem[_11618 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11988 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11988 + 68] = mem[idx + _11618 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11988 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11988 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13455 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13455] = 30
                    mem[_13455 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13981 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13981 + 68] = mem[idx + _13455 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13981 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13981 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15600] = 30
                    mem[_15600 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16108 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16108 + 68] = mem[idx + _15600 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16108 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16108 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _9254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9254] = 30
                    mem[_9254 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _9322 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9322 + 68] = mem[idx + _9254 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9322 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9322 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _9671 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9671] = 30
                    mem[_9671 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _9734 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9734 + 68] = mem[idx + _9671 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9734 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9734 + -mem[64] + 100
                _9274 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9274] = 26
                mem[_9274 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9368 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9368 + 68] = mem[idx + _9274 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9368 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9368 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10373 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10373] = 30
                        mem[_10373 + 32] = 'SafeMath: subtraction overflow'
                        _11248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11248] = 30
                        mem[_11248 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11621 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11621 + 68] = mem[idx + _11248 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11621 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11621 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12986] = 30
                        mem[_12986 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13459 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13459 + 68] = mem[idx + _12986 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13459 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13459 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10372 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10372] = 30
                        mem[_10372 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10494 + 68] = mem[idx + _10372 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10494 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10494 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11246] = 30
                        mem[_11246 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11620 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11620 + 68] = mem[idx + _11246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11620 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11620 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12984] = 30
                        mem[_12984 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13458 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13458 + 68] = mem[idx + _12984 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13458 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13458 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10930 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10930] = 30
                    mem[_10930 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11245 + 68] = mem[idx + _10930 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11245 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11245 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12458] = 30
                    mem[_12458 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12983 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12983 + 68] = mem[idx + _12458 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12983 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12983 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14569] = 30
                    mem[_14569 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15102 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15102 + 68] = mem[idx + _14569 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15102 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15102 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        _10370 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10370] = 30
                        mem[_10370 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10493 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10493 + 68] = mem[idx + _10370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10493 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10493 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11243 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11243] = 30
                        mem[_11243 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11619 + 68] = mem[idx + _11243 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11619 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11619 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12981 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12981] = 30
                        mem[_12981 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13457 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13457 + 68] = mem[idx + _12981 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13457 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13457 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10929 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10929] = 30
                    mem[_10929 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11242 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11242 + 68] = mem[idx + _10929 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11242 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11242 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12456 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12456] = 30
                    mem[_12456 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12980 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12980 + 68] = mem[idx + _12456 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12980 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12980 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14567 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14567] = 30
                    mem[_14567 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15100 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15100 + 68] = mem[idx + _14567 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15100 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15100 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    _10928 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10928] = 30
                    mem[_10928 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11241 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11241 + 68] = mem[idx + _10928 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11241 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11241 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12454] = 30
                    mem[_12454 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12979 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12979 + 68] = mem[idx + _12454 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12979 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12979 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14565 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14565] = 30
                    mem[_14565 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15099 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15099 + 68] = mem[idx + _14565 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15099 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15099 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _11995 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11995] = 30
                mem[_11995 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12453 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12453 + 68] = mem[idx + _11995 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12453 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12453 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13989 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13989] = 30
                mem[_13989 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14564 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14564 + 68] = mem[idx + _13989 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14564 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14564 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16112 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16112] = 30
                mem[_16112 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16497 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16497 + 68] = mem[idx + _16112 + 32]
                    idx = idx + 32
                    continue 
                mem[_16497 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16497 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor9 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        return 0
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor15 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor15 / arg1 != stor15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * stor13 / 100 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * stor13 / 100 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor9
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _9190 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9190] = 26
                mem[_9190 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9270 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9270 + 68] = mem[idx + _9190 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9270 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9270 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10192] = 30
                            mem[_10192 + 32] = 'SafeMath: subtraction overflow'
                            _10905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10905] = 30
                            mem[_10905 + 32] = 'SafeMath: subtraction overflow'
                            _12420 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12420] = 30
                            mem[_12420 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                            _12959 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12959 + 68] = mem[idx + _12420 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12959 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12959 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10191 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10191] = 30
                            mem[_10191 + 32] = 'SafeMath: subtraction overflow'
                            _10904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10904] = 30
                            mem[_10904 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11224 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11224 + 68] = mem[idx + _10904 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11224 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11224 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12418] = 30
                            mem[_12418 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                            _12958 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12958 + 68] = mem[idx + _12418 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12958 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12958 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10655] = 30
                        mem[_10655 + 32] = 'SafeMath: subtraction overflow'
                        _11967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11967] = 30
                        mem[_11967 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _12417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12417 + 68] = mem[idx + _11967 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12417 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12417 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13951] = 30
                        mem[_13951 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14532 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14532 + 68] = mem[idx + _13951 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14532 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14532 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10190 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10190] = 30
                            mem[_10190 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10358 + 68] = mem[idx + _10190 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10358 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _10902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10902] = 30
                            mem[_10902 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11223 + 68] = mem[idx + _10902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11223 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11223 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12415 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12415] = 30
                            mem[_12415 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                            _12957 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12957 + 68] = mem[idx + _12415 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12957 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12957 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10654 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10654] = 30
                        mem[_10654 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10901 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10901 + 68] = mem[idx + _10654 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10901 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10901 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11965] = 30
                        mem[_11965 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12414 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12414 + 68] = mem[idx + _11965 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12414 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12414 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13949] = 30
                        mem[_13949 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14530 + 68] = mem[idx + _13949 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14530 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14530 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10653] = 30
                        mem[_10653 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10900 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10900 + 68] = mem[idx + _10653 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10900 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10900 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11963 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11963] = 30
                        mem[_11963 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _12413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12413 + 68] = mem[idx + _11963 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12413 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12413 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13947 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13947] = 30
                        mem[_13947 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14529 + 68] = mem[idx + _13947 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14529 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14529 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11602] = 30
                    mem[_11602 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11962 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11962 + 68] = mem[idx + _11602 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11962 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11962 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13434] = 30
                    mem[_13434 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _13946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13946 + 68] = mem[idx + _13434 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13946 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13946 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15577 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15577] = 30
                    mem[_15577 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16079 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16079 + 68] = mem[idx + _15577 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16079 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16079 + -mem[64] + 100
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10188] = 30
                            mem[_10188 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10357 + 68] = mem[idx + _10188 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10357 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10357 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _10898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10898] = 30
                            mem[_10898 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11221 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11221 + 68] = mem[idx + _10898 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11221 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11221 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12411] = 30
                            mem[_12411 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _12956 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12956 + 68] = mem[idx + _12411 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12956 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12956 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10652] = 30
                        mem[_10652 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10897 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10897 + 68] = mem[idx + _10652 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10897 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10897 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11960 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11960] = 30
                        mem[_11960 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12410 + 68] = mem[idx + _11960 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12410 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12410 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13944 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13944] = 30
                        mem[_13944 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                        _14527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14527 + 68] = mem[idx + _13944 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14527 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14527 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10651 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10651] = 30
                        mem[_10651 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10896 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10896 + 68] = mem[idx + _10651 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10896 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10896 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11958 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11958] = 30
                        mem[_11958 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12409 + 68] = mem[idx + _11958 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12409 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13942] = 30
                        mem[_13942 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                        _14526 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14526 + 68] = mem[idx + _13942 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14526 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14526 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11601 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11601] = 30
                    mem[_11601 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11957 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11957 + 68] = mem[idx + _11601 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11957 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11957 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13432] = 30
                    mem[_13432 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13941 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13941 + 68] = mem[idx + _13432 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13941 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13941 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15574 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15574] = 30
                    mem[_15574 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16076 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16076 + 68] = mem[idx + _15574 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16076 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16076 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10650 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10650] = 30
                        mem[_10650 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _10895 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10895 + 68] = mem[idx + _10650 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10895 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10895 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11955 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11955] = 30
                        mem[_11955 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12408 + 68] = mem[idx + _11955 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12408 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _13939 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13939] = 30
                        mem[_13939 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                        _14525 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14525 + 68] = mem[idx + _13939 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14525 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14525 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11600] = 30
                    mem[_11600 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11954 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11954 + 68] = mem[idx + _11600 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11954 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11954 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13430 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13430] = 30
                    mem[_13430 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13938 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13938 + 68] = mem[idx + _13430 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13938 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13938 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _15572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15572] = 30
                    mem[_15572 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _16074 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16074 + 68] = mem[idx + _15572 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16074 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16074 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _11599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11599] = 30
                    mem[_11599 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11953 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11953 + 68] = mem[idx + _11599 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11953 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11953 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _13428 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13428] = 30
                    mem[_13428 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13937 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13937 + 68] = mem[idx + _13428 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13937 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13937 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15570] = 30
                    mem[_15570 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _16073 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16073 + 68] = mem[idx + _15570 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16073 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16073 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12955 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12955] = 30
                mem[_12955 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _13427 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13427 + 68] = mem[idx + _12955 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13427 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13427 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _15083 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15083] = 30
                mem[_15083 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _15569 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15569 + 68] = mem[idx + _15083 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15569 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15569 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16815 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16815] = 30
                mem[_16815 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _17131 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _17131 + 68] = mem[idx + _16815 + 32]
                    idx = idx + 32
                    continue 
                mem[_17131 + 98] = 0
                revert with memory
                  from mem[64]
                   len _17131 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] <= s:
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 1
                _9253 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9253] = 30
                mem[_9253 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor6[idx]] > t:
                    _9319 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9319 + 68] = mem[idx + _9253 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9319 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9319 + -mem[64] + 100
                if t < stor1[stor6[idx]]:
                    revert with 0, 17
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                _9669 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9669] = 30
                mem[_9669 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor6[idx]] <= s:
                    if s < stor2[stor6[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor6[idx]]
                    t = t - stor1[stor6[idx]]
                    continue 
                _9733 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _9733 + 68] = mem[idx + _9669 + 32]
                    idx = idx + 32
                    continue 
                mem[_9733 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9733 + -mem[64] + 100
            _9271 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9271] = 26
            mem[_9271 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _9366 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _9366 + 68] = mem[idx + _9271 + 32]
                    idx = idx + 32
                    continue 
                mem[_9366 + 94] = 0
                revert with memory
                  from mem[64]
                   len _9366 + -mem[64] + 100
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10365] = 30
                        mem[_10365 + 32] = 'SafeMath: subtraction overflow'
                        _11236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11236] = 30
                        mem[_11236 + 32] = 'SafeMath: subtraction overflow'
                        _12973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12973] = 30
                        mem[_12973 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                        _13440 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13440 + 68] = mem[idx + _12973 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13440 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13440 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10364] = 30
                        mem[_10364 + 32] = 'SafeMath: subtraction overflow'
                        _11235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11235] = 30
                        mem[_11235 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11608 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11608 + 68] = mem[idx + _11235 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11608 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11608 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12971] = 30
                        mem[_12971 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                        _13439 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13439 + 68] = mem[idx + _12971 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13439 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13439 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10912 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10912] = 30
                    mem[_10912 + 32] = 'SafeMath: subtraction overflow'
                    _12435 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12435] = 30
                    mem[_12435 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        _12970 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12970 + 68] = mem[idx + _12435 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12970 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12970 + -mem[64] + 100
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14549 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14549] = 30
                    mem[_14549 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15092 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15092 + 68] = mem[idx + _14549 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15092 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15092 + -mem[64] + 100
                if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10363] = 30
                        mem[_10363 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10491 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10491 + 68] = mem[idx + _10363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10491 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10491 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11233] = 30
                        mem[_11233 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11607 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11607 + 68] = mem[idx + _11233 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11607 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11607 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12968 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12968] = 30
                        mem[_12968 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                        _13438 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13438 + 68] = mem[idx + _12968 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13438 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13438 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10911 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10911] = 30
                    mem[_10911 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11232 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11232 + 68] = mem[idx + _10911 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11232 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11232 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12433 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12433] = 30
                    mem[_12433 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12967 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12967 + 68] = mem[idx + _12433 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12967 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12967 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14547] = 30
                    mem[_14547 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15090 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15090 + 68] = mem[idx + _14547 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15090 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15090 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10910 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10910] = 30
                    mem[_10910 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        _11231 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11231 + 68] = mem[idx + _10910 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11231 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11231 + -mem[64] + 100
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12431] = 30
                    mem[_12431 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        _12966 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12966 + 68] = mem[idx + _12431 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12966 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12966 + -mem[64] + 100
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14545 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14545] = 30
                    mem[_14545 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15089 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15089 + 68] = mem[idx + _14545 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15089 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15089 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _11971 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11971] = 30
                mem[_11971 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    _12430 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12430 + 68] = mem[idx + _11971 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12430 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12430 + -mem[64] + 100
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13961 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13961] = 30
                mem[_13961 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    _14544 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14544 + 68] = mem[idx + _13961 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14544 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14544 + -mem[64] + 100
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16091 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16091] = 30
                mem[_16091 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16493 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16493 + 68] = mem[idx + _16091 + 32]
                    idx = idx + 32
                    continue 
                mem[_16493 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16493 + -mem[64] + 100
            if arg1 and stor9 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        _10361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10361] = 30
                        mem[_10361 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10490 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10490 + 68] = mem[idx + _10361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10490 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10490 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11229] = 30
                        mem[_11229 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11605 + 68] = mem[idx + _11229 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11605 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12964 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12964] = 30
                        mem[_12964 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13437 + 68] = mem[idx + _12964 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13437 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13437 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10909 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10909] = 30
                    mem[_10909 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11228 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11228 + 68] = mem[idx + _10909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11228 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11228 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12428 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12428] = 30
                    mem[_12428 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12963 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12963 + 68] = mem[idx + _12428 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12963 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12963 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14542 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14542] = 30
                    mem[_14542 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                    _15087 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15087 + 68] = mem[idx + _14542 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15087 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15087 + -mem[64] + 100
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    _10908 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10908] = 30
                    mem[_10908 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11227 + 68] = mem[idx + _10908 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11227 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11227 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12426 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12426] = 30
                    mem[_12426 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12962 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12962 + 68] = mem[idx + _12426 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12962 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12962 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14540 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14540] = 30
                    mem[_14540 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                    _15086 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15086 + 68] = mem[idx + _14540 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15086 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15086 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _11970 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11970] = 30
                mem[_11970 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    _12425 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12425 + 68] = mem[idx + _11970 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12425 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12425 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                _13959 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13959] = 30
                mem[_13959 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _14539 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14539 + 68] = mem[idx + _13959 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14539 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14539 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16088 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16088] = 30
                mem[_16088 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16490 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16490 + 68] = mem[idx + _16088 + 32]
                    idx = idx + 32
                    continue 
                mem[_16490 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16490 + -mem[64] + 100
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    _10907 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10907] = 30
                    mem[_10907 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11226 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11226 + 68] = mem[idx + _10907 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11226 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11226 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12423 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12423] = 30
                    mem[_12423 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _12961 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12961 + 68] = mem[idx + _12423 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12961 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12961 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14537 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14537] = 30
                    mem[_14537 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
                    _15085 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15085 + 68] = mem[idx + _14537 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15085 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15085 + -mem[64] + 100
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _11969 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11969] = 30
                mem[_11969 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12422 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12422 + 68] = mem[idx + _11969 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12422 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12422 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13957 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13957] = 30
                mem[_13957 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14536 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14536 + 68] = mem[idx + _13957 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14536 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14536 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                _16086 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16086] = 30
                mem[_16086 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
                _16488 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16488 + 68] = mem[idx + _16086 + 32]
                    idx = idx + 32
                    continue 
                mem[_16488 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16488 + -mem[64] + 100
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                _11968 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11968] = 30
                mem[_11968 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    _12421 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12421 + 68] = mem[idx + _11968 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12421 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12421 + -mem[64] + 100
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _13955 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13955] = 30
                mem[_13955 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    _14535 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14535 + 68] = mem[idx + _13955 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14535 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14535 + -mem[64] + 100
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                _16084 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16084] = 30
                mem[_16084 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
                _16487 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16487 + 68] = mem[idx + _16084 + 32]
                    idx = idx + 32
                    continue 
                mem[_16487 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16487 + -mem[64] + 100
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _13436 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13436] = 30
            mem[_13436 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                _13954 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _13954 + 68] = mem[idx + _13436 + 32]
                    idx = idx + 32
                    continue 
                mem[_13954 + 98] = 0
                revert with memory
                  from mem[64]
                   len _13954 + -mem[64] + 100
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            _15582 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15582] = 30
            mem[_15582 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                _16083 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16083 + 68] = mem[idx + _15582 + 32]
                    idx = idx + 32
                    continue 
                mem[_16083 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16083 + -mem[64] + 100
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            _17136 = mem[64]
            mem[64] = mem[64] + 64
            mem[_17136] = 30
            mem[_17136 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            _17315 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _17315 + 68] = mem[idx + _17136 + 32]
                idx = idx + 32
                continue 
            mem[_17315 + 98] = 0
            revert with memory
              from mem[64]
               len _17315 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor9 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor15 / 100 / 100 * t / s)
                    if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor14 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor13 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor13 / 100 / 100 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s))
                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s))
            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) - (arg1 * stor15 / 100 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * stor13 / 100 / 100:
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        return 0
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor15 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor14 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor13 / 100 / 100:
                revert with 0, 18
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 and stor9 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor13 / 100 / 100:
            if not arg1 * stor14 / 100 / 100:
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor9 / totalSupply)
                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                if not arg1 * stor15 / 100 / 100:
                    revert with 0, 18
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor14 / 100 / 100:
                revert with 0, 18
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor15 / 100 / 100:
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < 0:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor13 / 100 / 100:
            revert with 0, 18
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor14 / 100 / 100:
            if not arg1 * stor15 / 100 / 100:
                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply))
            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                revert with 0, 17
            if not arg1 * stor15 / 100 / 100:
                revert with 0, 18
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor14 / 100 / 100:
            revert with 0, 18
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor15 / 100 / 100:
            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply))
        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
            revert with 0, 17
        if not arg1 * stor15 / 100 / 100:
            revert with 0, 18
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor15 / 100 / 100 * stor9 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9250] = 26
                        mem[_9250 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9315 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9315 + 68] = mem[idx + _9250 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9315 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9315 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10304] = 30
                        mem[_10304 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10446 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10446 + 68] = mem[idx + _10304 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10446 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10446 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11103] = 30
                        mem[_11103 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11395 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11395 + 68] = mem[idx + _11103 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11395 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11395 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12699] = 30
                        mem[_12699 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13124 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13124 + 68] = mem[idx + _12699 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13124 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13124 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9268 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9268] = 30
                        mem[_9268 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9364 + 68] = mem[idx + _9268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9364 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9699] = 30
                        mem[_9699 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9748 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9748 + 68] = mem[idx + _9699 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9748 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9748 + -mem[64] + 100
                    _9316 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9316] = 26
                    mem[_9316 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9396 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9396 + 68] = mem[idx + _9316 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9396 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9396 + -mem[64] + 100
                    if not arg1:
                        return 0
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10448 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10448] = 30
                    mem[_10448 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _10555 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _10555 + 68] = mem[idx + _10448 + 32]
                            idx = idx + 32
                            continue 
                        mem[_10555 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10555 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _11397 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11397] = 30
                    mem[_11397 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11735 + 68] = mem[idx + _11397 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11735 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11735 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _13125 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13125] = 30
                    mem[_13125 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _13632 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13632 + 68] = mem[idx + _13125 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13632 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13632 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor9 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor9 / totalSupply < 0:
                    revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9246] = 26
                        mem[_9246 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9312 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9312 + 68] = mem[idx + _9246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9312 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9312 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10300] = 30
                            mem[_10300 + 32] = 'SafeMath: subtraction overflow'
                            _11097 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11097] = 30
                            mem[_11097 + 32] = 'SafeMath: subtraction overflow'
                            _12692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12692] = 30
                            mem[_12692 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13119 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13119 + 68] = mem[idx + _12692 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13119 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13119 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10299] = 30
                            mem[_10299 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10442 + 68] = mem[idx + _10299 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10442 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10442 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11095] = 30
                            mem[_11095 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11389 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11389 + 68] = mem[idx + _11095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11389 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11389 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12690] = 30
                            mem[_12690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13118 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13118 + 68] = mem[idx + _12690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13118 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13118 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10793] = 30
                        mem[_10793 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11094 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11094 + 68] = mem[idx + _10793 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11094 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11094 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12213 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12213] = 30
                        mem[_12213 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12689 + 68] = mem[idx + _12213 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12689 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14253] = 30
                        mem[_14253 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14767 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14767 + 68] = mem[idx + _14253 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14767 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14767 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9267] = 30
                        mem[_9267 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9361 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9361 + 68] = mem[idx + _9267 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9361 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9361 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9697] = 30
                        mem[_9697 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9747 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9747 + 68] = mem[idx + _9697 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9747 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9747 + -mem[64] + 100
                    _9313 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9313] = 26
                    mem[_9313 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9394 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9394 + 68] = mem[idx + _9313 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9394 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9394 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor15 / 100 / 100:
                            return 0
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10445 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10445] = 30
                        mem[_10445 + 32] = 'SafeMath: subtraction overflow'
                        _11394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11394] = 30
                        mem[_11394 + 32] = 'SafeMath: subtraction overflow'
                        _13123 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13123] = 30
                        mem[_13123 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _13631 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13631 + 68] = mem[idx + _13123 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13631 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13631 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _10444 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10444] = 30
                        mem[_10444 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10553 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10553 + 68] = mem[idx + _10444 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10553 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10553 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11392] = 30
                        mem[_11392 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11733 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11733 + 68] = mem[idx + _11392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11733 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11733 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13121 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13121] = 30
                        mem[_13121 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13630 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13630 + 68] = mem[idx + _13121 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13630 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13630 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11098 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11098] = 30
                    mem[_11098 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11391 + 68] = mem[idx + _11098 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11391 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12693 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12693] = 30
                    mem[_12693 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _13120 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13120 + 68] = mem[idx + _12693 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13120 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13120 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14770 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14770] = 30
                    mem[_14770 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15201 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15201 + 68] = mem[idx + _14770 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15201 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15201 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor15 / 100 / 100:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor15 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9242 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9242] = 26
                        mem[_9242 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9309 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9309 + 68] = mem[idx + _9242 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9309 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9309 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10296 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10296] = 30
                            mem[_10296 + 32] = 'SafeMath: subtraction overflow'
                            _11088 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11088] = 30
                            mem[_11088 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11381 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11381 + 68] = mem[idx + _11088 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11381 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11381 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12681] = 30
                            mem[_12681 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13112 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13112 + 68] = mem[idx + _12681 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13112 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13112 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10295] = 30
                            mem[_10295 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10437 + 68] = mem[idx + _10295 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10437 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11086] = 30
                            mem[_11086 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11380 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11380 + 68] = mem[idx + _11086 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11380 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11380 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12679 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12679] = 30
                            mem[_12679 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13111 + 68] = mem[idx + _12679 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13111 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13111 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10788] = 30
                        mem[_10788 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11085 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11085 + 68] = mem[idx + _10788 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11085 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11085 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12203 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12203] = 30
                        mem[_12203 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12678 + 68] = mem[idx + _12203 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12678 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12678 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14242 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14242] = 30
                        mem[_14242 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14757 + 68] = mem[idx + _14242 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14757 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14757 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9266 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9266] = 30
                        mem[_9266 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9358 + 68] = mem[idx + _9266 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9358 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9695] = 30
                        mem[_9695 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9746 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9746 + 68] = mem[idx + _9695 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9746 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9746 + -mem[64] + 100
                    _9310 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9310] = 26
                    mem[_9310 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9392 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9392 + 68] = mem[idx + _9310 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9392 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9392 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            return 0
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10441 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10441] = 30
                        mem[_10441 + 32] = 'SafeMath: subtraction overflow'
                        _11386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11386] = 30
                        mem[_11386 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _11729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11729 + 68] = mem[idx + _11386 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11729 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11729 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13116] = 30
                        mem[_13116 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13625 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13625 + 68] = mem[idx + _13116 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13625 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13625 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _10440 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10440] = 30
                        mem[_10440 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10548 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10548 + 68] = mem[idx + _10440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10548 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10548 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11384] = 30
                        mem[_11384 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11728 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11728 + 68] = mem[idx + _11384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11728 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11728 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13114] = 30
                        mem[_13114 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13624 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13624 + 68] = mem[idx + _13114 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13624 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13624 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11089 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11089] = 30
                    mem[_11089 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _11383 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11383 + 68] = mem[idx + _11089 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11383 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11383 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _12683 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12683] = 30
                    mem[_12683 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _13113 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13113 + 68] = mem[idx + _12683 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13113 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13113 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14760 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14760] = 30
                    mem[_14760 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15198 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15198 + 68] = mem[idx + _14760 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15198 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15198 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor14 / 100 / 100:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9238] = 26
                        mem[_9238 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9306 + 68] = mem[idx + _9238 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9306 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9306 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10288] = 30
                                mem[_10288 + 32] = 'SafeMath: subtraction overflow'
                                _11077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11077] = 30
                                mem[_11077 + 32] = 'SafeMath: subtraction overflow'
                                _12665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12665] = 30
                                mem[_12665 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13102 + 68] = mem[idx + _12665 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13102 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13102 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10287] = 30
                                mem[_10287 + 32] = 'SafeMath: subtraction overflow'
                                _11076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11076] = 30
                                mem[_11076 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11372 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11372 + 68] = mem[idx + _11076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11372 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11372 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12663] = 30
                                mem[_12663 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13101 + 68] = mem[idx + _12663 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13101 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13101 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10779] = 30
                            mem[_10779 + 32] = 'SafeMath: subtraction overflow'
                            _12193 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12193] = 30
                            mem[_12193 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _12662 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12662 + 68] = mem[idx + _12193 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12662 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12662 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14227 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14227] = 30
                            mem[_14227 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14742 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14742 + 68] = mem[idx + _14227 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14742 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14742 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10286 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10286] = 30
                                mem[_10286 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10431 + 68] = mem[idx + _10286 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10431 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10431 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11074] = 30
                                mem[_11074 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11371 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11371 + 68] = mem[idx + _11074 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11371 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11371 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12660 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12660] = 30
                                mem[_12660 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13100 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13100 + 68] = mem[idx + _12660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13100 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13100 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10778] = 30
                            mem[_10778 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11073 + 68] = mem[idx + _10778 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11073 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12191 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12191] = 30
                            mem[_12191 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12659 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12659 + 68] = mem[idx + _12191 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12659 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12659 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14225 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14225] = 30
                            mem[_14225 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14740 + 68] = mem[idx + _14225 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14740 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14740 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10777] = 30
                            mem[_10777 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11072 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11072 + 68] = mem[idx + _10777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11072 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11072 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12189] = 30
                            mem[_12189 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12658 + 68] = mem[idx + _12189 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12658 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12658 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14223 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14223] = 30
                            mem[_14223 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14739 + 68] = mem[idx + _14223 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14739 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14739 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11721] = 30
                        mem[_11721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12188 + 68] = mem[idx + _11721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12188 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12188 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13615] = 30
                        mem[_13615 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _14222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14222 + 68] = mem[idx + _13615 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14222 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15789] = 30
                        mem[_15789 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16295 + 68] = mem[idx + _15789 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16295 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16295 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9265 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9265] = 30
                        mem[_9265 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9355 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9355 + 68] = mem[idx + _9265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9355 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9355 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9693 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9693] = 30
                        mem[_9693 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9745 + 68] = mem[idx + _9693 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9745 + -mem[64] + 100
                    _9307 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9307] = 26
                    mem[_9307 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9390 + 68] = mem[idx + _9307 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9390 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9390 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10436] = 30
                            mem[_10436 + 32] = 'SafeMath: subtraction overflow'
                            _11379 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11379] = 30
                            mem[_11379 + 32] = 'SafeMath: subtraction overflow'
                            _13110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13110] = 30
                            mem[_13110 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13619 + 68] = mem[idx + _13110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13619 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13619 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10435] = 30
                            mem[_10435 + 32] = 'SafeMath: subtraction overflow'
                            _11378 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11378] = 30
                            mem[_11378 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11724 + 68] = mem[idx + _11378 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11724 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11724 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13108] = 30
                            mem[_13108 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13618 + 68] = mem[idx + _13108 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13618 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13618 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11080 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11080] = 30
                        mem[_11080 + 32] = 'SafeMath: subtraction overflow'
                        _12671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12671] = 30
                        mem[_12671 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                            _13107 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13107 + 68] = mem[idx + _12671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13107 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13107 + -mem[64] + 100
                        if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14750] = 30
                        mem[_14750 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15195 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15195 + 68] = mem[idx + _14750 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15195 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15195 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10434] = 30
                            mem[_10434 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10546 + 68] = mem[idx + _10434 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10546 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10546 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11376 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11376] = 30
                            mem[_11376 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11723 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11723 + 68] = mem[idx + _11376 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11723 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11723 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13105 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13105] = 30
                            mem[_13105 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13617 + 68] = mem[idx + _13105 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13617 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11079 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11079] = 30
                        mem[_11079 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11375 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11375 + 68] = mem[idx + _11079 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11375 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11375 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12669] = 30
                        mem[_12669 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13104 + 68] = mem[idx + _12669 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13104 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13104 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14748 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14748] = 30
                        mem[_14748 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15193 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15193 + 68] = mem[idx + _14748 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15193 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15193 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11078] = 30
                        mem[_11078 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11374 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11374 + 68] = mem[idx + _11078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11374 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11374 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12667 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12667] = 30
                        mem[_12667 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13103 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13103 + 68] = mem[idx + _12667 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13103 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13103 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14746 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14746] = 30
                        mem[_14746 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15192 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15192 + 68] = mem[idx + _14746 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15192 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15192 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12194 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12194] = 30
                    mem[_12194 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor9 / totalSupply:
                        _12666 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12666 + 68] = mem[idx + _12194 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12666 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12666 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    _14230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14230] = 30
                    mem[_14230 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14745 + 68] = mem[idx + _14230 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14745 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _16299 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16299] = 30
                    mem[_16299 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16535 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16535 + 68] = mem[idx + _16299 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16535 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16535 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor14 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
    else:
        if arg1 and stor13 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor13 / arg1 != stor13:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9234] = 26
                        mem[_9234 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9303 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9303 + 68] = mem[idx + _9234 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9303 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9303 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                return 0
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10280] = 30
                            mem[_10280 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10427 + 68] = mem[idx + _10280 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10427 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10427 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11065] = 30
                            mem[_11065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11359 + 68] = mem[idx + _11065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11359 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11359 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12646 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12646] = 30
                            mem[_12646 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13092 + 68] = mem[idx + _12646 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13092 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13092 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            _10279 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10279] = 30
                            mem[_10279 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10426 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10426 + 68] = mem[idx + _10279 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10426 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10426 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11063 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11063] = 30
                            mem[_11063 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11358 + 68] = mem[idx + _11063 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11358 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12644] = 30
                            mem[_12644 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13091 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13091 + 68] = mem[idx + _12644 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13091 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13091 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10768] = 30
                        mem[_10768 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11062 + 68] = mem[idx + _10768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11062 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11062 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12174 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12174] = 30
                        mem[_12174 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _12643 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12643 + 68] = mem[idx + _12174 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12643 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12643 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14203 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14203] = 30
                        mem[_14203 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _14727 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14727 + 68] = mem[idx + _14203 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14727 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14727 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9264] = 30
                        mem[_9264 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9352 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9352 + 68] = mem[idx + _9264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9352 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9352 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9691] = 30
                        mem[_9691 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9744 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9744 + 68] = mem[idx + _9691 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9744 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9744 + -mem[64] + 100
                    _9304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9304] = 26
                    mem[_9304 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9388 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9388 + 68] = mem[idx + _9304 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9388 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9388 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            return 0
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10430] = 30
                        mem[_10430 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _10540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10540 + 68] = mem[idx + _10430 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10540 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _11364 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11364] = 30
                        mem[_11364 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _11713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11713 + 68] = mem[idx + _11364 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11713 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11713 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13096] = 30
                        mem[_13096 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13602 + 68] = mem[idx + _13096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13602 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13602 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        _10429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10429] = 30
                        mem[_10429 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _10539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10539 + 68] = mem[idx + _10429 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10539 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10539 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _11362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11362] = 30
                        mem[_11362 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11712 + 68] = mem[idx + _11362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11712 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11712 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _13094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13094] = 30
                        mem[_13094 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _13601 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13601 + 68] = mem[idx + _13094 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13601 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13601 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11067 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11067] = 30
                    mem[_11067 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _11361 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11361 + 68] = mem[idx + _11067 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11361 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11361 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _12648 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12648] = 30
                    mem[_12648 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _13093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13093 + 68] = mem[idx + _12648 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13093 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _14730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14730] = 30
                    mem[_14730 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _15185 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15185 + 68] = mem[idx + _14730 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15185 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15185 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor13 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor13 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < 0:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9230 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9230] = 26
                        mem[_9230 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9300 + 68] = mem[idx + _9230 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9300 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9300 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10273] = 30
                                mem[_10273 + 32] = 'SafeMath: subtraction overflow'
                                _11052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11052] = 30
                                mem[_11052 + 32] = 'SafeMath: subtraction overflow'
                                _12629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12629] = 30
                                mem[_12629 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13082 + 68] = mem[idx + _12629 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13082 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10272] = 30
                                mem[_10272 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10421 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10421 + 68] = mem[idx + _10272 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10421 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10421 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11050 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11050] = 30
                                mem[_11050 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11348 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11348 + 68] = mem[idx + _11050 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11348 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11348 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12627] = 30
                                mem[_12627 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13081 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13081 + 68] = mem[idx + _12627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13081 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13081 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10761] = 30
                            mem[_10761 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11049 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11049 + 68] = mem[idx + _10761 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11049 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11049 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12161 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12161] = 30
                            mem[_12161 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12626 + 68] = mem[idx + _12161 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12626 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12626 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14188] = 30
                            mem[_14188 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14712 + 68] = mem[idx + _14188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14712 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14712 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10271] = 30
                                mem[_10271 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10420 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10420 + 68] = mem[idx + _10271 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10420 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10420 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11047] = 30
                                mem[_11047 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11347 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11347 + 68] = mem[idx + _11047 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11347 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11347 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12624 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12624] = 30
                                mem[_12624 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13080 + 68] = mem[idx + _12624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13080 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13080 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10760] = 30
                            mem[_10760 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11046 + 68] = mem[idx + _10760 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11046 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12159] = 30
                            mem[_12159 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12623 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12623 + 68] = mem[idx + _12159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12623 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12623 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14186 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14186] = 30
                            mem[_14186 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14710 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14710 + 68] = mem[idx + _14186 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14710 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14710 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10759] = 30
                            mem[_10759 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11045 + 68] = mem[idx + _10759 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11045 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11045 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12157] = 30
                            mem[_12157 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12622 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12622 + 68] = mem[idx + _12157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12622 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12622 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14184 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14184] = 30
                            mem[_14184 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14709 + 68] = mem[idx + _14184 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14709 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14709 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11705 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11705] = 30
                        mem[_11705 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12156 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12156 + 68] = mem[idx + _11705 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12156 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12156 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13592] = 30
                        mem[_13592 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14183 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14183 + 68] = mem[idx + _13592 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14183 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14183 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _15760 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15760] = 30
                        mem[_15760 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16265 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16265 + 68] = mem[idx + _15760 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16265 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16265 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9263 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9263] = 30
                        mem[_9263 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9349 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9349 + 68] = mem[idx + _9263 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9349 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9349 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9689] = 30
                        mem[_9689 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9743 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9743 + 68] = mem[idx + _9689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9743 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9743 + -mem[64] + 100
                    _9301 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9301] = 26
                    mem[_9301 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9386 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9386 + 68] = mem[idx + _9301 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9386 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9386 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                return 0
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10425 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10425] = 30
                            mem[_10425 + 32] = 'SafeMath: subtraction overflow'
                            _11357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11357] = 30
                            mem[_11357 + 32] = 'SafeMath: subtraction overflow'
                            _13090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13090] = 30
                            mem[_13090 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13596 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13596 + 68] = mem[idx + _13090 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13596 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13596 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _10424 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10424] = 30
                            mem[_10424 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10537 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10537 + 68] = mem[idx + _10424 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10537 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10537 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11355] = 30
                            mem[_11355 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11708 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11708 + 68] = mem[idx + _11355 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11708 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11708 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13088 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13088] = 30
                            mem[_13088 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13595 + 68] = mem[idx + _13088 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13595 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13595 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11055] = 30
                        mem[_11055 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11354 + 68] = mem[idx + _11055 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11354 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12635 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12635] = 30
                        mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13087 + 68] = mem[idx + _12635 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13087 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13087 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14720] = 30
                        mem[_14720 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15182 + 68] = mem[idx + _14720 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15182 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15182 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _10423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10423] = 30
                            mem[_10423 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10536 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10536 + 68] = mem[idx + _10423 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10536 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10536 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11352 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11352] = 30
                            mem[_11352 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11707 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11707 + 68] = mem[idx + _11352 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11707 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11707 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13085] = 30
                            mem[_13085 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13594 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13594 + 68] = mem[idx + _13085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13594 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13594 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11054] = 30
                        mem[_11054 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11351 + 68] = mem[idx + _11054 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11351 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11351 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12633 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12633] = 30
                        mem[_12633 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _13084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13084 + 68] = mem[idx + _12633 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13084 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13084 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14718] = 30
                        mem[_14718 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15180 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15180 + 68] = mem[idx + _14718 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15180 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15180 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _11053 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11053] = 30
                        mem[_11053 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11350 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11350 + 68] = mem[idx + _11053 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11350 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11350 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12631] = 30
                        mem[_12631 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13083 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13083 + 68] = mem[idx + _12631 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13083 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13083 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14716 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14716] = 30
                        mem[_14716 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15179 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15179 + 68] = mem[idx + _14716 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15179 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15179 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12163 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12163] = 30
                    mem[_12163 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12630 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12630 + 68] = mem[idx + _12163 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12630 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12630 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14191 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14191] = 30
                    mem[_14191 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14715 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14715 + 68] = mem[idx + _14191 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14715 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14715 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                        revert with 0, 17
                    _16269 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16269] = 30
                    mem[_16269 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16530 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16530 + 68] = mem[idx + _16269 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16530 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16530 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor15 / 100 / 100:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor15 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
        else:
            if arg1 and stor14 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / arg1 != stor14:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9226] = 26
                        mem[_9226 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9297 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9297 + 68] = mem[idx + _9226 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9297 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9297 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    return 0
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10266] = 30
                                mem[_10266 + 32] = 'SafeMath: subtraction overflow'
                                _11034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11034] = 30
                                mem[_11034 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11332 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11332 + 68] = mem[idx + _11034 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11332 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11332 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12605 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12605] = 30
                                mem[_12605 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13068 + 68] = mem[idx + _12605 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13068 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13068 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                _10265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10265] = 30
                                mem[_10265 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10413 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10413 + 68] = mem[idx + _10265 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10413 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10413 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11032] = 30
                                mem[_11032 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11331 + 68] = mem[idx + _11032 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11331 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11331 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12603] = 30
                                mem[_12603 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13067 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13067 + 68] = mem[idx + _12603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13067 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13067 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10752] = 30
                            mem[_10752 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11031 + 68] = mem[idx + _10752 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11031 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11031 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12137] = 30
                            mem[_12137 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _12602 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12602 + 68] = mem[idx + _12137 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12602 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12602 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14162 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14162] = 30
                            mem[_14162 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14692 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14692 + 68] = mem[idx + _14162 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14692 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14692 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                _10263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10263] = 30
                                mem[_10263 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10412 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10412 + 68] = mem[idx + _10263 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10412 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10412 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11029] = 30
                                mem[_11029 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11330 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11330 + 68] = mem[idx + _11029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11330 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11330 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12600] = 30
                                mem[_12600 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13066 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13066 + 68] = mem[idx + _12600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13066 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13066 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10751] = 30
                            mem[_10751 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11028 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11028 + 68] = mem[idx + _10751 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11028 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11028 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12135] = 30
                            mem[_12135 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12599 + 68] = mem[idx + _12135 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12599 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14160] = 30
                            mem[_14160 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14690 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14690 + 68] = mem[idx + _14160 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14690 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14690 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10750] = 30
                            mem[_10750 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11027 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11027 + 68] = mem[idx + _10750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11027 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11027 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12133] = 30
                            mem[_12133 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _12598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12598 + 68] = mem[idx + _12133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12598 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14158] = 30
                            mem[_14158 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _14689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14689 + 68] = mem[idx + _14158 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14689 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11694 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11694] = 30
                        mem[_11694 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12132 + 68] = mem[idx + _11694 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12132 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _13573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13573] = 30
                        mem[_13573 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14157 + 68] = mem[idx + _13573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14157 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14157 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15739] = 30
                        mem[_15739 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16244 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16244 + 68] = mem[idx + _15739 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16244 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16244 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9262] = 30
                        mem[_9262 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9346 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9346 + 68] = mem[idx + _9262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9346 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9346 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9687 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9687] = 30
                        mem[_9687 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9742 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9742 + 68] = mem[idx + _9687 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9742 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9742 + -mem[64] + 100
                    _9298 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9298] = 26
                    mem[_9298 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9384 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9384 + 68] = mem[idx + _9298 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9384 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9384 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                return 0
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10419] = 30
                            mem[_10419 + 32] = 'SafeMath: subtraction overflow'
                            _11341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11341] = 30
                            mem[_11341 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _11697 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11697 + 68] = mem[idx + _11341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11697 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11697 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13076] = 30
                            mem[_13076 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13577 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13577 + 68] = mem[idx + _13076 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13577 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13577 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            _10418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10418] = 30
                            mem[_10418 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _10530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10530 + 68] = mem[idx + _10418 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10530 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10530 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _11339 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11339] = 30
                            mem[_11339 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _11696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11696 + 68] = mem[idx + _11339 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11696 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13074 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13074] = 30
                            mem[_13074 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13576 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13576 + 68] = mem[idx + _13074 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13576 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13576 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11038] = 30
                        mem[_11038 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _11338 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11338 + 68] = mem[idx + _11038 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11338 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11338 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12612] = 30
                        mem[_12612 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _13073 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13073 + 68] = mem[idx + _12612 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13073 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13073 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14700] = 30
                        mem[_14700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _15172 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15172 + 68] = mem[idx + _14700 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15172 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15172 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            _10416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10416] = 30
                            mem[_10416 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _10529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10529 + 68] = mem[idx + _10416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10529 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10529 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _11336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11336] = 30
                            mem[_11336 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11695 + 68] = mem[idx + _11336 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11695 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13071 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13071] = 30
                            mem[_13071 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _13575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13575 + 68] = mem[idx + _13071 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13575 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11037] = 30
                        mem[_11037 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _11335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11335 + 68] = mem[idx + _11037 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11335 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11335 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _12610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12610] = 30
                        mem[_12610 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13070 + 68] = mem[idx + _12610 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13070 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13070 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14698] = 30
                        mem[_14698 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15170 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15170 + 68] = mem[idx + _14698 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15170 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15170 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        _11036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11036] = 30
                        mem[_11036 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _11334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11334 + 68] = mem[idx + _11036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11334 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _12608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12608] = 30
                        mem[_12608 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _13069 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13069 + 68] = mem[idx + _12608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13069 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13069 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _14696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14696] = 30
                        mem[_14696 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _15169 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15169 + 68] = mem[idx + _14696 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15169 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15169 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12139 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12139] = 30
                    mem[_12139 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _12607 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12607 + 68] = mem[idx + _12139 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12607 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12607 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _14165 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14165] = 30
                    mem[_14165 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _14695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14695 + 68] = mem[idx + _14165 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14695 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14695 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _16248 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16248] = 30
                    mem[_16248 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _16526 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16526 + 68] = mem[idx + _16248 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16526 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16526 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if arg1 * stor14 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if arg1 * stor14 / 100 / 100:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
            else:
                if arg1 and stor15 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / arg1 != stor15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor13 / 100 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor13 / 100 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * stor14 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) < arg1 * stor14 / 100 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * stor15 / 100 / 100 > arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor13 / 100 / 100) - (arg1 * stor14 / 100 / 100) < arg1 * stor15 / 100 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor9
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _9222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9222] = 26
                        mem[_9222 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9294 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9294 + 68] = mem[idx + _9222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9294 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9294 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor13 / 100 / 100:
                                if not arg1 * stor14 / 100 / 100:
                                    if not arg1 * stor15 / 100 / 100:
                                        return 0
                                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _10254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10254] = 30
                                    mem[_10254 + 32] = 'SafeMath: subtraction overflow'
                                    _11013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11013] = 30
                                    mem[_11013 + 32] = 'SafeMath: subtraction overflow'
                                    _12574 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12574] = 30
                                    mem[_12574 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                        if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13049 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13049 + 68] = mem[idx + _12574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13049 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13049 + -mem[64] + 100
                                if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    _10253 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10253] = 30
                                    mem[_10253 + 32] = 'SafeMath: subtraction overflow'
                                    _11012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11012] = 30
                                    mem[_11012 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                        _11317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11317 + 68] = mem[idx + _11012 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11317 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11317 + -mem[64] + 100
                                    if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    _12572 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12572] = 30
                                    mem[_12572 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13048 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13048 + 68] = mem[idx + _12572 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13048 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13048 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10735 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10735] = 30
                                mem[_10735 + 32] = 'SafeMath: subtraction overflow'
                                _12111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12111] = 30
                                mem[_12111 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _12571 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12571 + 68] = mem[idx + _12111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12571 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12571 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14127] = 30
                                mem[_14127 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14663 + 68] = mem[idx + _14127 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14663 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14663 + -mem[64] + 100
                            if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10252 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10252] = 30
                                    mem[_10252 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                        _10404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10404 + 68] = mem[idx + _10252 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10404 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10404 + -mem[64] + 100
                                    if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    _11010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11010] = 30
                                    mem[_11010 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        _11316 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11316 + 68] = mem[idx + _11010 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11316 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11316 + -mem[64] + 100
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _12569 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12569] = 30
                                    mem[_12569 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13047 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13047 + 68] = mem[idx + _12569 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13047 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13047 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10734] = 30
                                mem[_10734 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11009 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11009 + 68] = mem[idx + _10734 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11009 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11009 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12109 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12109] = 30
                                mem[_12109 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12568 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12568 + 68] = mem[idx + _12109 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12568 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12568 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _14125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14125] = 30
                                mem[_14125 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14661 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14661 + 68] = mem[idx + _14125 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14661 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14661 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10733] = 30
                                mem[_10733 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11008 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11008 + 68] = mem[idx + _10733 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11008 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11008 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12107] = 30
                                mem[_12107 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _12567 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12567 + 68] = mem[idx + _12107 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12567 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12567 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14123] = 30
                                mem[_14123 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14660 + 68] = mem[idx + _14123 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14660 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14660 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11678] = 30
                            mem[_11678 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _12106 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12106 + 68] = mem[idx + _11678 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12106 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12106 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13552 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13552] = 30
                            mem[_13552 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _14122 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14122 + 68] = mem[idx + _13552 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14122 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14122 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15716] = 30
                            mem[_15716 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16215 + 68] = mem[idx + _15716 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16215 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16215 + -mem[64] + 100
                        if arg1 and stor9 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    _10250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10250] = 30
                                    mem[_10250 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _10403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10403 + 68] = mem[idx + _10250 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10403 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10403 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _11006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11006] = 30
                                    mem[_11006 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor9 / totalSupply:
                                        _11314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11314 + 68] = mem[idx + _11006 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11314 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11314 + -mem[64] + 100
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    _12565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12565] = 30
                                    mem[_12565 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor9 / totalSupply:
                                        if arg1 * stor9 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor9 / totalSupply)
                                    _13046 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13046 + 68] = mem[idx + _12565 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13046 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13046 + -mem[64] + 100
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10732] = 30
                                mem[_10732 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11005 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11005 + 68] = mem[idx + _10732 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11005 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11005 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12104] = 30
                                mem[_12104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _12564 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12564 + 68] = mem[idx + _12104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12564 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12564 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _14120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14120] = 30
                                mem[_14120 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14658 + 68] = mem[idx + _14120 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14658 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14658 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10731] = 30
                                mem[_10731 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11004 + 68] = mem[idx + _10731 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11004 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11004 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _12102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12102] = 30
                                mem[_12102 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _12563 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12563 + 68] = mem[idx + _12102 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12563 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12563 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _14118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14118] = 30
                                mem[_14118 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14657 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14657 + 68] = mem[idx + _14118 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14657 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14657 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11677] = 30
                            mem[_11677 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _12101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12101 + 68] = mem[idx + _11677 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12101 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12101 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _13550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13550] = 30
                            mem[_13550 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _14117 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14117 + 68] = mem[idx + _13550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14117 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14117 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15713 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15713] = 30
                            mem[_15713 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16212 + 68] = mem[idx + _15713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16212 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16212 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10730] = 30
                                mem[_10730 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                    _11003 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11003 + 68] = mem[idx + _10730 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11003 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11003 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _12099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12099] = 30
                                mem[_12099 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    _12562 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12562 + 68] = mem[idx + _12099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12562 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12562 + -mem[64] + 100
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                _14115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14115] = 30
                                mem[_14115 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _14656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14656 + 68] = mem[idx + _14115 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14656 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11676] = 30
                            mem[_11676 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12098 + 68] = mem[idx + _11676 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12098 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12098 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13548] = 30
                            mem[_13548 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14114 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14114 + 68] = mem[idx + _13548 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14114 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14114 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _15711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15711] = 30
                            mem[_15711 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16210 + 68] = mem[idx + _15711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16210 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16210 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11675 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11675] = 30
                            mem[_11675 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _12097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12097 + 68] = mem[idx + _11675 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12097 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _13546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13546] = 30
                            mem[_13546 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _14113 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14113 + 68] = mem[idx + _13546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14113 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14113 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _15709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15709] = 30
                            mem[_15709 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _16209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16209 + 68] = mem[idx + _15709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16209 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16209 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13045] = 30
                        mem[_13045 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _13545 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13545 + 68] = mem[idx + _13045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13545 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13545 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _15153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15153] = 30
                        mem[_15153 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _15708 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15708 + 68] = mem[idx + _15153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15708 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15708 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16905] = 30
                        mem[_16905 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _17209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17209 + 68] = mem[idx + _16905 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17209 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17209 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _9261 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9261] = 30
                        mem[_9261 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _9343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9343 + 68] = mem[idx + _9261 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9343 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9343 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _9685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9685] = 30
                        mem[_9685 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _9741 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9741 + 68] = mem[idx + _9685 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9741 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9741 + -mem[64] + 100
                    _9295 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9295] = 26
                    mem[_9295 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9382 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9382 + 68] = mem[idx + _9295 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9382 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9382 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    return 0
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10411] = 30
                                mem[_10411 + 32] = 'SafeMath: subtraction overflow'
                                _11329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11329] = 30
                                mem[_11329 + 32] = 'SafeMath: subtraction overflow'
                                _13063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13063] = 30
                                mem[_13063 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= 0:
                                    if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13558 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13558 + 68] = mem[idx + _13063 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13558 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13558 + -mem[64] + 100
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                _10410 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10410] = 30
                                mem[_10410 + 32] = 'SafeMath: subtraction overflow'
                                _11328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11328] = 30
                                mem[_11328 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    _11684 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11684 + 68] = mem[idx + _11328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11684 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11684 + -mem[64] + 100
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _13061 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13061] = 30
                                mem[_13061 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13557 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13557 + 68] = mem[idx + _13061 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13557 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13557 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11020 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11020] = 30
                            mem[_11020 + 32] = 'SafeMath: subtraction overflow'
                            _12589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12589] = 30
                            mem[_12589 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                _13060 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13060 + 68] = mem[idx + _12589 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13060 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13060 + -mem[64] + 100
                            if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14680] = 30
                            mem[_14680 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15162 + 68] = mem[idx + _14680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15162 + -mem[64] + 100
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10409] = 30
                                mem[_10409 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    _10527 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10527 + 68] = mem[idx + _10409 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10527 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10527 + -mem[64] + 100
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                _11326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11326] = 30
                                mem[_11326 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    _11683 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11683 + 68] = mem[idx + _11326 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11683 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11683 + -mem[64] + 100
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _13058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13058] = 30
                                mem[_13058 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13556 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13556 + 68] = mem[idx + _13058 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13556 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13556 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11019 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11019] = 30
                            mem[_11019 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11325 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11325 + 68] = mem[idx + _11019 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11325 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11325 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12587 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12587] = 30
                            mem[_12587 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13057 + 68] = mem[idx + _12587 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13057 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13057 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14678] = 30
                            mem[_14678 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15160 + 68] = mem[idx + _14678 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15160 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15160 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11018 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11018] = 30
                            mem[_11018 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                _11324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11324 + 68] = mem[idx + _11018 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11324 + -mem[64] + 100
                            if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12585] = 30
                            mem[_12585 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                _13056 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13056 + 68] = mem[idx + _12585 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13056 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13056 + -mem[64] + 100
                            if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14676] = 30
                            mem[_14676 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15159 + 68] = mem[idx + _14676 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15159 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15159 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12115 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12115] = 30
                        mem[_12115 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                            _12584 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12584 + 68] = mem[idx + _12115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12584 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12584 + -mem[64] + 100
                        if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14137] = 30
                        mem[_14137 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            _14675 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14675 + 68] = mem[idx + _14137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14675 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14675 + -mem[64] + 100
                        if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16227 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16227] = 30
                        mem[_16227 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _16522 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16522 + 68] = mem[idx + _16227 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16522 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16522 + -mem[64] + 100
                    if arg1 and stor9 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                _10407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10407] = 30
                                mem[_10407 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _10526 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10526 + 68] = mem[idx + _10407 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10526 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10526 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _11322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11322] = 30
                                mem[_11322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor9 / totalSupply:
                                    _11681 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11681 + 68] = mem[idx + _11322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11681 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11681 + -mem[64] + 100
                                if arg1 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                _13054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13054] = 30
                                mem[_13054 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor9 / totalSupply:
                                    if arg1 * stor9 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor9 / totalSupply)
                                _13555 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13555 + 68] = mem[idx + _13054 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13555 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13555 + -mem[64] + 100
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11017] = 30
                            mem[_11017 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11321 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11321 + 68] = mem[idx + _11017 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11321 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11321 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12582] = 30
                            mem[_12582 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _13053 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13053 + 68] = mem[idx + _12582 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13053 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13053 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _14673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14673] = 30
                            mem[_14673 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= arg1 * stor9 / totalSupply:
                                if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15157 + 68] = mem[idx + _14673 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15157 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15157 + -mem[64] + 100
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            _11016 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11016] = 30
                            mem[_11016 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                _11320 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11320 + 68] = mem[idx + _11016 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11320 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11320 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            _12580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12580] = 30
                            mem[_12580 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _13052 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13052 + 68] = mem[idx + _12580 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13052 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13052 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _14671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14671] = 30
                            mem[_14671 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15156 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15156 + 68] = mem[idx + _14671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15156 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15156 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12114] = 30
                        mem[_12114 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor9 / totalSupply:
                            _12579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12579 + 68] = mem[idx + _12114 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12579 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12579 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < 0:
                            revert with 0, 17
                        _14135 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14135] = 30
                        mem[_14135 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _14670 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14670 + 68] = mem[idx + _14135 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14670 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14670 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16224] = 30
                        mem[_16224 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16519 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16519 + 68] = mem[idx + _16224 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16519 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16519 + -mem[64] + 100
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            _11015 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11015] = 30
                            mem[_11015 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                _11319 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11319 + 68] = mem[idx + _11015 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11319 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11319 + -mem[64] + 100
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            _12577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12577] = 30
                            mem[_12577 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                _13051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13051 + 68] = mem[idx + _12577 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13051 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13051 + -mem[64] + 100
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            _14668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14668] = 30
                            mem[_14668 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor9 / totalSupply)
                            _15155 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15155 + 68] = mem[idx + _14668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15155 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15155 + -mem[64] + 100
                        if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor15 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12113 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12113] = 30
                        mem[_12113 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12576 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12576 + 68] = mem[idx + _12113 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12576 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12576 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14133] = 30
                        mem[_14133 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14667 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14667 + 68] = mem[idx + _14133 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14667 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14667 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                            revert with 0, 17
                        _16222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16222] = 30
                        mem[_16222 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16517 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16517 + 68] = mem[idx + _16222 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16517 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16517 + -mem[64] + 100
                    if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor14 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor15 / 100 / 100:
                        _12112 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12112] = 30
                        mem[_12112 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                            _12575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12575 + 68] = mem[idx + _12112 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12575 + -mem[64] + 100
                        if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _14131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14131] = 30
                        mem[_14131 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                            _14666 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14666 + 68] = mem[idx + _14131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14666 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14666 + -mem[64] + 100
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        _16220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16220] = 30
                        mem[_16220 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor9 / totalSupply)
                        _16516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16516 + 68] = mem[idx + _16220 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16516 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16516 + -mem[64] + 100
                    if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor15 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13554] = 30
                    mem[_13554 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                        _14130 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14130 + 68] = mem[idx + _13554 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14130 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14130 + -mem[64] + 100
                    if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _15721 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15721] = 30
                    mem[_15721 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                        _16219 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16219 + 68] = mem[idx + _15721 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16219 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16219 + -mem[64] + 100
                    if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                        revert with 0, 17
                    _17214 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17214] = 30
                    mem[_17214 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor15 / 100 / 100 * stor9 / totalSupply <= (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                        if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor9 / totalSupply)
                    _17323 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _17323 + 68] = mem[idx + _17214 + 32]
                        idx = idx + 32
                        continue 
                    mem[_17323 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17323 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor9 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor13 / 100 / 100:
                            if not arg1 * stor14 / 100 / 100:
                                if arg1 * stor15 / 100 / 100:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor15 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor14 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor14 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor13 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor14 / 100 / 100:
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor14 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor15 / 100 / 100:
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor15 / 100 / 100:
                                        revert with 0, 18
                                    if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * stor13 / 100 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor14 / 100 / 100 * t / s > -1 * arg1 * stor13 / 100 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * stor13 / 100 / 100 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * stor15 / 100 / 100 * t / s > (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and t / s > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * t / s / arg1 * stor13 / 100 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and t / s > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * t / s / arg1 * stor14 / 100 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and t / s > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * t / s / arg1 * stor15 / 100 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * stor13 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) < arg1 * stor14 / 100 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * t / s > (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * stor13 / 100 / 100 * t / s) - (arg1 * stor14 / 100 / 100 * t / s) < arg1 * stor15 / 100 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor13 / 100 / 100:
                        if not arg1 * stor14 / 100 / 100:
                            if arg1 * stor15 / 100 / 100:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor14 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor13 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor14 / 100 / 100:
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor14 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor15 / 100 / 100:
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                    revert with 0, 17
                                if not arg1 * stor15 / 100 / 100:
                                    revert with 0, 18
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                                if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor9 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor9 / totalSupply / arg1 != stor9 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor13 / 100 / 100:
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * stor13 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor13 / 100 / 100:
                        revert with 0, 17
                    if not arg1 * stor13 / 100 / 100:
                        revert with 0, 18
                    if arg1 * stor13 / 100 / 100 * stor9 / totalSupply / arg1 * stor13 / 100 / 100 != stor9 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor14 / 100 / 100:
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor14 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor14 / 100 / 100:
                            revert with 0, 17
                        if not arg1 * stor14 / 100 / 100:
                            revert with 0, 18
                        if arg1 * stor14 / 100 / 100 * stor9 / totalSupply / arg1 * stor14 / 100 / 100 != stor9 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor15 / 100 / 100:
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor15 / 100 / 100 and stor9 / totalSupply > -1 / arg1 * stor15 / 100 / 100:
                                revert with 0, 17
                            if not arg1 * stor15 / 100 / 100:
                                revert with 0, 18
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply / arg1 * stor15 / 100 / 100 != stor9 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor13 / 100 / 100 * stor9 / totalSupply > arg1 * stor9 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor9 / totalSupply < arg1 * stor13 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor14 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) < arg1 * stor14 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor15 / 100 / 100 * stor9 / totalSupply > (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor9 / totalSupply) - (arg1 * stor13 / 100 / 100 * stor9 / totalSupply) - (arg1 * stor14 / 100 / 100 * stor9 / totalSupply) < arg1 * stor15 / 100 / 100 * stor9 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor9 / totalSupply)
}



}
